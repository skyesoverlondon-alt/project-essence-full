<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Essence Crown: Shard Wars</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
/* Essence Crown: Shard Wars - Premium TCG Theme */
/* Inspired by Yu-Gi-Oh! Master Duel UI */

@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Rajdhani:wght@400;500;600;700&display=swap');

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --gold: #d4af37;
    --gold-light: #f4d03f;
    --gold-dark: #aa8a2e;
    --purple: #6b21a8;
    --purple-dark: #3b0764;
    --pink: #db2777;
    --void-black: #0a0a0f;
    --cosmic-blue: #1e3a5f;
    --essence-glow: #00ffcc;
    --damage-red: #ff4444;
    --card-border: #8b7355;
    --stone-light: #a89078;
    --stone-dark: #5c4a3a;
    --ec-bg: #050012;
    --ec-amethyst: #7c3aed;
    --ec-gold: #f6c453;
    --ec-teal: #14f4ff;
    --ec-panel-bg: rgba(12, 5, 25, 0.92);
    --ec-border: rgba(124, 58, 237, 0.4);
}

/* ===== NEW EARTH ARENA - .ec-* CLASSES ===== */

.ec-frame {
    position: relative;
    width: 100%;
    min-height: 100vh;
    min-height: 100dvh;
    height: auto;
    background: 
        radial-gradient(ellipse at 50% 0%, rgba(124, 58, 237, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 100%, rgba(246, 196, 83, 0.08) 0%, transparent 40%),
        linear-gradient(180deg, var(--ec-bg) 0%, #0a0020 50%, var(--ec-bg) 100%);
    display: flex;
    flex-direction: column;
    overflow: visible;
    font-family: 'Rajdhani', sans-serif;
    z-index: 10;
}

/* === HUD (Top & Bottom Bars) === */
.ec-hud {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 24px;
    background: linear-gradient(180deg, rgba(12, 5, 25, 0.95) 0%, rgba(20, 10, 35, 0.85) 100%);
    border: 1px solid var(--ec-border);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    z-index: 100;
}

.ec-hud--top {
    border-radius: 0 0 16px 16px;
    border-top: none;
}

.ec-hud--bottom {
    border-radius: 16px 16px 0 0;
    border-bottom: none;
}

.ec-hud-player {
    display: flex;
    align-items: center;
    gap: 16px;
}

.ec-hud-crest {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--ec-amethyst) 0%, var(--purple-dark) 100%);
    border: 3px solid var(--ec-gold);
    box-shadow: 0 0 20px rgba(246, 196, 83, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.ec-hud-crest .deity-card-frame {
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
}

.ec-hud-text {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.ec-hud-name {
    font-family: 'Cinzel', serif;
    font-size: 18px;
    font-weight: 700;
    color: var(--ec-gold);
    text-shadow: 0 0 10px rgba(246, 196, 83, 0.5);
}

.ec-hud-title {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.6);
    text-transform: uppercase;
    letter-spacing: 2px;
}

.ec-hud-bars {
    display: flex;
    align-items: center;
    gap: 20px;
    flex: 1;
    justify-content: center;
}

.ec-essence-bar {
    position: relative;
    width: 200px;
    height: 28px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid var(--ec-amethyst);
    border-radius: 14px;
    overflow: hidden;
}

.ec-essence-fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, var(--ec-teal) 0%, var(--ec-amethyst) 100%);
    transition: width 0.5s ease;
}

.ec-essence-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Cinzel', serif;
    font-size: 14px;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
    z-index: 1;
}

.ec-hud-stats {
    display: flex;
    gap: 12px;
}

.ec-pill {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 14px;
    background: rgba(20, 10, 40, 0.8);
    border: 1px solid var(--ec-border);
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.ec-pill:hover {
    background: rgba(124, 58, 237, 0.2);
    border-color: var(--ec-amethyst);
    transform: translateY(-2px);
}

.ec-pill-icon {
    font-size: 16px;
}

.ec-pill-value {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    font-weight: 700;
    color: var(--ec-gold);
}

.ec-pill-label {
    font-size: 10px;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.ec-pill--kl .ec-pill-value { color: var(--ec-teal); }
.ec-pill--deck .ec-pill-value { color: #a78bfa; }
.ec-pill--void .ec-pill-value { color: #f87171; }

.ec-phase-display {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.ec-phase-display #phase-badge {
    position: static;
    transform: none;
}

.ec-phase-display #phase-tracker {
    position: static;
    transform: none;
}

/* === MAIN CONTENT GRID === */
.ec-main {
    flex: 1;
    display: grid;
    grid-template-columns: 3fr 1.4fr;
    gap: 16px;
    padding: 16px;
    min-height: 0;
    min-width: 0;
    overflow: visible;
}

@media (max-width: 1400px) {
    .ec-main {
        grid-template-columns: 1fr;
    }
    .ec-side-panels {
        display: none;
    }
}

@media (max-width: 1000px) {
    .ec-main {
        padding: 8px;
        gap: 8px;
    }
}

/* === NEW EARTH ARENA === */
.ec-arena {
    background: 
        /* Constellation grid overlay */
        repeating-linear-gradient(
            0deg,
            transparent,
            transparent 60px,
            rgba(255, 215, 0, 0.04) 60px,
            rgba(255, 215, 0, 0.04) 61px
        ),
        repeating-linear-gradient(
            90deg,
            transparent,
            transparent 60px,
            rgba(255, 215, 0, 0.04) 60px,
            rgba(255, 215, 0, 0.04) 61px
        ),
        /* Shard engravings */
        radial-gradient(ellipse at 25% 30%, rgba(139, 92, 246, 0.08) 0%, transparent 40%),
        radial-gradient(ellipse at 75% 70%, rgba(212, 175, 55, 0.06) 0%, transparent 40%),
        /* Center glow */
        radial-gradient(ellipse at center, rgba(124, 58, 237, 0.12) 0%, transparent 50%),
        /* Cosmic stone base */
        linear-gradient(135deg, rgba(15, 10, 28, 0.95) 0%, rgba(22, 15, 40, 0.98) 100%);
    border: 2px solid var(--ec-border);
    border-radius: 16px;
    box-shadow: 
        0 0 40px rgba(124, 58, 237, 0.2),
        inset 0 0 80px rgba(124, 58, 237, 0.08),
        inset 0 0 2px rgba(212, 175, 55, 0.3);
    display: flex;
    flex-direction: column;
    overflow: visible;
}

.ec-arena-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 16px;
    gap: 12px;
}

/* === FIELD ROWS === */
.ec-field-row {
    display: grid;
    grid-template-columns: 1fr 2fr 1fr;
    gap: 12px;
}

.ec-field-row--opponent {
    transform: perspective(800px) rotateX(5deg);
}

.ec-field-row--player {
    transform: perspective(800px) rotateX(-5deg);
}

/* === ZONE PANELS === */
.ec-zone-panel {
    background: rgba(15, 8, 30, 0.7);
    border: 1px solid rgba(124, 58, 237, 0.3);
    border-radius: 12px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.ec-zone-panel--avatar {
    background: linear-gradient(135deg, rgba(124, 58, 237, 0.15) 0%, rgba(15, 8, 30, 0.8) 100%);
    border-color: var(--ec-amethyst);
    box-shadow: 0 0 20px rgba(124, 58, 237, 0.2);
}

.ec-zone-title {
    font-family: 'Cinzel', serif;
    font-size: 11px;
    font-weight: 700;
    color: var(--ec-gold);
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: center;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(246, 196, 83, 0.2);
}

.ec-zone-body {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    min-height: 80px;
}

/* === CARD SLOTS === */
.ec-card-slot {
    position: relative;
    width: clamp(50px, 6vw, 70px);
    height: clamp(70px, 8.5vw, 95px);
    background: 
        linear-gradient(135deg, rgba(20, 15, 35, 0.6) 0%, rgba(30, 20, 45, 0.7) 100%);
    border: 2px solid rgba(124, 58, 237, 0.35);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 
        inset 0 0 15px rgba(0, 0, 0, 0.3),
        0 2px 8px rgba(0, 0, 0, 0.2);
}

.ec-card-slot::before {
    content: '';
    position: absolute;
    inset: 3px;
    border: 1px solid rgba(124, 58, 237, 0.15);
    border-radius: 4px;
    pointer-events: none;
}

.ec-card-slot:hover {
    border-color: var(--ec-amethyst);
    background: 
        linear-gradient(135deg, rgba(124, 58, 237, 0.15) 0%, rgba(30, 20, 45, 0.8) 100%);
    box-shadow: 
        0 0 20px rgba(124, 58, 237, 0.4),
        inset 0 0 15px rgba(124, 58, 237, 0.1);
    transform: scale(1.02);
}

.ec-card-slot--avatar {
    border-color: rgba(246, 196, 83, 0.5);
}

.ec-card-slot--avatar.active {
    border: 2px solid var(--ec-gold);
    box-shadow: 0 0 25px rgba(246, 196, 83, 0.5);
    animation: ec-pulse 2s infinite;
}

@keyframes ec-pulse {
    0%, 100% { box-shadow: 0 0 25px rgba(246, 196, 83, 0.5); }
    50% { box-shadow: 0 0 40px rgba(246, 196, 83, 0.8); }
}

.ec-card-slot--domain { border-color: rgba(20, 244, 255, 0.4); }
.ec-card-slot--spell { border-color: rgba(168, 85, 247, 0.4); }
.ec-card-slot--relic { border-color: rgba(251, 191, 36, 0.4); }

/* === SHARD LINE === */
.ec-shard-line {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    justify-content: center;
}

.ec-shard {
    width: 28px;
    height: 28px;
    background: linear-gradient(135deg, var(--ec-gold) 0%, #b8860b 100%);
    border-radius: 50%;
    border: 2px solid var(--gold-light);
    box-shadow: 0 0 10px rgba(246, 196, 83, 0.5);
    transition: all 0.3s ease;
}

.ec-shard--faded {
    background: rgba(60, 40, 20, 0.5);
    border-color: rgba(184, 134, 11, 0.3);
    box-shadow: none;
    opacity: 0.4;
}

.ec-shard--claimed {
    background: linear-gradient(135deg, var(--ec-teal) 0%, var(--ec-amethyst) 100%);
    border-color: var(--ec-teal);
    box-shadow: 0 0 15px rgba(20, 244, 255, 0.6);
}

/* === DOMAIN ZONE (CENTER) === */
.ec-domain-zone {
    position: relative;
    background: 
        linear-gradient(90deg, transparent 0%, rgba(124, 58, 237, 0.15) 30%, rgba(212, 175, 55, 0.08) 50%, rgba(124, 58, 237, 0.15) 70%, transparent 100%);
    border-top: 2px solid rgba(246, 196, 83, 0.4);
    border-bottom: 2px solid rgba(246, 196, 83, 0.4);
    padding: 16px 24px;
    text-align: center;
    box-shadow: 
        0 0 30px rgba(212, 175, 55, 0.15),
        inset 0 0 20px rgba(124, 58, 237, 0.1);
}

.ec-domain-zone::before,
.ec-domain-zone::after {
    content: '‚óÜ';
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gold);
    font-size: 0.8em;
    opacity: 0.6;
    text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
}

.ec-domain-zone::before {
    left: 12px;
}

.ec-domain-zone::after {
    right: 12px;
}

.ec-domain-title {
    font-size: 10px;
    color: rgba(255, 255, 255, 0.6);
    text-transform: uppercase;
    letter-spacing: 3px;
    margin-bottom: 4px;
}

.ec-domain-name {
    font-family: 'Cinzel', serif;
    font-size: 20px;
    font-weight: 700;
    color: var(--ec-gold);
    text-shadow: 0 0 20px rgba(246, 196, 83, 0.5);
    margin: 4px 0;
}

.ec-domain-text {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
    font-style: italic;
}

/* === SIDE PANELS === */
.ec-side-panels {
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow: hidden;
}

.ec-panel {
    background: var(--ec-panel-bg);
    border: 1px solid var(--ec-border);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.ec-panel--codex {
    flex: 0 0 auto;
}

.ec-panel--chronicle {
    flex: 1;
    min-height: 0;
}

.ec-panel--actions {
    flex: 0 0 auto;
    padding: 12px;
}

.ec-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: linear-gradient(90deg, rgba(124, 58, 237, 0.2) 0%, transparent 100%);
    border-bottom: 1px solid var(--ec-border);
}

.ec-panel-title {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    font-weight: 700;
    color: var(--ec-gold);
}

.ec-panel-tag {
    font-size: 10px;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
    letter-spacing: 1px;
    background: rgba(124, 58, 237, 0.2);
    padding: 4px 10px;
    border-radius: 10px;
}

/* === CODEX VIEW === */
.ec-codex-card {
    padding: 16px;
}

.ec-codex-name {
    font-family: 'Cinzel', serif;
    font-size: 18px;
    font-weight: 700;
    color: #fff;
    margin-bottom: 8px;
}

.ec-codex-meta {
    font-size: 12px;
    color: var(--ec-amethyst);
    margin-bottom: 12px;
}

.ec-codex-body {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.85);
    line-height: 1.5;
    margin-bottom: 12px;
}

.ec-codex-flavor {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.5);
    font-style: italic;
    border-top: 1px solid var(--ec-border);
    padding-top: 10px;
}

/* === BATTLE CHRONICLE === */
.ec-chronicle-body {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.ec-chronicle-entry {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
    padding: 8px 12px;
    background: rgba(20, 10, 40, 0.5);
    border-radius: 6px;
    border-left: 3px solid var(--ec-amethyst);
}

.ec-chronicle-entry.action { border-left-color: var(--ec-teal); }
.ec-chronicle-entry.damage { border-left-color: var(--damage-red); }
.ec-chronicle-entry.heal { border-left-color: var(--essence-glow); }
.ec-chronicle-entry.phase { border-left-color: var(--ec-gold); }

.chronicle-turn {
    display: inline-block;
    background: var(--ec-amethyst);
    color: #fff;
    font-size: 10px;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 8px;
}

/* === COMMAND HAND BAR === */
.ec-hand-bar {
    background: 
        linear-gradient(0deg, rgba(10, 5, 20, 0.98) 0%, rgba(18, 10, 32, 0.95) 100%);
    border-top: 2px solid rgba(212, 175, 55, 0.4);
    padding: 12px 20px 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex-shrink: 0;
    position: relative;
    z-index: 50;
    box-shadow: 
        0 -4px 20px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(212, 175, 55, 0.1);
}

.ec-hand-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.ec-hand-title {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    font-weight: 700;
    color: var(--ec-gold);
}

.ec-hand-info {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.6);
}

.ec-hand-cards {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: nowrap;
    min-height: 120px;
    overflow-x: auto;
    padding: 10px 0;
}

.ec-hand-cards::-webkit-scrollbar {
    height: 6px;
}

.ec-hand-cards::-webkit-scrollbar-track {
    background: rgba(124, 58, 237, 0.1);
    border-radius: 3px;
}

.ec-hand-cards::-webkit-scrollbar-thumb {
    background: var(--ec-amethyst);
    border-radius: 3px;
}

/* Hand cards styling */
.ec-hand-cards .game-card {
    width: 80px;
    min-width: 80px;
    height: 110px;
    flex-shrink: 0;
    border-radius: 8px;
    background: linear-gradient(135deg, rgba(30, 20, 50, 0.95) 0%, rgba(15, 10, 30, 1) 100%);
    border: 2px solid var(--ec-border);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.ec-hand-cards .game-card:hover {
    transform: translateY(-20px) scale(1.1);
    border-color: var(--ec-gold);
    box-shadow: 0 15px 40px rgba(246, 196, 83, 0.4);
    z-index: 100;
}

.ec-hand-cards .game-card .card-front {
    width: 100%;
    height: 100%;
    position: relative;
}

.ec-hand-cards .game-card .card-image {
    width: 100%;
    height: 70%;
    object-fit: cover;
    border-radius: 6px 6px 0 0;
}

.ec-hand-cards .game-card .card-cost {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 22px;
    height: 22px;
    background: linear-gradient(135deg, var(--ec-teal) 0%, var(--ec-amethyst) 100%);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Cinzel', serif;
    font-size: 12px;
    font-weight: 700;
    color: #fff;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
}

.ec-hand-cards .game-card .card-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(0deg, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.7) 70%, transparent 100%);
    padding: 6px 4px 4px;
}

.ec-hand-cards .game-card .card-name {
    font-family: 'Cinzel', serif;
    font-size: 9px;
    font-weight: 700;
    color: #fff;
    text-align: center;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.ec-hand-cards .game-card .card-stats {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-top: 2px;
}

.ec-hand-cards .game-card .card-stats .stat {
    font-size: 10px;
    font-weight: 700;
}

.ec-hand-cards .game-card .card-stats .stat.attack {
    color: #ff6b6b;
}

.ec-hand-cards .game-card .card-stats .stat.health {
    color: #4ade80;
}

.ec-hand-cards .game-card .health-bar {
    display: none;
}

.ec-hand-cards .game-card .guardian-badge,
.ec-hand-cards .game-card .beast-badge {
    font-size: 7px;
    padding: 1px 3px;
}

/* Hand content layout with deck and graveyard */
.ec-hand-content {
    display: flex;
    align-items: center;
    gap: 20px;
    justify-content: center;
}

/* Deck pile */
.ec-deck-pile {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    padding: 8px;
    border-radius: 12px;
    background: rgba(20, 10, 40, 0.5);
    border: 2px solid transparent;
}

.ec-deck-pile:hover {
    transform: scale(1.05);
    border-color: var(--ec-gold);
    box-shadow: 0 0 20px rgba(246, 196, 83, 0.3);
}

.ec-deck-pile.can-draw {
    animation: deckGlow 2s infinite;
}

@keyframes deckGlow {
    0%, 100% { box-shadow: 0 0 10px rgba(20, 244, 255, 0.3); }
    50% { box-shadow: 0 0 25px rgba(20, 244, 255, 0.6); }
}

.ec-deck-stack {
    position: relative;
    width: 60px;
    height: 85px;
}

.ec-deck-card {
    position: absolute;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #2a1a4a 0%, #1a0a2a 100%);
    border: 2px solid var(--ec-amethyst);
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
}

.ec-deck-card::before {
    content: 'üÉè';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    opacity: 0.5;
}

.ec-deck-card:nth-child(1) { top: 0; left: 0; }
.ec-deck-card:nth-child(2) { top: -3px; left: 3px; }
.ec-deck-card:nth-child(3) { top: -6px; left: 6px; }

.ec-deck-count {
    font-family: 'Cinzel', serif;
    font-size: 18px;
    font-weight: 700;
    color: var(--ec-teal);
    text-shadow: 0 0 10px rgba(20, 244, 255, 0.5);
}

.ec-deck-label {
    font-size: 10px;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
    letter-spacing: 2px;
}

/* Graveyard pile */
.ec-graveyard-pile {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    padding: 8px;
    border-radius: 12px;
    background: rgba(40, 10, 20, 0.5);
    border: 2px solid transparent;
}

.ec-graveyard-pile:hover {
    transform: scale(1.05);
    border-color: #ff4444;
    box-shadow: 0 0 20px rgba(255, 68, 68, 0.3);
}

.ec-graveyard-icon {
    width: 60px;
    height: 85px;
    background: linear-gradient(135deg, #2a0a1a 0%, #1a0a0a 100%);
    border: 2px solid rgba(255, 68, 68, 0.5);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
}

.ec-graveyard-count {
    font-family: 'Cinzel', serif;
    font-size: 18px;
    font-weight: 700;
    color: #ff6b6b;
}

.ec-graveyard-label {
    font-size: 10px;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
    letter-spacing: 2px;
}

/* Persistent Game Controls */
.ec-game-controls {
    position: fixed;
    top: 12px;
    right: 12px;
    display: none;
    gap: 8px;
    z-index: 1000;
}

#game-container:not([style*="display: none"]) .ec-game-controls {
    display: flex;
}

.ec-ctrl-btn {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: linear-gradient(135deg, rgba(12, 5, 25, 0.95) 0%, rgba(20, 10, 35, 0.9) 100%);
    border: 2px solid var(--ec-border);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
}

.ec-ctrl-btn:hover {
    transform: scale(1.1);
    border-color: var(--ec-gold);
    box-shadow: 0 0 20px rgba(246, 196, 83, 0.4);
}

.ec-ctrl-btn .ctrl-icon {
    font-size: 20px;
}

/* Pause Menu Overlay */
.ec-pause-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(8px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.ec-pause-overlay.hidden {
    display: none;
}

.ec-pause-menu {
    background: linear-gradient(135deg, rgba(12, 5, 25, 0.98) 0%, rgba(30, 15, 50, 0.95) 100%);
    border: 3px solid var(--ec-gold);
    border-radius: 20px;
    padding: 40px 60px;
    text-align: center;
    box-shadow: 0 0 60px rgba(246, 196, 83, 0.3), 0 20px 60px rgba(0, 0, 0, 0.8);
    min-width: 320px;
}

.pause-title {
    font-family: 'Cinzel', serif;
    font-size: 32px;
    font-weight: 700;
    color: var(--ec-gold);
    text-shadow: 0 0 20px rgba(246, 196, 83, 0.5);
    margin: 0 0 30px 0;
    letter-spacing: 3px;
}

.pause-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.pause-btn {
    padding: 14px 30px;
    font-family: 'Cinzel', serif;
    font-size: 16px;
    font-weight: 600;
    color: #fff;
    background: linear-gradient(135deg, var(--ec-amethyst) 0%, #5b21b6 100%);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.pause-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(124, 58, 237, 0.5);
    border-color: var(--ec-gold);
}

.pause-btn--danger {
    background: linear-gradient(135deg, #991b1b 0%, #7f1d1d 100%);
}

.pause-btn--danger:hover {
    box-shadow: 0 8px 25px rgba(220, 38, 38, 0.5);
}

/* Draw animation */
.ec-draw-animation {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    width: 80px;
    height: 110px;
    background: linear-gradient(135deg, #2a1a4a 0%, #1a0a2a 100%);
    border: 2px solid var(--ec-gold);
    border-radius: 8px;
    box-shadow: 0 0 30px rgba(246, 196, 83, 0.6);
    animation: drawToHand 0.5s ease-out forwards;
}

@keyframes drawToHand {
    0% {
        opacity: 1;
        transform: scale(1);
    }
    50% {
        transform: scale(1.2) rotate(10deg);
    }
    100% {
        opacity: 0;
        transform: scale(0.8) translateY(20px);
    }
}

.ec-hand-card {
    width: 75px;
    padding: 10px 8px;
    background: linear-gradient(135deg, rgba(30, 20, 50, 0.9) 0%, rgba(15, 10, 30, 0.95) 100%);
    border: 2px solid var(--ec-border);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.ec-hand-card:hover {
    transform: translateY(-10px) scale(1.05);
    border-color: var(--ec-gold);
    box-shadow: 0 10px 30px rgba(246, 196, 83, 0.3);
    z-index: 10;
}

.ec-hand-card-type {
    font-size: 9px;
    color: var(--ec-amethyst);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.ec-hand-card-name {
    font-family: 'Cinzel', serif;
    font-size: 11px;
    font-weight: 700;
    color: #fff;
    margin-top: 4px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* === QUICK ACTIONS PANEL === */
.ec-panel--actions #turn-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
}

.ec-panel--actions #side-panel {
    display: flex;
    gap: 8px;
    justify-content: center;
    position: static;
    transform: none;
    flex-direction: row;
}

.ec-panel--actions .panel-btn {
    width: 40px;
    height: 40px;
    font-size: 16px;
}

.ec-panel--actions .turn-btn {
    flex: 1;
    padding: 12px;
    font-size: 13px;
}

/* === HIDDEN LEGACY ELEMENTS === */
.hidden-badge {
    display: none !important;
}

/* ===== PROFILE MODAL ===== */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10000;
}

.modal:not(.hidden) {
    display: flex;
}

.modal.hidden {
    display: none;
}

.modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(5, 2, 15, 0.9);
    backdrop-filter: blur(4px);
}

.modal-content {
    position: relative;
    background: 
        linear-gradient(135deg, rgba(25, 18, 42, 0.98) 0%, rgba(18, 12, 32, 0.99) 100%);
    border: 2px solid var(--gold);
    border-radius: 12px;
    padding: 40px;
    max-width: 500px;
    margin: auto;
    z-index: 10001;
    box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.7),
        0 0 50px rgba(212, 175, 55, 0.3),
        inset 0 0 60px rgba(139, 92, 246, 0.1);
}

.modal-content::before {
    content: '';
    position: absolute;
    top: -2px;
    left: 50%;
    transform: translateX(-50%);
    width: 70%;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    border-bottom: 2px solid var(--gold);
    padding-bottom: 15px;
}

.modal-header h2 {
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 24px;
    margin: 0;
}

.modal-close {
    background: none;
    border: none;
    color: var(--gold);
    font-size: 28px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    color: var(--gold-light);
}

.profile-form {
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.form-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.form-group label {
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.form-group input {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid var(--gold);
    color: white;
    padding: 12px;
    border-radius: 8px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 16px;
}

.form-group input:focus {
    outline: none;
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
}

.avatar-options {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
}

.avatar-option {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid transparent;
    border-radius: 10px;
    padding: 15px;
    text-align: center;
    font-size: 32px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.avatar-option:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: scale(1.1);
}

.avatar-option.selected {
    border-color: var(--gold);
    background: rgba(212, 175, 55, 0.2);
    box-shadow: 0 0 15px rgba(212, 175, 55, 0.6);
}

.btn-primary {
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-light) 100%);
    color: #000;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-family: 'Cinzel', serif;
    font-weight: 700;
    cursor: pointer;
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s ease;
}

.btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(212, 175, 55, 0.3);
}

.btn-secondary {
    background: transparent;
    color: var(--gold);
    border: 2px solid var(--gold);
    padding: 12px 24px;
    border-radius: 8px;
    font-family: 'Cinzel', serif;
    font-weight: 600;
    cursor: pointer;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s ease;
}

.btn-secondary:hover {
    background: rgba(212, 175, 55, 0.1);
}

/* ===== ENHANCED PROFILE MODAL ===== */
.profile-modal-enhanced {
    max-width: 650px !important;
    max-height: 85vh;
    overflow-y: auto;
}

.profile-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 25px;
    border-bottom: 2px solid rgba(212, 175, 55, 0.3);
    padding-bottom: 15px;
}

.profile-tab {
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.6);
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    font-weight: 600;
    padding: 10px 20px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s ease;
    border-radius: 8px;
}

.profile-tab:hover {
    color: white;
    background: rgba(255, 255, 255, 0.1);
}

.profile-tab.active {
    color: var(--gold);
    background: rgba(212, 175, 55, 0.2);
}

.profile-tab-content {
    display: none;
}

.profile-tab-content.active {
    display: block;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Avatar Options Enhanced */
.avatar-options.enhanced {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
}

.avatar-options.enhanced .avatar-option {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    padding: 12px 8px;
}

.avatar-icon {
    font-size: 28px;
}

.avatar-label {
    font-size: 11px;
    color: rgba(255, 255, 255, 0.7);
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Title Options */
.title-options {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}

.title-option {
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid transparent;
    border-radius: 8px;
    padding: 12px;
    text-align: center;
    color: white;
    cursor: pointer;
    font-family: 'Cinzel', serif;
    font-size: 13px;
    transition: all 0.3s ease;
}

.title-option:hover:not(.locked) {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(212, 175, 55, 0.5);
}

.title-option.selected {
    border-color: var(--gold);
    background: rgba(212, 175, 55, 0.2);
    box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
}

.title-option.locked {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Card Back Options */
.cardback-options, .border-options {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
}

.cardback-option, .border-option {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.cardback-option:hover:not(.locked), .border-option:hover:not(.locked) {
    background: rgba(255, 255, 255, 0.1);
}

.cardback-option.selected, .border-option.selected {
    border-color: var(--gold);
    background: rgba(212, 175, 55, 0.15);
}

.cardback-option.locked, .border-option.locked {
    opacity: 0.4;
    cursor: not-allowed;
}

.cardback-preview {
    width: 50px;
    height: 70px;
    border-radius: 6px;
    border: 2px solid rgba(255, 255, 255, 0.3);
}

.cardback-preview.default { background: linear-gradient(135deg, #3b0764 0%, #6b21a8 100%); }
.cardback-preview.cosmic { background: linear-gradient(135deg, #0f0f3f 0%, #1e3a5f 50%, #6b21a8 100%); }
.cardback-preview.void { background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 100%); }
.cardback-preview.golden { background: linear-gradient(135deg, #aa8a2e 0%, #f4d03f 50%, #d4af37 100%); }

.border-preview {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 3px solid;
}

.border-preview.bronze { border-color: #cd7f32; background: linear-gradient(135deg, #cd7f32 0%, #8b4513 100%); }
.border-preview.silver { border-color: #c0c0c0; background: linear-gradient(135deg, #c0c0c0 0%, #808080 100%); }
.border-preview.gold { border-color: #ffd700; background: linear-gradient(135deg, #ffd700 0%, #d4af37 100%); }
.border-preview.divine { border-color: #ff6b9d; background: linear-gradient(135deg, #ff6b9d 0%, #6b21a8 50%, #00ffcc 100%); }

.cardback-option span, .border-option span {
    font-size: 11px;
    color: rgba(255, 255, 255, 0.8);
    text-transform: uppercase;
}

/* Stats Grid */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    margin-bottom: 25px;
}

.stat-card {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    padding: 20px 15px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.stat-card.wins { border-color: rgba(0, 255, 150, 0.3); }
.stat-card.losses { border-color: rgba(255, 68, 68, 0.3); }
.stat-card.winrate { border-color: rgba(212, 175, 55, 0.3); }

.stat-value {
    font-family: 'Cinzel', serif;
    font-size: 28px;
    font-weight: 700;
    color: var(--gold);
    margin-bottom: 5px;
}

.stat-label {
    font-size: 11px;
    color: rgba(255, 255, 255, 0.6);
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Match History */
.recent-matches h3 {
    color: var(--gold);
    font-family: 'Cinzel', serif;
    margin-bottom: 15px;
    font-size: 16px;
}

.match-history {
    max-height: 150px;
    overflow-y: auto;
}

.match-entry {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 10px 15px;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 8px;
    margin-bottom: 8px;
    border-left: 3px solid;
}

.match-entry.win { border-color: #00ff96; }
.match-entry.loss { border-color: #ff4444; }

.match-result {
    font-size: 18px;
    font-weight: bold;
}

.match-entry.win .match-result { color: #00ff96; }
.match-entry.loss .match-result { color: #ff4444; }

.match-opponent {
    flex: 1;
    color: white;
}

.match-mode {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
}

.no-matches {
    text-align: center;
    color: rgba(255, 255, 255, 0.4);
    padding: 30px;
    font-style: italic;
}

.profile-actions {
    display: flex;
    justify-content: flex-end;
    gap: 15px;
    margin-top: 25px;
    padding-top: 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

#profile-deity-select {
    width: 100%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid var(--gold);
    color: white;
    padding: 12px;
    border-radius: 8px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    cursor: pointer;
}

#profile-deity-select option {
    background: #1a0a2e;
    color: white;
}

/* ===== MATCH INTRO CINEMATIC ===== */
.match-intro {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10001;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

.match-intro.hidden {
    display: none;
}

.intro-bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0d1b2a 100%);
    z-index: 0;
}

.intro-bg::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        radial-gradient(ellipse at 20% 30%, rgba(107, 33, 168, 0.4) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 70%, rgba(219, 39, 119, 0.3) 0%, transparent 50%);
    animation: introGlow 3s ease-in-out infinite alternate;
}

@keyframes introGlow {
    from { opacity: 0.5; }
    to { opacity: 1; }
}

.intro-content {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 80px;
    z-index: 1;
    width: 100%;
    padding: 0 50px;
}

.duelist {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    opacity: 0;
    transform: translateX(-100px);
}

.duelist-right {
    transform: translateX(100px);
}

.match-intro.animating .duelist {
    animation: duelistSlide 0.8s ease-out forwards;
}

.match-intro.animating .duelist-right {
    animation: duelistSlideRight 0.8s ease-out forwards;
}

@keyframes duelistSlide {
    from { opacity: 0; transform: translateX(-100px); }
    to { opacity: 1; transform: translateX(0); }
}

@keyframes duelistSlideRight {
    from { opacity: 0; transform: translateX(100px); }
    to { opacity: 1; transform: translateX(0); }
}

.duelist-avatar {
    font-size: 80px;
    width: 140px;
    height: 140px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, rgba(107, 33, 168, 0.5) 0%, rgba(219, 39, 119, 0.5) 100%);
    border: 4px solid var(--gold);
    border-radius: 50%;
    box-shadow: 
        0 0 30px rgba(212, 175, 55, 0.5),
        inset 0 0 30px rgba(0, 0, 0, 0.3);
}

.duelist-name {
    font-family: 'Cinzel', serif;
    font-size: 32px;
    font-weight: 700;
    color: white;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
}

.duelist-title {
    font-family: 'Rajdhani', sans-serif;
    font-size: 16px;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 3px;
}

.duelist-deity {
    font-family: 'Cinzel', serif;
    font-size: 18px;
    color: rgba(255, 255, 255, 0.8);
}

.vs-emblem {
    position: relative;
    opacity: 0;
    transform: scale(0);
}

.match-intro.vs-slam .vs-emblem {
    animation: vsSlamIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
}

@keyframes vsSlamIn {
    from { opacity: 0; transform: scale(3); }
    to { opacity: 1; transform: scale(1); }
}

.vs-text {
    font-family: 'Cinzel', serif;
    font-size: 72px;
    font-weight: 900;
    color: var(--gold);
    text-shadow: 
        0 0 30px rgba(212, 175, 55, 0.8),
        0 0 60px rgba(212, 175, 55, 0.5),
        0 4px 0 #aa8a2e;
    position: relative;
    z-index: 2;
}

.vs-glow {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 200px;
    height: 200px;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, rgba(212, 175, 55, 0.4) 0%, transparent 70%);
    animation: vsGlowPulse 1s ease-in-out infinite alternate;
    z-index: 1;
}

@keyframes vsGlowPulse {
    from { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
    to { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
}

.intro-bottom {
    position: absolute;
    bottom: 80px;
    left: 0;
    right: 0;
    text-align: center;
    z-index: 1;
}

.battle-quote {
    font-family: 'Cinzel', serif;
    font-size: 22px;
    color: rgba(255, 255, 255, 0.9);
    font-style: italic;
    text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
    opacity: 0;
}

.match-intro.animating .battle-quote {
    animation: quoteReveal 1s ease-out 1.5s forwards;
}

@keyframes quoteReveal {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

.intro-progress {
    width: 300px;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    margin: 30px auto 0;
    border-radius: 2px;
    overflow: hidden;
}

.match-intro.animating .intro-progress::after {
    content: '';
    display: block;
    width: 0;
    height: 100%;
    background: linear-gradient(90deg, var(--gold), var(--gold-light));
    animation: progressFill 3.5s linear forwards;
}

@keyframes progressFill {
    to { width: 100%; }
}

.match-intro.fade-out {
    animation: introFadeOut 0.5s ease-out forwards;
}

@keyframes introFadeOut {
    to { opacity: 0; }
}

html, body {
    width: 100%;
    min-height: 100%;
    min-height: 100dvh;
    overflow-x: hidden;
    overflow-y: auto;
    font-family: 'Rajdhani', sans-serif;
    background: #000;
}

/* ===== GAME CONTAINER ===== */
#game-container {
    width: 100%;
    min-height: 100vh;
    min-height: 100dvh;
    position: relative;
    overflow: visible;
    background: linear-gradient(180deg, #1a0a2e 0%, #0d1b2a 50%, #1a0a2e 100%);
}

/* Cosmic Background */
#game-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        radial-gradient(ellipse at 20% 20%, rgba(107, 33, 168, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(219, 39, 119, 0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(0, 255, 204, 0.1) 0%, transparent 40%);
    pointer-events: none;
    z-index: 0;
}

/* === BOARD CSS START === */
/* ===== GAME BOARD - NEW EARTH ARENA ===== */
/* Legacy #game-board styles removed - now using .ec-frame */

@keyframes boardPulse {
    0%, 100% {
        box-shadow: 
            0 40px 80px rgba(0, 0, 0, 0.8),
            inset 0 0 100px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(107, 33, 168, 0.6),
            inset 0 2px 10px rgba(255, 255, 255, 0.05),
            0 0 100px rgba(147, 51, 234, 0.3);
    }
    50% {
        box-shadow: 
            0 50px 100px rgba(0, 0, 0, 0.9),
            inset 0 0 150px rgba(0, 0, 0, 0.6),
            0 0 100px rgba(107, 33, 168, 0.8),
            inset 0 2px 15px rgba(255, 255, 255, 0.1),
            0 0 150px rgba(147, 51, 234, 0.5);
    }
}

/* Legacy #game-board::before and .player-zone styles removed - using .ec-* classes */

/* ===== DEITY DISPLAY (Left Side) - TABLETOP ANIME STYLE ===== */
.deity-display {
    width: 130px;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 8px;
    position: relative;
    filter: drop-shadow(0 0 30px rgba(147, 51, 234, 0.4));
    animation: deityHover 3s ease-in-out infinite;
}

@keyframes deityHover {
    0%, 100% {
        transform: translateY(0) translateZ(0);
    }
    50% {
        transform: translateY(-15px) translateZ(0);
    }
}

.deity-card-frame {
    width: 110px;
    height: 155px;
    border-radius: 12px;
    overflow: hidden;
    border: 4px solid var(--gold);
    box-shadow: 
        0 15px 40px rgba(0, 0, 0, 0.8),
        0 0 30px rgba(212, 175, 55, 0.8),
        inset 0 0 20px rgba(0, 255, 204, 0.2),
        0 0 50px rgba(147, 51, 234, 0.5);
    position: relative;
    background: linear-gradient(135deg, #2a1a3a 0%, #1a0a2a 100%);
    animation: deityGlow 4s ease-in-out infinite;
    transform-style: preserve-3d;
}

@keyframes deityGlow {
    0%, 100% {
        box-shadow: 
            0 15px 40px rgba(0, 0, 0, 0.8),
            0 0 30px rgba(212, 175, 55, 0.8),
            inset 0 0 20px rgba(0, 255, 204, 0.2),
            0 0 50px rgba(147, 51, 234, 0.5);
    }
    50% {
        box-shadow: 
            0 15px 50px rgba(0, 0, 0, 0.9),
            0 0 50px rgba(212, 175, 55, 1),
            inset 0 0 30px rgba(0, 255, 204, 0.4),
            0 0 80px rgba(147, 51, 234, 0.8);
    }
}

.deity-card-frame img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    filter: saturate(1.2) brightness(1.05);
}

.deity-card-frame::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, transparent 60%, rgba(0, 0, 0, 0.7) 100%);
    pointer-events: none;
    animation: deityShine 6s ease-in-out infinite;
}

@keyframes deityShine {
    0%, 100% { opacity: 0; }
    50% { opacity: 0.3; }
}

.deity-name-label {
    font-family: 'Cinzel', serif;
    font-size: 10px;
    color: var(--gold);
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
    animation: labelGlow 2s ease-in-out infinite;
}

@keyframes labelGlow {
    0%, 100% { text-shadow: 0 0 10px rgba(212, 175, 55, 0.8); }
    50% { text-shadow: 0 0 20px rgba(212, 175, 55, 1); }
}

/* ===== LIFE POINTS BADGES (Corners) ===== */
.life-badge {
    position: absolute;
    width: 85px;
    height: 85px;
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Cinzel', serif;
    z-index: 100;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}

.life-badge:hover {
    transform: scale(1.1);
}

.life-badge.player-1 {
    bottom: 15px;
    left: 15px;
    background: linear-gradient(135deg, #1e3a5f 0%, #0d1b2a 100%);
    border: 3px solid #4a90d9;
    box-shadow: 
        0 0 30px rgba(74, 144, 217, 0.5),
        inset 0 0 20px rgba(74, 144, 217, 0.2);
}

.life-badge.player-2 {
    top: 15px;
    right: 15px;
    background: linear-gradient(135deg, #5f1e1e 0%, #2a0d0d 100%);
    border: 3px solid #d94a4a;
    box-shadow: 
        0 0 30px rgba(217, 74, 74, 0.5),
        inset 0 0 20px rgba(217, 74, 74, 0.2);
}

.life-badge .life-value {
    font-size: 22px;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 0 10px currentColor;
}

.life-badge .life-label {
    font-size: 9px;
    color: rgba(255, 255, 255, 0.7);
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* ===== KL BADGE (Resource) ===== */
.kl-badge {
    position: absolute;
    width: 55px;
    height: 55px;
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #2d1b4e 0%, #1a0a2e 100%);
    border: 2px solid var(--purple);
    box-shadow: 0 0 20px rgba(107, 33, 168, 0.5);
    font-family: 'Cinzel', serif;
    z-index: 100;
    cursor: pointer;
    transition: transform 0.2s;
}

.kl-badge:hover {
    transform: scale(1.1);
}

.kl-badge.player-1 {
    bottom: 110px;
    left: 25px;
}

.kl-badge.player-2 {
    top: 110px;
    right: 25px;
}

.kl-badge .kl-value {
    font-size: 16px;
    font-weight: 700;
    color: var(--essence-glow);
    text-shadow: 0 0 10px var(--essence-glow);
}

.kl-badge .kl-label {
    font-size: 7px;
    color: rgba(255, 255, 255, 0.6);
}

/* ===== BOARD ZONES (Card Slots) ===== */
.board-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.board-row {
    display: flex;
    justify-content: center;
    gap: 8px;
    flex: 1;
}

.row-label {
    position: absolute;
    left: -60px;
    font-size: 9px;
    color: rgba(255, 255, 255, 0.4);
    text-transform: uppercase;
    writing-mode: vertical-rl;
    transform: rotate(180deg);
}

.card-slot {
    width: 75px;
    height: 105px;
    border-radius: 8px;
    background: 
        linear-gradient(135deg, rgba(168, 144, 120, 0.25) 0%, rgba(92, 74, 58, 0.25) 100%);
    border: 2px solid rgba(139, 115, 85, 0.4);
    box-shadow: 
        inset 0 0 15px rgba(0, 0, 0, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.3);
    position: relative;
    transition: all 0.3s ease;
}

.card-slot:hover {
    border-color: var(--gold);
    box-shadow: 
        inset 0 0 15px rgba(0, 0, 0, 0.4),
        0 0 15px rgba(212, 175, 55, 0.3);
}

.card-slot.highlighted {
    border-color: var(--essence-glow);
    box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
}

/* Slot decorative corners */
.card-slot::before,
.card-slot::after {
    content: '';
    position: absolute;
    width: 10px;
    height: 10px;
    border: 2px solid rgba(139, 115, 85, 0.3);
}

.card-slot::before {
    top: 3px;
    left: 3px;
    border-right: none;
    border-bottom: none;
}

.card-slot::after {
    bottom: 3px;
    right: 3px;
    border-left: none;
    border-top: none;
}

/* ===== ZONE LABELS ===== */
.zone-label-row {
    display: flex;
    justify-content: center;
    margin: 2px 0;
}

.zone-label {
    font-family: 'Cinzel', serif;
    font-size: 9px;
    font-weight: 600;
    color: rgba(212, 175, 55, 0.6);
    text-transform: uppercase;
    letter-spacing: 2px;
    padding: 2px 12px;
    background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.1), transparent);
    border-radius: 4px;
}

/* ===== ZONE-SPECIFIC SLOT STYLING ===== */
.avatar-row {
    position: relative;
}

.avatar-row::before {
    content: '';
    position: absolute;
    inset: -4px;
    border: 1px solid rgba(255, 215, 0, 0.15);
    border-radius: 12px;
    pointer-events: none;
}

.domain-row::before {
    content: '';
    position: absolute;
    inset: -4px;
    border: 1px solid rgba(147, 51, 234, 0.15);
    border-radius: 12px;
    pointer-events: none;
}

.avatar-slot {
    border-color: rgba(255, 215, 0, 0.3);
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.08) 0%, rgba(139, 92, 0, 0.08) 100%);
}

.avatar-slot::before,
.avatar-slot::after {
    border-color: rgba(255, 215, 0, 0.25);
}

.domain-slot {
    border-color: rgba(147, 51, 234, 0.4);
    background: linear-gradient(135deg, rgba(147, 51, 234, 0.12) 0%, rgba(76, 29, 149, 0.12) 100%);
}

.domain-slot::before,
.domain-slot::after {
    border-color: rgba(147, 51, 234, 0.35);
}

.spell-slot {
    border-color: rgba(59, 130, 246, 0.4);
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(30, 64, 175, 0.08) 100%);
}

.spell-slot::before,
.spell-slot::after {
    border-color: rgba(59, 130, 246, 0.3);
}

.relic-slot {
    border-color: rgba(212, 175, 55, 0.4);
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.1) 0%, rgba(161, 122, 24, 0.1) 100%);
}

.relic-slot::before,
.relic-slot::after {
    border-color: rgba(212, 175, 55, 0.3);
}

/* ===== DECK/GRAVEYARD PORTALS ===== */
.pile-zone {
    width: 90px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
}

.deck-portal, .grave-portal {
    width: 70px;
    height: 70px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s;
    position: relative;
    border: 3px solid var(--card-border);
    font-size: 28px;
}

.deck-portal {
    background: linear-gradient(135deg, #2a1a3a 0%, #1a0a2a 100%);
    box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.4),
        inset 0 0 20px rgba(0, 0, 0, 0.3);
}

.deck-portal::before {
    content: 'üìñ';
    position: absolute;
    font-size: 32px;
    text-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
}

.grave-portal {
    background: 
        radial-gradient(circle, #1a0a0a 0%, #0a0505 70%),
        conic-gradient(from 0deg, #6b21a8, #db2777, #6b21a8);
    border: 3px solid var(--purple);
    box-shadow: 
        0 0 30px rgba(107, 33, 168, 0.6),
        inset 0 0 30px rgba(0, 0, 0, 0.8);
    overflow: hidden;
}

.grave-portal::before {
    content: '';
    position: absolute;
    width: 200%;
    height: 200%;
    background: conic-gradient(from 0deg, transparent, var(--purple), transparent, var(--pink), transparent);
    animation: portal-spin 4s linear infinite;
    opacity: 0.5;
    z-index: -1;
}

@keyframes portal-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.deck-portal:hover, .grave-portal:hover {
    transform: scale(1.1);
}

.pile-count {
    position: absolute;
    bottom: -6px;
    right: -6px;
    background: var(--void-black);
    color: #fff;
    font-size: 11px;
    font-weight: 700;
    padding: 2px 7px;
    border-radius: 10px;
    border: 2px solid var(--gold);
    z-index: 1;
}

.pile-label {
    font-size: 9px;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* ===== HAND ZONE ===== */
/* Legacy #hand-zone styles overridden - now using .ec-hand-bar layout */
#hand-zone.ec-hand-bar {
    position: relative;
    bottom: auto;
    left: auto;
    transform: none;
    height: auto;
}

/* ===== SUN ALTAR INTEGRATION ===== */
.ec-deck-fracture-zones {
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 10px;
    position: absolute;
    left: 20px;
    bottom: 50%;
    flex-direction: column;
}

.chronicle-content.collapsed {
    display: none;
}

/* Deity Ring Integration */
.deity-ring {
    flex-shrink: 0;
}

.deity-ring .deity-card-inner {
    width: 60px;
    height: 84px;
    border-radius: 6px;
    overflow: hidden;
    background: linear-gradient(135deg, #2a1f4d 0%, #1a1030 100%);
    display: flex;
    align-items: center;
    justify-content: center;
}

.deity-ring .deity-card-inner img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* Essence HUD adjustments */
.essence-hud {
    display: flex;
    align-items: center;
    gap: 16px;
    flex: 1;
}

.essence-counter {
    position: relative;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.essence-glyph {
    position: absolute;
    inset: 0;
    border: 2px solid var(--domain-second-sun, #FFD700);
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255, 215, 0, 0.15) 0%, transparent 70%);
    animation: essence-pulse 3s ease-in-out infinite;
}

@keyframes essence-pulse {
    0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
    50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
}

.kl-display {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.kl-pips {
    display: flex;
    gap: 3px;
}

.kl-pip {
    width: 14px;
    height: 18px;
    background: rgba(139, 92, 246, 0.2);
    border: 1px solid rgba(139, 92, 246, 0.4);
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    transition: all 0.3s ease;
}

.kl-pip.active {
    background: linear-gradient(180deg, #8B5CF6 0%, rgba(139, 92, 246, 0.6) 100%);
    border-color: #8B5CF6;
    box-shadow: 0 0 8px rgba(139, 92, 246, 0.5);
}

.kl-pip.spent {
    background: rgba(50, 40, 70, 0.4);
    border-color: rgba(100, 80, 120, 0.2);
    opacity: 0.5;
}

.kl-text {
    font-family: 'Rajdhani', sans-serif;
    font-size: 11px;
    color: rgba(255, 255, 255, 0.6);
}

/* Zone wrapper and labels */
.zone-wrapper {
    position: relative;
    margin: 4px 0;
}

.zone-label {
    position: absolute;
    top: -8px;
    left: 10px;
    padding: 1px 8px;
    background: linear-gradient(135deg, #2d2640 0%, #1a1625 100%);
    border: 1px solid rgba(255, 215, 0, 0.25);
    border-radius: 3px;
    font-family: 'Cinzel', serif;
    font-size: 9px;
    font-weight: 600;
    color: #FFD700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    z-index: 5;
}

/* Avatar and Support Lines */
.avatar-line, .support-line {
    display: flex;
    gap: 6px;
    justify-content: center;
    padding: 8px 6px;
    border-radius: 6px;
    min-height: 100px;
}

.avatar-line {
    background: linear-gradient(180deg, rgba(255, 215, 0, 0.03) 0%, transparent 100%);
    border: 1px dashed rgba(255, 215, 0, 0.15);
}

.support-line {
    background: linear-gradient(180deg, rgba(139, 92, 246, 0.03) 0%, transparent 100%);
    border: 1px dashed rgba(139, 92, 246, 0.15);
}

/* Shard/Relic Row */
.shard-relic-row {
    display: flex;
    gap: 8px;
    justify-content: center;
    padding: 8px;
}

.shard-slot {
    width: 40px;
    height: 40px;
    background: radial-gradient(circle, rgba(139, 92, 246, 0.08) 0%, transparent 70%);
    border: 1px solid rgba(139, 92, 246, 0.25);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.shard-slot:hover {
    border-color: #8B5CF6;
    box-shadow: 0 0 15px rgba(139, 92, 246, 0.3);
}

/* Spell Row */
.spell-row {
    display: flex;
    gap: 6px;
    justify-content: center;
    padding: 6px;
    background: linear-gradient(90deg, transparent 0%, rgba(239, 68, 68, 0.03) 50%, transparent 100%);
    border-radius: 6px;
    min-height: 90px;
}

.spell-slot {
    border: 1px dashed rgba(239, 68, 68, 0.2) !important;
}

/* #player-hand now uses .ec-hand-cards styling from the New Earth Arena layout */
#player-hand {
    display: flex;
    flex: 1;
    justify-content: center;
    align-items: center;
    gap: 8px;
    flex-wrap: nowrap;
    overflow-x: auto;
    padding: 5px;
    min-height: 120px;
}

/* === BOARD CSS END === */
/* ===== CARDS ===== */
.game-card {
    width: 95px;
    height: 133px;
    border-radius: 8px;
    position: relative;
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    transform-style: preserve-3d;
}

.game-card .card-front {
    width: 100%;
    height: 100%;
    border-radius: 8px;
    overflow: hidden;
    border: 3px solid var(--card-border);
    box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(212, 175, 55, 0.2);
    background: linear-gradient(135deg, #2a1a3a 0%, #1a0a2a 100%);
    position: relative;
}

.game-card .card-image {
    width: 100%;
    height: 65%;
    object-fit: cover;
}

.game-card .card-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.9) 30%);
    padding: 20px 5px 5px;
}

.game-card .card-name {
    font-family: 'Cinzel', serif;
    font-size: 8px;
    font-weight: 600;
    color: #fff;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.game-card .card-stats {
    display: flex;
    justify-content: space-between;
    margin-top: 3px;
}

.game-card .card-cost {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--purple) 0%, var(--purple-dark) 100%);
    border: 2px solid var(--gold);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 0 5px #000;
}

.game-card .stat {
    font-size: 9px;
    font-weight: 600;
    padding: 1px 4px;
    border-radius: 3px;
}

.game-card .stat.attack {
    background: rgba(255, 68, 68, 0.8);
    color: #fff;
}

.game-card .stat.health {
    background: rgba(68, 255, 68, 0.8);
    color: #000;
}

/* Aspect glow effects */
.game-card.glow .card-front {
    border-color: #ffd700;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
}

.game-card.void .card-front {
    border-color: #9333ea;
    box-shadow: 0 0 20px rgba(147, 51, 234, 0.6);
}

.game-card.gray .card-front {
    border-color: #6b7280;
    box-shadow: 0 0 20px rgba(107, 114, 128, 0.6);
}

/* Card back */
.game-card.face-down .card-front {
    background: 
        linear-gradient(135deg, #1a0a2e 0%, #0a0510 100%),
        repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(107, 33, 168, 0.1) 10px, rgba(107, 33, 168, 0.1) 20px);
}

.game-card.face-down .card-image,
.game-card.face-down .card-info {
    display: none;
}

.game-card.face-down .card-front::after {
    content: '‚úß';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 36px;
    color: var(--gold);
    text-shadow: 0 0 20px var(--gold);
}

/* Tapped card */
.game-card.tapped {
    transform: rotate(90deg);
}

/* ===== PHASE INDICATOR ===== */
#phase-badge {
    position: absolute;
    top: 80px;
    right: 100px;
    transform: none;
    background: linear-gradient(135deg, #8b0000 0%, #4a0000 100%);
    border: 3px solid var(--gold);
    padding: 12px 22px;
    border-radius: 12px;
    z-index: 100;
    text-align: center;
    box-shadow: 
        0 0 30px rgba(139, 0, 0, 0.5),
        0 0 60px rgba(139, 0, 0, 0.3);
}

#phase-badge .turn-number {
    font-family: 'Cinzel', serif;
    font-size: 11px;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 1px;
}

#phase-badge .phase-name {
    font-family: 'Cinzel', serif;
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 0 10px #fff;
    text-transform: uppercase;
}

/* ===== PHASE TRACKER (Visual Progress) ===== */
#phase-tracker {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    background: linear-gradient(135deg, rgba(10, 5, 20, 0.95) 0%, rgba(30, 10, 50, 0.95) 100%);
    border: 2px solid var(--gold);
    border-radius: 30px;
    padding: 8px 20px;
    z-index: 100;
    box-shadow: 0 0 25px rgba(212, 175, 55, 0.3);
}

.phase-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
    padding: 6px 12px;
    border-radius: 16px;
    transition: all 0.3s ease;
    opacity: 0.4;
}

.phase-step.active {
    opacity: 1;
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.3) 0%, rgba(139, 0, 0, 0.4) 100%);
    box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
}

.phase-icon {
    font-size: 20px;
    filter: drop-shadow(0 0 5px currentColor);
}

.phase-step[data-phase="dawn"] .phase-icon { color: #ffd700; }
.phase-step[data-phase="main"] .phase-icon { color: #60a5fa; }
.phase-step[data-phase="clash"] .phase-icon { color: #ef4444; }
.phase-step[data-phase="twilight"] .phase-icon { color: #a855f7; }

.phase-step.active .phase-icon {
    animation: phase-pulse 1.5s infinite;
}

@keyframes phase-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
}

.phase-label {
    font-family: 'Cinzel', serif;
    font-size: 9px;
    font-weight: 700;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* ===== SIDE PANEL (Right) ===== */
#side-panel {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 100;
}

.panel-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 3px solid #4a90d9;
    background: linear-gradient(135deg, #1e3a5f 0%, #0d1b2a 100%);
    color: #fff;
    font-size: 18px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 15px rgba(74, 144, 217, 0.4);
}

.panel-btn:hover {
    transform: scale(1.15);
    box-shadow: 0 0 25px rgba(74, 144, 217, 0.7);
}

.panel-btn.active {
    background: linear-gradient(135deg, #4a90d9 0%, #1e3a5f 100%);
}

.panel-btn.auto-btn {
    font-size: 11px;
    font-weight: 700;
    font-family: 'Rajdhani', sans-serif;
}

/* ===== TURN CONTROLS ===== */
#turn-controls {
    position: absolute;
    bottom: 185px;
    right: 80px;
    display: flex;
    gap: 8px;
    z-index: 100;
}

.turn-btn {
    padding: 10px 22px;
    border-radius: 22px;
    border: 2px solid var(--gold);
    background: linear-gradient(135deg, rgba(42, 26, 58, 0.9) 0%, rgba(26, 10, 42, 0.9) 100%);
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
}

.turn-btn:hover {
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    color: #000;
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
}

/* ===== MAIN MENU SCREEN ===== */
.main-menu-screen {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0d1b2a 100%);
    display: flex;
    flex-direction: column;
    z-index: 2000;
    overflow-y: auto;
    overflow-x: hidden;
}

.main-menu-screen.hidden {
    display: none;
}

.menu-background {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        radial-gradient(ellipse at 20% 20%, rgba(107, 33, 168, 0.4) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(219, 39, 119, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(0, 255, 204, 0.15) 0%, transparent 40%);
    pointer-events: none;
    z-index: 0;
}

.menu-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 24px 40px;
    z-index: 10;
    background: 
        linear-gradient(180deg, rgba(10, 5, 20, 0.98) 0%, rgba(20, 10, 35, 0.9) 100%);
    border-bottom: 2px solid rgba(212, 175, 55, 0.3);
    flex-shrink: 0;
    gap: 30px;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
}

.menu-logo {
    flex: 1;
    min-width: 0;
}

.menu-logo h1 {
    font-family: 'Cinzel', serif;
    font-size: 3.5em;
    color: var(--gold);
    text-shadow: 0 0 40px rgba(212, 175, 55, 0.6), 0 4px 8px rgba(0,0,0,0.5);
    margin: 0;
    letter-spacing: 4px;
}

.menu-logo h2 {
    font-family: 'Cinzel', serif;
    font-size: 1.8em;
    color: rgba(212, 175, 55, 0.7);
    margin: 0;
    letter-spacing: 8px;
}

.menu-controls {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-shrink: 0;
}

.audio-btn {
    background: linear-gradient(135deg, rgba(147, 51, 234, 0.6), rgba(219, 39, 119, 0.6));
    border: 2px solid var(--gold);
    color: var(--gold);
    width: 44px;
    height: 44px;
    border-radius: 8px;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s;
}

.audio-btn:hover {
    background: linear-gradient(135deg, rgba(147, 51, 234, 0.9), rgba(219, 39, 119, 0.9));
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
    transform: scale(1.1);
}

.audio-btn.muted {
    opacity: 0.5;
    color: rgba(212, 175, 55, 0.5);
}

.volume-slider {
    width: 80px;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(212, 175, 55, 0.3);
    border-radius: 3px;
    cursor: pointer;
}

.volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: var(--gold);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
    transition: all 0.2s;
}

.volume-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
}

.volume-slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: var(--gold);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
}

.fullscreen-btn {
    background: linear-gradient(135deg, rgba(147, 51, 234, 0.6), rgba(219, 39, 119, 0.6));
    border: 2px solid var(--gold);
    color: var(--gold);
    width: 50px;
    height: 50px;
    border-radius: 8px;
    font-size: 24px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s;
}

.fullscreen-btn:hover {
    background: linear-gradient(135deg, rgba(147, 51, 234, 0.9), rgba(219, 39, 119, 0.9));
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
    transform: scale(1.1);
}

.fullscreen-btn:active {
    transform: scale(0.95);
}

.fullscreen-btn.active {
    background: linear-gradient(135deg, var(--purple), var(--pink));
    box-shadow: 0 0 30px rgba(147, 51, 234, 0.8);
}

.menu-profile {
    display: flex;
    align-items: center;
    gap: 15px;
    background: rgba(20, 10, 40, 0.8);
    padding: 15px 25px;
    border-radius: 12px;
    border: 1px solid rgba(212, 175, 55, 0.3);
    flex-shrink: 0;
}

.profile-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--purple), var(--pink));
    border: 2px solid var(--gold);
}

.profile-info {
    display: flex;
    flex-direction: column;
}

.profile-name {
    font-weight: 600;
    color: #fff;
    font-size: 1.1em;
}

.profile-rank {
    color: var(--gold);
    font-size: 0.9em;
}

.currency-shards {
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-weight: 700;
    font-size: 1.2em;
}

.currency-shards::before {
    content: 'üíé ';
    -webkit-text-fill-color: initial;
}

.menu-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 20px;
    z-index: 5;
    overflow-y: auto;
    gap: 20px;
}

.menu-modes {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 20px;
    max-width: 1000px;
    width: 100%;
    padding: 0 20px;
}

.mode-card {
    background: 
        linear-gradient(135deg, rgba(20, 15, 35, 0.95) 0%, rgba(30, 20, 50, 0.98) 50%, rgba(20, 15, 35, 0.95) 100%);
    border: 2px solid rgba(212, 175, 55, 0.4);
    border-radius: 12px;
    padding: 25px 20px;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    min-height: 180px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.mode-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
    opacity: 0;
    transition: opacity 0.3s;
}

.mode-card:hover {
    transform: translateY(-8px) scale(1.02);
    border-color: var(--gold);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 30px rgba(212, 175, 55, 0.2);
}

.mode-card:hover::before {
    opacity: 1;
}

.mode-card.solo { border-left: 4px solid var(--essence-glow); }
.mode-card.campaign { border-left: 4px solid var(--gold); }
.mode-card.multiplayer { border-left: 4px solid var(--pink); }
.mode-card.deckbuilder { border-left: 4px solid #3b82f6; }
.mode-card.collection { border-left: 4px solid #a855f7; }
.mode-icon {
    font-size: 3em;
    margin-bottom: 15px;
}

.mode-info h3 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 1.3em;
    margin: 0 0 8px 0;
}

.mode-info p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.95em;
    margin: 0;
}

.mode-badge {
    position: absolute;
    top: 15px;
    right: 15px;
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 0.75em;
    font-weight: 600;
    background: rgba(100, 100, 150, 0.4);
    color: rgba(255, 255, 255, 0.8);
}

.mode-badge.new {
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    color: #000;
}

.mode-badge.hot {
    background: linear-gradient(135deg, var(--pink), #9333ea);
    color: #fff;
}

.menu-news {
    margin-top: 40px;
    width: 100%;
    max-width: 900px;
}

.news-banner {
    background: linear-gradient(90deg, rgba(212, 175, 55, 0.2), rgba(107, 33, 168, 0.2), rgba(212, 175, 55, 0.2));
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 8px;
    padding: 15px 25px;
    display: flex;
    align-items: center;
    gap: 15px;
}

.news-label {
    background: var(--gold);
    color: #000;
    padding: 4px 12px;
    border-radius: 4px;
    font-weight: 700;
    font-size: 0.8em;
}

.news-text {
    color: rgba(255, 255, 255, 0.9);
}

.menu-footer {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
    padding: 15px 20px;
    z-index: 10;
    background: linear-gradient(135deg, rgba(10, 10, 26, 0.95) 0%, rgba(26, 10, 46, 0.9) 100%);
    flex-shrink: 0;
}

.menu-footer-btn {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: rgba(255, 255, 255, 0.6);
    padding: 8px 20px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s;
}

.menu-footer-btn:hover {
    border-color: var(--gold);
    color: var(--gold);
}

.menu-version {
    color: rgba(255, 255, 255, 0.3);
    font-size: 0.85em;
}

/* ===== SOLO MODE ===== */
.solo-container, .campaign-container {
    max-width: 85vw;
    width: 85%;
    max-height: 90vh;
    max-height: 90dvh;
    text-align: center;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    gap: 15px;
    padding: 20px;
}

.solo-container h1, .campaign-container h1 {
    margin: 10px 0 5px 0;
    flex-shrink: 0;
}

.solo-container > p, .campaign-container > p {
    margin: 0 0 10px 0;
    flex-shrink: 0;
}

.difficulty-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 15px;
    margin: 30px auto;
    width: 100%;
}

.difficulty-card {
    background: linear-gradient(135deg, rgba(30, 20, 50, 0.9) 0%, rgba(15, 10, 30, 0.95) 100%);
    border: 2px solid rgba(139, 115, 85, 0.4);
    border-radius: 12px;
    padding: 20px 15px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.difficulty-card:hover {
    transform: translateY(-5px);
    border-color: var(--gold);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
}

.difficulty-card.boss {
    border-color: var(--pink);
    background: linear-gradient(135deg, rgba(50, 20, 40, 0.9) 0%, rgba(30, 10, 25, 0.95) 100%);
}

.diff-icon {
    font-size: 2.5em;
    margin-bottom: 15px;
}

.difficulty-card h3 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    margin: 0 0 8px 0;
    font-size: 1.1em;
}

.difficulty-card p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.8em;
    margin: 0 0 10px 0;
    line-height: 1.3;
}

.diff-rewards {
    color: var(--essence-glow);
    font-weight: 600;
    font-size: 0.8em;
}

/* ===== CAMPAIGN ===== */
.campaign-progress {
    margin: 30px 0;
}

.progress-bar {
    width: 100%;
    height: 12px;
    background: rgba(50, 50, 80, 0.5);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--gold), var(--essence-glow));
    border-radius: 6px;
    transition: width 0.5s ease;
}

.chapter-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
    margin: 20px auto;
    width: 100%;
}

.chapter-card {
    background: linear-gradient(135deg, rgba(30, 20, 50, 0.9) 0%, rgba(15, 10, 30, 0.95) 100%);
    border: 2px solid rgba(139, 115, 85, 0.4);
    border-radius: 10px;
    padding: 15px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.chapter-card:hover:not(.locked) {
    transform: translateY(-5px);
    border-color: var(--gold);
}

.chapter-card.completed {
    border-color: var(--essence-glow);
    opacity: 0.8;
}

.chapter-card.locked {
    opacity: 0.5;
    cursor: not-allowed;
}

.chapter-card.current {
    border-color: var(--gold);
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
}

.chapter-number {
    font-family: 'Cinzel', serif;
    font-size: 2em;
    color: var(--gold);
    margin-bottom: 10px;
}

.chapter-card h3 {
    font-size: 0.85em;
    color: #fff;
    margin: 0 0 3px 0;
}

.chapter-card p {
    font-size: 0.7em;
    color: rgba(255, 255, 255, 0.6);
    margin: 0 0 8px 0;
}

.chapter-reward {
    font-size: 0.7em;
    color: var(--essence-glow);
}

.lock-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2em;
    opacity: 0.5;
}

/* ===== STORY CAMPAIGN UI ===== */
.campaign-story-header {
    text-align: center;
    margin-bottom: 30px;
}

.campaign-title {
    font-family: 'Cinzel', serif;
    font-size: 2.5em;
    color: var(--gold);
    text-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
    margin: 0 0 10px 0;
}

.campaign-subtitle {
    color: rgba(212, 175, 55, 0.7);
    font-size: 1.2em;
    font-style: italic;
    margin: 0;
}

.campaign-act {
    background: linear-gradient(180deg, rgba(30, 20, 50, 0.8) 0%, rgba(15, 10, 30, 0.9) 100%);
    border: 1px solid rgba(139, 115, 85, 0.4);
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 25px;
}

.campaign-act.locked {
    opacity: 0.5;
    filter: grayscale(0.5);
}

.act-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    padding-bottom: 12px;
}

.act-title {
    font-family: 'Cinzel', serif;
    font-size: 1.6em;
    color: var(--gold);
    margin: 0;
}

.act-progress {
    background: rgba(212, 175, 55, 0.2);
    padding: 6px 15px;
    border-radius: 20px;
    color: var(--gold);
    font-weight: 600;
}

.act-summary {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.95em;
    margin: 0 0 20px 0;
    line-height: 1.6;
}

.act-chapters {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.chapter-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
}

.chapter-title {
    font-size: 1em;
    color: #fff;
    margin: 0;
    font-weight: 600;
}

.chapter-portrait {
    font-size: 2.5em;
    margin-bottom: 10px;
    text-align: center;
}

.chapter-domain {
    font-size: 0.75em;
    color: var(--essence-glow);
    margin-bottom: 6px;
    font-style: italic;
}

.chapter-boss-name {
    font-size: 0.9em;
    color: rgba(255, 255, 255, 0.9);
    font-weight: 600;
    margin-bottom: 6px;
}

.chapter-difficulty {
    font-size: 0.7em;
    color: var(--gold);
    letter-spacing: 2px;
    margin-bottom: 8px;
}

.chapter-prelude {
    font-size: 0.75em;
    color: rgba(255, 255, 255, 0.6);
    line-height: 1.4;
    margin-bottom: 10px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* Story Cutscene Overlay */
.story-cutscene-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(ellipse at center, rgba(42, 10, 74, 0.98) 0%, rgba(10, 5, 20, 0.99) 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3000;
    animation: cutsceneFadeIn 0.5s ease;
}

@keyframes cutsceneFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.story-cutscene-overlay.fade-out {
    animation: cutsceneFadeOut 0.4s ease forwards;
}

@keyframes cutsceneFadeOut {
    to { opacity: 0; }
}

.story-cutscene-container {
    width: 90%;
    max-width: 900px;
    background: linear-gradient(180deg, rgba(40, 20, 60, 0.95) 0%, rgba(20, 10, 40, 0.98) 100%);
    border: 2px solid rgba(212, 175, 55, 0.5);
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 0 60px rgba(147, 51, 234, 0.4), inset 0 0 40px rgba(212, 175, 55, 0.1);
}

.cutscene-header {
    text-align: center;
    margin-bottom: 25px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    padding-bottom: 20px;
}

.cutscene-act {
    font-family: 'Cinzel', serif;
    font-size: 0.9em;
    color: var(--essence-glow);
    text-transform: uppercase;
    letter-spacing: 3px;
    margin-bottom: 8px;
}

.cutscene-chapter {
    font-family: 'Cinzel', serif;
    font-size: 2em;
    color: var(--gold);
    text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
    margin-bottom: 10px;
}

.cutscene-domain {
    font-size: 1em;
    color: rgba(212, 175, 55, 0.7);
    font-style: italic;
}

.cutscene-content {
    display: flex;
    gap: 30px;
    align-items: flex-start;
    margin-bottom: 25px;
}

.cutscene-portrait {
    font-size: 6em;
    flex-shrink: 0;
    background: linear-gradient(135deg, rgba(147, 51, 234, 0.3), rgba(219, 39, 119, 0.3));
    padding: 20px;
    border-radius: 15px;
    border: 2px solid rgba(212, 175, 55, 0.4);
}

.cutscene-text-wrapper {
    flex: 1;
    max-height: 250px;
    overflow-y: auto;
}

.cutscene-text {
    color: rgba(255, 255, 255, 0.9);
    font-size: 1.1em;
    line-height: 1.8;
    margin: 0;
    white-space: pre-wrap;
}

.cutscene-fade-in {
    animation: textFadeIn 0.5s ease;
}

@keyframes textFadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.cutscene-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-top: 1px solid rgba(212, 175, 55, 0.3);
    padding-top: 20px;
}

.cutscene-boss-info {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.cutscene-boss-info .boss-name {
    font-family: 'Cinzel', serif;
    font-size: 1.3em;
    color: var(--gold);
}

.cutscene-boss-info .boss-ability {
    font-size: 0.9em;
    color: rgba(255, 255, 255, 0.7);
    font-style: italic;
}

.cutscene-btn {
    background: linear-gradient(135deg, var(--gold) 0%, rgba(212, 175, 55, 0.7) 100%);
    color: #000;
    border: none;
    padding: 15px 40px;
    font-family: 'Cinzel', serif;
    font-size: 1.1em;
    font-weight: 700;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.cutscene-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
}

/* Victory Cutscene Overlay */
.victory-cutscene-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(ellipse at center, rgba(42, 40, 10, 0.98) 0%, rgba(20, 15, 5, 0.99) 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3000;
    animation: cutsceneFadeIn 0.5s ease;
}

.victory-cutscene-container {
    width: 90%;
    max-width: 800px;
    background: linear-gradient(180deg, rgba(60, 40, 20, 0.95) 0%, rgba(30, 20, 10, 0.98) 100%);
    border: 3px solid var(--gold);
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: 0 0 80px rgba(212, 175, 55, 0.5), inset 0 0 60px rgba(212, 175, 55, 0.15);
}

.victory-banner {
    font-family: 'Cinzel', serif;
    font-size: 3.5em;
    color: var(--gold);
    text-shadow: 0 0 40px rgba(212, 175, 55, 0.8), 0 4px 10px rgba(0, 0, 0, 0.5);
    margin-bottom: 10px;
    letter-spacing: 10px;
    animation: victoryPulse 2s ease infinite;
}

@keyframes victoryPulse {
    0%, 100% { text-shadow: 0 0 40px rgba(212, 175, 55, 0.8); }
    50% { text-shadow: 0 0 60px rgba(212, 175, 55, 1), 0 0 80px rgba(212, 175, 55, 0.6); }
}

.victory-chapter {
    font-size: 1.3em;
    color: rgba(212, 175, 55, 0.8);
    margin-bottom: 20px;
}

.victory-portrait {
    font-size: 5em;
    margin: 20px 0;
}

.victory-text-wrapper {
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 25px;
}

.victory-text {
    color: rgba(255, 255, 255, 0.9);
    font-size: 1.1em;
    line-height: 1.7;
    margin: 0;
    text-align: left;
}

.victory-rewards {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin: 25px 0;
    padding: 20px;
    background: rgba(212, 175, 55, 0.1);
    border-radius: 12px;
    border: 1px solid rgba(212, 175, 55, 0.3);
}

.victory-rewards .reward-item {
    font-size: 1.2em;
    color: var(--gold);
    font-weight: 600;
}

.victory-btn {
    background: linear-gradient(135deg, var(--gold) 0%, rgba(212, 175, 55, 0.7) 100%);
    color: #000;
    border: none;
    padding: 15px 50px;
    font-family: 'Cinzel', serif;
    font-size: 1.2em;
    font-weight: 700;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.victory-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 40px rgba(212, 175, 55, 0.7);
}

/* ===== DECK BUILDER ===== */
.deckbuilder-container {
    width: 90vw;
    max-width: 1400px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.deckbuilder-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.deck-tabs {
    display: flex;
    gap: 10px;
}

.deck-tab {
    padding: 10px 20px;
    background: rgba(50, 50, 80, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
}

.deck-tab.active {
    background: var(--gold);
    color: #000;
    border-color: var(--gold);
}

.deckbuilder-content {
    flex: 1;
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 20px;
    min-height: 0;
}

.card-pool {
    background: rgba(20, 15, 35, 0.8);
    border-radius: 12px;
    padding: 20px;
    display: flex;
    flex-direction: column;
}

.pool-filters {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.pool-filters input, .pool-filters select {
    padding: 10px 15px;
    background: rgba(30, 30, 60, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #fff;
    font-family: inherit;
}

.pool-cards, .pool-cards-group {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 10px;
    overflow-y: auto;
}

.pool-card {
    background: rgba(30, 25, 50, 0.8);
    border-radius: 8px;
    padding: 8px;
    cursor: grab;
    transition: all 0.2s;
    position: relative;
}

.pool-card:active {
    cursor: grabbing;
    opacity: 0.7;
}

.pool-card:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    border: 1px solid var(--gold);
}

.pool-card img {
    width: 100%;
    border-radius: 4px;
}

.pool-card-info {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
    font-size: 0.75em;
}

.pool-card-name {
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.pool-card-cost {
    color: var(--essence-glow);
}

.pool-card-hint {
    font-size: 0.65em;
    color: rgba(255, 255, 255, 0.4);
    margin-top: 3px;
    text-align: center;
}

.current-deck {
    background: rgba(20, 15, 35, 0.8);
    border-radius: 12px;
    padding: 20px;
    display: flex;
    flex-direction: column;
}

.deck-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.deck-info input {
    padding: 10px;
    background: rgba(30, 30, 60, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 1.1em;
}

.deck-count {
    color: var(--essence-glow);
    font-weight: 600;
}

.deck-cards {
    flex: 1;
    overflow-y: auto;
    min-height: 0;
    padding-right: 8px;
}

.deck-card-entry {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: rgba(40, 35, 60, 0.5);
    border-radius: 6px;
    margin-bottom: 5px;
    cursor: grab;
    transition: all 0.2s;
}

.deck-card-entry:active {
    cursor: grabbing;
    opacity: 0.8;
}

.deck-card-entry:hover {
    background: rgba(60, 50, 80, 0.6);
    border-left: 3px solid var(--gold);
}

.deck-card-remove {
    cursor: pointer;
    color: rgba(255, 100, 100, 0.6);
    font-size: 1.2em;
    padding: 0 5px;
    transition: color 0.2s;
}

.deck-card-remove:hover {
    color: #ff6666;
}

.deck-card-name {
    color: #fff;
}

.deck-card-count {
    color: var(--gold);
}

.deck-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.deck-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 8px;
    font-family: 'Cinzel', serif;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
}

.deck-btn.save {
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    color: #000;
}

.deck-btn.clear {
    background: rgba(100, 50, 50, 0.5);
    color: #fff;
    border: 1px solid rgba(255, 100, 100, 0.3);
}

.deck-btn.play {
    background: linear-gradient(135deg, var(--essence-glow), #00ffcc);
    color: #000;
}

.saved-decks-section {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.saved-decks-section h4 {
    color: var(--gold);
    font-size: 0.9em;
    margin: 0 0 10px 0;
}

.saved-deck-entry {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    background: rgba(40, 35, 60, 0.5);
    border-radius: 6px;
    margin-bottom: 5px;
    font-size: 0.85em;
}

.deck-title {
    flex: 1;
    color: #fff;
}

.deck-size {
    color: var(--gold);
    font-size: 0.75em;
}

.deck-entry-btn {
    padding: 4px 10px;
    font-size: 0.75em;
    border-radius: 4px;
    border: none;
    cursor: pointer;
}

.deck-entry-btn.load {
    background: linear-gradient(135deg, var(--essence-glow), #00ffcc);
    color: #000;
}

.deck-entry-btn.delete {
    background: rgba(100, 50, 50, 0.5);
    color: #fff;
    border: 1px solid rgba(255, 100, 100, 0.3);
}

/* ===== COLLECTION ===== */
.collection-container {
    width: 90vw;
    max-width: 1200px;
    max-height: 85vh;
    display: flex;
    flex-direction: column;
}

.collection-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}

.coll-tab {
    padding: 12px 25px;
    background: rgba(50, 50, 80, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.7);
    font-family: 'Cinzel', serif;
    cursor: pointer;
    transition: all 0.3s;
}

.coll-tab.active, .coll-tab:hover {
    background: var(--gold);
    color: #000;
    border-color: var(--gold);
}

.collection-grid {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 18px;
    overflow-y: auto;
    padding: 15px;
}

.coll-card {
    position: relative;
    background: 
        linear-gradient(135deg, rgba(25, 18, 42, 0.95) 0%, rgba(18, 12, 32, 0.98) 100%);
    border: 2px solid rgba(139, 92, 246, 0.35);
    border-radius: 10px;
    padding: 12px;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.coll-card:hover {
    transform: translateY(-8px);
    border-color: var(--gold);
    box-shadow: 
        0 15px 35px rgba(0, 0, 0, 0.4),
        0 0 25px rgba(212, 175, 55, 0.2);
}

.coll-card img {
    width: 100%;
    border-radius: 6px;
    margin-bottom: 10px;
    border: 1px solid rgba(139, 92, 246, 0.3);
}

.coll-card-name {
    color: #fff;
    font-size: 0.85em;
    display: block;
}

.coll-card-stats {
    color: var(--gold);
    font-size: 0.75em;
    margin-top: 4px;
}

/* ===== BACK BUTTON ===== */
.back-btn {
    margin-top: auto;
    padding: 12px 30px;
    background: rgba(50, 50, 80, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    color: #fff;
    font-family: 'Cinzel', serif;
    font-size: 0.95em;
    cursor: pointer;
    transition: all 0.3s;
    flex-shrink: 0;
}

.back-btn:hover {
    border-color: var(--gold);
    color: var(--gold);
}

/* ===== DEITY SELECTION OVERLAY ===== */
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(10, 10, 15, 0.97);
    z-index: 1000;
    padding: 20px;
    overflow-y: auto;
}

.overlay:not(.hidden) {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.deity-select-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
}

.overlay.hidden {
    display: none;
}

.overlay h1 {
    font-family: 'Cinzel', serif;
    font-size: 44px;
    color: var(--gold);
    text-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
    margin-bottom: 10px;
}

.overlay p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 18px;
    margin-bottom: 40px;
}

/* Deity Grid - Fixed proportions */
.deity-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    max-width: 1200px;
    width: 90%;
    margin: 20px auto 0;
}

.deity-option {
    width: 100%;
    aspect-ratio: 3/4;
    max-width: 280px;
    margin: 0 auto;
    border-radius: 12px;
    overflow: hidden;
    border: 3px solid rgba(139, 115, 85, 0.5);
    cursor: pointer;
    transition: all 0.4s ease;
    position: relative;
    background: linear-gradient(135deg, #2a1a3a 0%, #1a0a2a 100%);
    display: flex;
    align-items: center;
    justify-content: center;
}

.deity-option:hover {
    transform: translateY(-15px) scale(1.05);
    border-color: var(--gold);
    box-shadow: 0 25px 60px rgba(212, 175, 55, 0.5);
}

.deity-option img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.deity-option .deity-name {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.9) 50%);
    padding: 35px 12px 12px;
    text-align: center;
}

.deity-option .deity-name h3 {
    font-family: 'Cinzel', serif;
    font-size: 16px;
    color: var(--gold);
    margin-bottom: 4px;
}

.deity-option .deity-name p {
    font-size: 11px;
    color: rgba(255, 255, 255, 0.6);
    margin: 0;
}

.deity-option .select-btn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    color: #000;
    padding: 10px 25px;
    border-radius: 22px;
    font-family: 'Cinzel', serif;
    font-weight: 700;
    font-size: 13px;
    border: none;
    cursor: pointer;
    transition: transform 0.3s ease;
    text-transform: uppercase;
}

.deity-option:hover .select-btn {
    transform: translate(-50%, -50%) scale(1);
}

/* ===== GAME LOG PANEL ===== */
#log-panel {
    position: absolute;
    right: 75px;
    top: 50%;
    transform: translateY(-50%);
    width: 280px;
    max-height: 380px;
    background: rgba(10, 10, 15, 0.95);
    border: 2px solid rgba(74, 144, 217, 0.5);
    border-radius: 12px;
    padding: 12px;
    z-index: 200;
    display: none;
}

#log-panel.visible {
    display: block;
}

#log-panel h3 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    margin-bottom: 8px;
    font-size: 14px;
}

#log-content {
    max-height: 320px;
    overflow-y: auto;
    font-size: 11px;
    color: rgba(255, 255, 255, 0.8);
}

#log-content .log-entry {
    padding: 8px 10px;
    margin: 4px 0;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.2);
    border-left: 3px solid rgba(139, 92, 246, 0.4);
    font-size: 0.85em;
    transition: all 0.2s ease;
}

#log-content .log-entry:hover {
    background: rgba(139, 92, 246, 0.1);
}

#log-content .log-entry.phase {
    color: var(--gold);
    border-left-color: var(--gold);
    background: rgba(212, 175, 55, 0.08);
    font-weight: 600;
}

#log-content .log-entry.turn {
    color: var(--ec-amethyst);
    border-left-color: var(--ec-amethyst);
    background: rgba(139, 92, 246, 0.15);
    font-family: 'Cinzel', serif;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
}

#log-content .log-entry.damage {
    color: var(--damage-red);
    border-left-color: var(--damage-red);
    background: rgba(255, 68, 68, 0.08);
}

#log-content .log-entry.heal {
    color: var(--essence-glow);
    border-left-color: var(--essence-glow);
    background: rgba(0, 255, 204, 0.08);
}

#log-content .log-entry.summon {
    color: var(--ec-teal);
    border-left-color: var(--ec-teal);
    background: rgba(20, 244, 255, 0.08);
}

#log-content .log-entry.attack {
    color: #ff8c00;
    border-left-color: #ff8c00;
    background: rgba(255, 140, 0, 0.08);
}

/* ===== CONTEXT MENU ===== */
#context-menu {
    position: fixed;
    background: rgba(10, 10, 15, 0.98);
    border: 2px solid var(--gold);
    border-radius: 10px;
    padding: 5px 0;
    min-width: 140px;
    z-index: 2000;
    display: none;
}

#context-menu.visible {
    display: block;
}

.context-option {
    padding: 8px 18px;
    color: #fff;
    font-size: 13px;
    cursor: pointer;
    transition: background 0.2s;
}

.context-option:hover {
    background: rgba(212, 175, 55, 0.2);
    color: var(--gold);
}

/* ===== STAT CONTROLS ===== */
.stat-controls {
    display: flex;
    gap: 3px;
    margin-top: 3px;
}

.stat-btn {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: rgba(0, 0, 0, 0.5);
    color: #fff;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.stat-btn:hover {
    background: var(--gold);
    color: #000;
    border-color: var(--gold);
}

/* ===== ANIMATIONS ===== */
@keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 20px rgba(212, 175, 55, 0.4); }
    50% { box-shadow: 0 0 40px rgba(212, 175, 55, 0.8); }
}

@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

@keyframes damage-shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* Card play animation */
.card-playing {
    animation: card-play 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes card-play {
    0% { 
        transform: scale(0.8) translateY(200px) rotateZ(-15deg); 
        opacity: 0;
    }
    50% {
        transform: scale(1.1) translateY(-50px) rotateZ(5deg);
    }
    100% { 
        transform: scale(1) translateY(0) rotateZ(0deg); 
        opacity: 1; 
    }
}

/* Spell animation */
.spell-casting {
    animation: spell-cast 0.8s ease-out;
}

@keyframes spell-cast {
    0% {
        transform: scale(1) rotateZ(0deg);
        opacity: 1;
    }
    50% {
        transform: scale(1.3) rotateZ(10deg);
        opacity: 0.8;
    }
    100% {
        transform: scale(0) rotateZ(360deg);
        opacity: 0;
    }
}

/* ===== LEGAL PLAY & TARGET HIGHLIGHTING ===== */
.game-card.legal-play {
    box-shadow: 
        0 0 20px rgba(0, 255, 204, 0.8),
        0 0 40px rgba(0, 255, 204, 0.5),
        inset 0 0 15px rgba(0, 255, 204, 0.3) !important;
    border: 2px solid rgba(0, 255, 204, 0.9) !important;
    animation: legal-pulse 1.5s ease-in-out infinite;
}

.game-card.legal-target {
    box-shadow: 
        0 0 20px rgba(255, 68, 68, 0.8),
        0 0 40px rgba(255, 68, 68, 0.5),
        inset 0 0 15px rgba(255, 68, 68, 0.3) !important;
    border: 2px solid rgba(255, 68, 68, 0.9) !important;
    animation: target-pulse 1.5s ease-in-out infinite;
}

.game-card.selected-attacker {
    box-shadow: 
        0 0 25px rgba(212, 175, 55, 1),
        0 0 50px rgba(212, 175, 55, 0.7),
        inset 0 0 20px rgba(212, 175, 55, 0.4) !important;
    border: 3px solid var(--gold) !important;
}

@keyframes legal-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.85; }
}

@keyframes target-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.85; }
}

/* ===== COMBAT SYSTEM ===== */

/* Turn Indicator */
.turn-indicator {
    position: fixed;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 30px;
    border-radius: 25px;
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 2px;
    z-index: 100;
    transition: all 0.3s ease;
}

.turn-indicator.p1 {
    background: linear-gradient(135deg, rgba(30, 100, 200, 0.9), rgba(20, 60, 120, 0.95));
    border: 2px solid #4a90d9;
    color: #fff;
    box-shadow: 0 0 20px rgba(30, 100, 200, 0.5);
}

.turn-indicator.p2 {
    background: linear-gradient(135deg, rgba(200, 50, 50, 0.9), rgba(120, 20, 20, 0.95));
    border: 2px solid #d94a4a;
    color: #fff;
    box-shadow: 0 0 20px rgba(200, 50, 50, 0.5);
}

/* Action Prompt */
#action-prompt {
    position: fixed;
    top: 70px;
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    padding: 12px 25px;
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.95), rgba(170, 138, 46, 0.95));
    border: 2px solid #f4d03f;
    border-radius: 8px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 1rem;
    font-weight: 600;
    color: #1a0a2e;
    z-index: 200;
    opacity: 0;
    pointer-events: none;
    transition: all 0.3s ease;
    box-shadow: 0 5px 25px rgba(212, 175, 55, 0.4);
}

#action-prompt.visible {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
    pointer-events: auto;
}

#action-prompt .action-prompt-message {
    text-align: center;
}

.ec-dialog-close {
    margin-top: 1rem;
    padding: 0.5rem 1.5rem;
    border-radius: 999px;
    border: none;
    cursor: pointer;
    font-weight: 600;
}

/* Card Selection States */
.game-card.selected-attacker {
    box-shadow: 0 0 25px #00ff88, 0 0 50px #00ff8844 !important;
    transform: scale(1.05);
    z-index: 50;
}

.game-card.selected-attacker::after {
    content: 'ATTACKING';
    position: absolute;
    bottom: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: #00ff88;
    color: #000;
    padding: 3px 10px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
}

.game-card.valid-target {
    box-shadow: 0 0 20px #ff4444, 0 0 40px #ff444466 !important;
    animation: pulse-target 1s infinite;
    cursor: crosshair !important;
}

@keyframes pulse-target {
    0%, 100% { box-shadow: 0 0 20px #ff4444, 0 0 40px #ff444466; }
    50% { box-shadow: 0 0 30px #ff6666, 0 0 60px #ff666688; }
}

/* Deity as valid target */
.deity-card-frame.valid-deity-target {
    box-shadow: 0 0 30px #ff4444, 0 0 50px #ff444488 !important;
    animation: pulse-target 1s infinite;
    cursor: crosshair !important;
}

.deity-card-frame.valid-deity-target img {
    filter: brightness(1.2);
}

/* Health Bar on Cards */
.health-bar {
    position: absolute;
    bottom: 2px;
    left: 5%;
    width: 90%;
    height: 4px;
    background: rgba(0, 0, 0, 0.6);
    border-radius: 2px;
    overflow: hidden;
}

.health-fill {
    height: 100%;
    background: linear-gradient(90deg, #00ff88, #44ff44);
    border-radius: 2px;
    transition: width 0.3s ease;
}

.health-fill[style*="width: 5"], .health-fill[style*="width: 4"],
.health-fill[style*="width: 3"], .health-fill[style*="width: 2"],
.health-fill[style*="width: 1"] {
    background: linear-gradient(90deg, #ff4444, #ff6666);
}

/* Battle Overlay */
#battle-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

#battle-overlay.visible {
    opacity: 1;
    pointer-events: all;
}

.battle-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 40px;
}

.battle-card {
    width: 200px;
    text-align: center;
    animation: battle-entrance 0.5s ease-out;
}

.battle-card.attacker {
    animation: battle-entrance-left 0.5s ease-out;
}

.battle-card.defender {
    animation: battle-entrance-right 0.5s ease-out;
}

@keyframes battle-entrance-left {
    from { transform: translateX(-100px) scale(0.8); opacity: 0; }
    to { transform: translateX(0) scale(1); opacity: 1; }
}

@keyframes battle-entrance-right {
    from { transform: translateX(100px) scale(0.8); opacity: 0; }
    to { transform: translateX(0) scale(1); opacity: 1; }
}

.battle-card img {
    width: 180px;
    height: 250px;
    object-fit: cover;
    border-radius: 12px;
    border: 3px solid var(--gold);
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
}

.battle-card.attacker img {
    border-color: #00ff88;
    box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
}

.battle-card.defender img {
    border-color: #ff4444;
    box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
}

.battle-name {
    margin-top: 12px;
    font-family: 'Cinzel', serif;
    font-size: 1.1rem;
    font-weight: 700;
    color: #fff;
}

.battle-stats {
    margin-top: 8px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 1.3rem;
    font-weight: 700;
}

.battle-stats .atk {
    color: #ff6666;
}

.battle-stats .hp {
    color: #66ff88;
}

.battle-vs {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}

.vs-text {
    font-family: 'Cinzel', serif;
    font-size: 3rem;
    font-weight: 900;
    color: var(--gold);
    text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
    animation: vs-pulse 1s infinite;
}

@keyframes vs-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.damage-preview {
    background: linear-gradient(135deg, #ff4444, #cc0000);
    padding: 8px 20px;
    border-radius: 20px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 1.2rem;
    font-weight: 700;
    color: #fff;
    box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
}

.battle-actions {
    position: absolute;
    bottom: 80px;
    display: flex;
    gap: 20px;
}

.battle-btn {
    padding: 15px 40px;
    font-family: 'Cinzel', serif;
    font-size: 1.1rem;
    font-weight: 700;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.battle-btn.confirm {
    background: linear-gradient(135deg, #00cc66, #009944);
    color: #fff;
    box-shadow: 0 5px 20px rgba(0, 200, 100, 0.4);
}

.battle-btn.confirm:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 30px rgba(0, 200, 100, 0.6);
}

.battle-btn.cancel {
    background: linear-gradient(135deg, #666, #444);
    color: #fff;
}

.battle-btn.cancel:hover {
    background: linear-gradient(135deg, #888, #666);
}

.battle-btn.skip {
    background: linear-gradient(135deg, #cc6600, #994400);
    color: #fff;
}

.battle-btn.skip:hover {
    background: linear-gradient(135deg, #ff8800, #cc6600);
}

/* ===== BLOCKER DECLARATION OVERLAY ===== */
.blocker-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.92);
    z-index: 550;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.blocker-overlay.visible {
    opacity: 1;
    pointer-events: all;
}

.blocker-container {
    background: linear-gradient(145deg, rgba(20, 10, 40, 0.98), rgba(10, 5, 25, 0.98));
    border: 2px solid var(--ec-amethyst);
    border-radius: 20px;
    padding: 30px 40px;
    max-width: 90vw;
    max-height: 85vh;
    overflow-y: auto;
    box-shadow: 
        0 0 60px rgba(124, 58, 237, 0.3),
        inset 0 0 40px rgba(124, 58, 237, 0.1);
}

.blocker-header {
    text-align: center;
    margin-bottom: 25px;
}

.blocker-header h2 {
    font-family: 'Cinzel', serif;
    font-size: 2rem;
    color: var(--ec-gold);
    text-shadow: 0 0 20px rgba(246, 196, 83, 0.5);
    margin-bottom: 10px;
}

.blocker-header p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 1rem;
}

.blocker-attackers,
.blocker-available {
    margin-bottom: 25px;
}

.blocker-attackers h3,
.blocker-available h3 {
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
    color: #fff;
    margin-bottom: 15px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(124, 58, 237, 0.3);
}

.blocker-attacker-list {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    justify-content: center;
}

.blocker-attacker-slot {
    display: flex;
    align-items: center;
    gap: 15px;
    background: rgba(255, 50, 50, 0.1);
    border: 1px solid rgba(255, 100, 100, 0.3);
    border-radius: 12px;
    padding: 15px;
}

.blocker-attacker-card,
.blocker-slot,
.blocker-available-card {
    width: 100px;
    text-align: center;
}

.blocker-attacker-card img,
.blocker-slot img,
.blocker-available-card img {
    width: 80px;
    height: 110px;
    object-fit: cover;
    border-radius: 8px;
    border: 2px solid var(--gold);
}

.blocker-attacker-card img {
    border-color: #ff4444;
    box-shadow: 0 0 15px rgba(255, 68, 68, 0.4);
}

.blocker-slot {
    background: rgba(0, 0, 0, 0.3);
    border: 2px dashed rgba(255, 255, 255, 0.3);
    border-radius: 10px;
    min-height: 130px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.blocker-slot:hover {
    border-color: var(--ec-teal);
    background: rgba(20, 244, 255, 0.1);
}

.blocker-slot.assigned {
    border-style: solid;
    border-color: #00ff88;
    background: rgba(0, 255, 136, 0.1);
}

.blocker-slot.assigned img {
    border-color: #00ff88;
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
}

.blocker-arrow {
    font-size: 2rem;
    color: var(--ec-gold);
    text-shadow: 0 0 10px rgba(246, 196, 83, 0.5);
}

.blocker-card-name {
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.85rem;
    font-weight: 600;
    color: #fff;
    margin-top: 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.blocker-card-stats {
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.7);
}

.no-blocker {
    color: rgba(255, 255, 255, 0.4);
    font-size: 0.9rem;
}

.blocker-available-list {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
}

.blocker-available-card {
    background: rgba(0, 255, 136, 0.1);
    border: 2px solid rgba(0, 255, 136, 0.3);
    border-radius: 10px;
    padding: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.blocker-available-card:hover {
    transform: translateY(-5px);
    border-color: #00ff88;
    box-shadow: 0 10px 25px rgba(0, 255, 136, 0.3);
}

.blocker-available-card.assigned {
    opacity: 0.4;
    pointer-events: none;
}

.blocker-available-card img {
    border-color: #00ff88;
}

.blocker-actions {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 20px;
}

/* ===== DECLARED ATTACKER HIGHLIGHT ===== */
.game-card.declared-attacker {
    box-shadow: 
        0 0 20px rgba(0, 255, 136, 0.6),
        0 0 40px rgba(0, 255, 136, 0.3),
        inset 0 0 15px rgba(0, 255, 136, 0.2) !important;
    border-color: #00ff88 !important;
    animation: attacker-pulse 1s infinite ease-in-out;
}

@keyframes attacker-pulse {
    0%, 100% { 
        box-shadow: 
            0 0 20px rgba(0, 255, 136, 0.6),
            0 0 40px rgba(0, 255, 136, 0.3);
    }
    50% { 
        box-shadow: 
            0 0 30px rgba(0, 255, 136, 0.8),
            0 0 60px rgba(0, 255, 136, 0.5);
    }
}

/* ===== CARD DESTRUCTION ANIMATION ===== */
.ec-destroy-anim {
    animation: card-destroy 0.6s ease-out forwards;
}

@keyframes card-destroy {
    0% { 
        transform: scale(1);
        opacity: 1;
        filter: brightness(1);
    }
    30% {
        transform: scale(1.1);
        filter: brightness(2) saturate(0);
    }
    100% {
        transform: scale(0) rotate(15deg);
        opacity: 0;
        filter: brightness(3);
    }
}

/* Damage Numbers */
#damage-numbers {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 600;
}

.damage-number {
    position: absolute;
    font-family: 'Cinzel', serif;
    font-size: 3rem;
    font-weight: 900;
    color: #ff4444;
    text-shadow: 
        2px 2px 0 #000,
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        0 0 20px #ff0000;
    animation: damage-float 1.5s ease-out forwards;
    transform: translate(-50%, -50%);
}

@keyframes damage-float {
    0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(0.5); 
    }
    20% {
        transform: translate(-50%, -50%) scale(1.3);
    }
    100% { 
        opacity: 0; 
        transform: translate(-50%, -150%) scale(1); 
    }
}

/* Particle Canvas */
#particle-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 550;
}

/* Attack Animation */
.game-card.attacking {
    animation: attack-lunge 0.5s ease-out;
}

@keyframes attack-lunge {
    0% { transform: translateY(0); }
    30% { transform: translateY(-30px) scale(1.1); }
    60% { transform: translateY(-60px) scale(1.15); }
    100% { transform: translateY(0) scale(1); }
}

/* Destroy Animation */
.game-card.destroying {
    animation: destroy-card 0.5s ease-out forwards;
}

@keyframes destroy-card {
    0% { 
        transform: scale(1); 
        opacity: 1; 
        filter: brightness(1);
    }
    50% {
        transform: scale(1.2);
        filter: brightness(2);
    }
    100% { 
        transform: scale(0) rotateZ(45deg); 
        opacity: 0; 
    }
}

/* Screen Shake */
.shake-light {
    animation: shake-light 0.3s ease-out;
}

.shake-heavy {
    animation: shake-heavy 0.4s ease-out;
}

@keyframes shake-light {
    0%, 100% { transform: translate(-50%, -50%) perspective(1200px) rotateX(12deg); }
    25% { transform: translate(calc(-50% + 5px), calc(-50% + 3px)) perspective(1200px) rotateX(12deg); }
    75% { transform: translate(calc(-50% - 5px), calc(-50% - 3px)) perspective(1200px) rotateX(12deg); }
}

@keyframes shake-heavy {
    0%, 100% { transform: translate(-50%, -50%) perspective(1200px) rotateX(12deg); }
    20% { transform: translate(calc(-50% + 10px), calc(-50% + 8px)) perspective(1200px) rotateX(14deg); }
    40% { transform: translate(calc(-50% - 12px), calc(-50% - 6px)) perspective(1200px) rotateX(10deg); }
    60% { transform: translate(calc(-50% + 8px), calc(-50% + 10px)) perspective(1200px) rotateX(14deg); }
    80% { transform: translate(calc(-50% - 6px), calc(-50% - 8px)) perspective(1200px) rotateX(10deg); }
}

/* Victory Screen */
#victory-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.95) 100%);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fade-in 0.5s ease-out;
}

@keyframes fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
}

.victory-content {
    text-align: center;
    animation: victory-entrance 0.8s ease-out;
}

@keyframes victory-entrance {
    from { 
        transform: scale(0.5) translateY(50px); 
        opacity: 0; 
    }
    to { 
        transform: scale(1) translateY(0); 
        opacity: 1; 
    }
}

.victory-title {
    font-family: 'Cinzel', serif;
    font-size: 5rem;
    font-weight: 900;
    background: linear-gradient(135deg, #d4af37, #f4d03f, #d4af37);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    filter: drop-shadow(0 0 30px rgba(212, 175, 55, 0.8));
    animation: victory-glow 2s infinite;
}

@keyframes victory-glow {
    0%, 100% { filter: drop-shadow(0 0 30px rgba(212, 175, 55, 0.8)); }
    50% { filter: drop-shadow(0 0 50px rgba(244, 208, 63, 1)); }
}

.victory-text {
    font-family: 'Rajdhani', sans-serif;
    font-size: 2rem;
    color: #fff;
    margin-top: 20px;
}

.victory-btn {
    margin-top: 40px;
    padding: 15px 50px;
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    border: none;
    border-radius: 8px;
    color: #1a0a2e;
    cursor: pointer;
    transition: all 0.3s ease;
}

.victory-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
}

.victory-btn.secondary {
    background: transparent;
    border: 2px solid var(--gold);
    color: var(--gold);
}

.victory-buttons {
    display: flex;
    gap: 15px;
    margin-top: 30px;
    justify-content: center;
}

.reward-text {
    font-size: 1.5rem;
    color: var(--essence-glow);
    font-weight: 600;
    margin-top: 15px;
    animation: pulse 1.5s infinite;
}

.victory-content.defeat .victory-title {
    background: linear-gradient(135deg, #9333ea, #db2777, #9333ea);
    -webkit-background-clip: text;
}

.victory-particle {
    position: absolute;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    animation: confetti-fall 3s linear forwards;
}

@keyframes confetti-fall {
    0% { 
        transform: translateY(-100vh) rotate(0deg); 
        opacity: 1; 
    }
    100% { 
        transform: translateY(100vh) rotate(720deg); 
        opacity: 0; 
    }
}

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar {
    width: 6px;
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 3px;
}

::-webkit-scrollbar-thumb {
    background: var(--gold);
    border-radius: 3px;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 1400px) {
    .menu-modes {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
    }
    
    .deity-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .deity-option {
        width: 220px;
        height: 310px;
    }
}

@media (max-width: 768px) {
    .menu-header {
        flex-direction: column;
        gap: 20px;
        padding: 20px 30px;
    }
    
    .menu-logo h1 {
        font-size: 2.5em;
    }
    
    .menu-logo h2 {
        font-size: 1.2em;
    }
    
    .menu-modes {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
        padding: 0 10px;
    }
    
    .mode-card {
        padding: 15px 10px;
        min-height: 150px;
    }
    
    .mode-icon {
        font-size: 2em;
        margin-bottom: 10px;
    }
    
    .mode-info h3 {
        font-size: 1em;
    }
    
    .mode-info p {
        font-size: 0.8em;
    }
    
    .news-banner {
        padding: 10px 15px;
    }
    
    .news-label {
        padding: 2px 8px;
        font-size: 0.65em;
    }
    
    .news-text {
        font-size: 0.85em;
    }
}

@media (max-width: 900px) {
    .deity-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
    }
    
    .deity-option {
        width: 170px;
        height: 240px;
    }
    
    #game-board {
        width: 95%;
        height: 70%;
    }
}

/* ===== DEITY INFO OVERLAY ===== */
.deity-info-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.9) 50%);
    padding: 30px 6px 6px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    z-index: 2;
}

.deity-passive {
    font-size: 8px;
    color: var(--gold);
    text-align: center;
    font-family: 'Cinzel', serif;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: help;
}

.god-code-charges {
    display: flex;
    gap: 4px;
    margin: 2px 0;
}

.god-code-charges .charge {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid var(--gold-dark);
    background: transparent;
    transition: all 0.3s ease;
}

.god-code-charges .charge.active {
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-light) 100%);
    box-shadow: 0 0 8px var(--gold);
    animation: pulse-charge 2s infinite;
}

@keyframes pulse-charge {
    0%, 100% { box-shadow: 0 0 8px var(--gold); }
    50% { box-shadow: 0 0 15px var(--gold-light), 0 0 25px var(--gold); }
}

.god-code-btn {
    background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
    color: white;
    border: none;
    padding: 3px 8px;
    font-size: 8px;
    font-family: 'Cinzel', serif;
    font-weight: 700;
    border-radius: 4px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s ease;
    animation: god-code-pulse 1.5s infinite;
}

.god-code-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px #ff4444;
}

@keyframes god-code-pulse {
    0%, 100% { box-shadow: 0 0 5px #ff4444; }
    50% { box-shadow: 0 0 15px #ff4444, 0 0 25px #ff000088; }
}

.deity-overflow {
    position: absolute;
    top: 5px;
    right: 5px;
    background: rgba(0, 0, 0, 0.8);
    color: var(--essence-glow);
    font-size: 8px;
    padding: 2px 5px;
    border-radius: 3px;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    z-index: 3;
}

/* ===== GUARDIAN BADGE ===== */
.guardian-badge {
    position: absolute;
    top: 5px;
    left: 5px;
    background: linear-gradient(135deg, #2196f3 0%, #1565c0 100%);
    color: white;
    font-size: 7px;
    padding: 2px 5px;
    border-radius: 3px;
    font-family: 'Cinzel', serif;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 0 8px rgba(33, 150, 243, 0.5);
    z-index: 5;
}

/* ===== BEAST BADGE ===== */
.beast-badge {
    position: absolute;
    top: 5px;
    right: 5px;
    background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%);
    color: white;
    font-size: 7px;
    padding: 2px 5px;
    border-radius: 3px;
    font-family: 'Cinzel', serif;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
    z-index: 5;
}

/* ===== DEITY STATS IN SELECTION ===== */
.deity-option .deity-stats {
    font-size: 10px;
    color: var(--essence-glow);
    margin-top: 2px;
}

/* ===== ASPECT COLORS FOR CARDS ===== */
.game-card.glow {
    border-color: #ffd700;
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
}

.game-card.void {
    border-color: #9c27b0;
    box-shadow: 0 0 15px rgba(156, 39, 176, 0.3);
}

.game-card.gray {
    border-color: #607d8b;
    box-shadow: 0 0 15px rgba(96, 125, 139, 0.3);
}

/* ===== DRAW ANIMATION ===== */
#draw-animation {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    pointer-events: none;
}

#draw-animation.visible {
    display: flex;
}

.draw-card-container {
    text-align: center;
    animation: draw-pop 0.6s ease-out;
}

.draw-card {
    width: 200px;
    height: 280px;
    border-radius: 12px;
    overflow: hidden;
    border: 4px solid var(--gold);
    background: #1a0a2a;
    box-shadow: 0 0 50px var(--gold);
    animation: draw-glow 1s infinite;
}

.draw-card img {
    width: 100%;
    height: 70%;
    object-fit: cover;
}

.draw-card-info {
    padding: 10px;
    background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.95) 100%);
}

.draw-card-name {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    color: var(--gold);
    margin-bottom: 5px;
}

.draw-card-cost, .draw-card-stats {
    font-size: 12px;
    color: #fff;
}

.draw-text {
    font-family: 'Cinzel', serif;
    font-size: 36px;
    color: var(--gold);
    margin-top: 20px;
    text-shadow: 0 0 20px var(--gold);
    animation: draw-pulse 0.5s ease-out;
}

@keyframes draw-pop {
    0% { transform: scale(0.3) translateY(100px); opacity: 0; }
    50% { transform: scale(1.1) translateY(-20px); }
    100% { transform: scale(1) translateY(0); opacity: 1; }
}

@keyframes draw-glow {
    0%, 100% { box-shadow: 0 0 30px var(--gold); }
    50% { box-shadow: 0 0 60px var(--gold-light); }
}

@keyframes draw-pulse {
    0% { transform: scale(0.5); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

/* ===== PILE/GRAVEYARD OVERLAY ===== */
#pile-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

#pile-overlay.visible {
    display: flex;
}

.pile-container {
    width: 90%;
    max-width: 900px;
    max-height: 80vh;
    background: linear-gradient(135deg, #2a1a3a 0%, #1a0a2a 100%);
    border: 3px solid var(--gold);
    border-radius: 15px;
    padding: 20px;
    overflow: hidden;
}

.pile-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--gold-dark);
}

.pile-header h2 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    margin: 0;
}

.pile-count {
    font-size: 14px;
    color: rgba(255,255,255,0.7);
}

.pile-close {
    background: var(--damage-red);
    border: none;
    color: white;
    width: 35px;
    height: 35px;
    border-radius: 50%;
    font-size: 18px;
    cursor: pointer;
    transition: transform 0.2s;
}

.pile-close:hover {
    transform: scale(1.1);
}

.pile-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 15px;
    max-height: 60vh;
    overflow-y: auto;
    padding: 10px;
}

.pile-card {
    background: #1a0a2a;
    border: 2px solid var(--stone-dark);
    border-radius: 8px;
    overflow: hidden;
    transition: transform 0.3s, box-shadow 0.3s;
}

.pile-card:hover {
    transform: translateY(-10px) scale(1.05);
    box-shadow: 0 10px 30px rgba(212, 175, 55, 0.3);
}

.pile-card.glow { border-color: #ffd700; }
.pile-card.void { border-color: #9c27b0; }
.pile-card.gray { border-color: #607d8b; }

.pile-card img {
    width: 100%;
    height: 120px;
    object-fit: cover;
}

.pile-card-info {
    padding: 8px;
    background: rgba(0,0,0,0.8);
}

.pile-card-name {
    font-family: 'Cinzel', serif;
    font-size: 11px;
    color: var(--gold);
    margin-bottom: 3px;
}

.pile-card-cost, .pile-card-stats {
    font-size: 10px;
    color: rgba(255,255,255,0.8);
}

.pile-card-effect {
    font-size: 9px;
    color: rgba(255,255,255,0.6);
    margin-top: 5px;
    max-height: 40px;
    overflow: hidden;
}

.pile-empty {
    grid-column: 1 / -1;
    text-align: center;
    color: rgba(255,255,255,0.5);
    font-size: 18px;
    padding: 40px;
}

/* ===== AI PLAY OVERLAY ===== */
#ai-play-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    pointer-events: none;
}

#ai-play-overlay.visible {
    display: flex;
}

.ai-play-container {
    text-align: center;
    animation: ai-slide 0.5s ease-out;
}

.ai-play-text {
    font-family: 'Cinzel', serif;
    font-size: 28px;
    color: #ff4444;
    margin-bottom: 20px;
    text-shadow: 0 0 20px #ff4444;
}

.ai-play-card {
    width: 180px;
    height: 250px;
    border-radius: 10px;
    overflow: hidden;
    border: 3px solid #ff4444;
    background: #1a0a2a;
    margin: 0 auto;
    box-shadow: 0 0 40px rgba(255, 68, 68, 0.5);
}

.ai-play-card img {
    width: 100%;
    height: 70%;
    object-fit: cover;
}

.ai-play-info {
    padding: 10px;
    background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.95) 100%);
}

.ai-play-name {
    font-family: 'Cinzel', serif;
    font-size: 13px;
    color: #ff4444;
}

.ai-play-stats {
    font-size: 11px;
    color: #fff;
    margin-top: 5px;
}

@keyframes ai-slide {
    0% { transform: translateY(-100px); opacity: 0; }
    100% { transform: translateY(0); opacity: 1; }
}

/* ===== CARD PREVIEW ===== */
#card-preview {
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 280px;
    display: none;
    z-index: 1500;
    pointer-events: none;
}

#card-preview.visible {
    display: block;
}

.preview-card {
    background: linear-gradient(135deg, #2a1a3a 0%, #1a0a2a 100%);
    border: 3px solid var(--gold);
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), 0 0 30px rgba(212, 175, 55, 0.3);
    animation: preview-appear 0.2s ease-out;
}

.preview-card.glow { border-color: #ffd700; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), 0 0 30px rgba(255, 215, 0, 0.4); }
.preview-card.void { border-color: #9c27b0; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), 0 0 30px rgba(156, 39, 176, 0.4); }
.preview-card.gray { border-color: #607d8b; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), 0 0 30px rgba(96, 125, 139, 0.4); }

.preview-card img {
    width: 100%;
    height: 180px;
    object-fit: cover;
}

.preview-info {
    padding: 12px;
    background: rgba(0, 0, 0, 0.9);
}

.preview-name {
    font-family: 'Cinzel', serif;
    font-size: 16px;
    color: var(--gold);
    margin-bottom: 5px;
}

.preview-type {
    font-size: 11px;
    color: rgba(255,255,255,0.6);
    margin-bottom: 8px;
}

.preview-cost {
    font-size: 14px;
    color: var(--essence-glow);
    margin-bottom: 5px;
}

.preview-stats {
    font-size: 13px;
    color: #fff;
    margin-bottom: 8px;
}

.preview-effect {
    font-size: 11px;
    color: rgba(255,255,255,0.85);
    line-height: 1.4;
    margin-bottom: 8px;
    max-height: 80px;
    overflow-y: auto;
}

.preview-passive, .preview-godcode {
    font-size: 10px;
    color: rgba(255,255,255,0.7);
    line-height: 1.3;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(255,255,255,0.2);
}

.preview-passive strong, .preview-godcode strong {
    color: var(--gold);
}

@keyframes preview-appear {
    0% { transform: translateX(-20px); opacity: 0; }
    100% { transform: translateX(0); opacity: 1; }
}

/* ===== HOVER EFFECT FOR BOARD CARDS ===== */
.game-card:hover {
    transform: translateY(-15px) scale(1.1);
    z-index: 100;
    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6), 0 0 25px rgba(212, 175, 55, 0.4);
}

/* ===== SPELL TARGETING ===== */
.valid-spell-target {
    animation: spell-target-pulse 0.8s infinite;
    cursor: pointer !important;
}

@keyframes spell-target-pulse {
    0%, 100% { 
        box-shadow: 0 0 20px rgba(147, 51, 234, 0.6), 0 0 40px rgba(147, 51, 234, 0.3);
        border-color: #9333ea;
    }
    50% { 
        box-shadow: 0 0 35px rgba(147, 51, 234, 0.9), 0 0 60px rgba(147, 51, 234, 0.5);
        border-color: #c084fc;
    }
}

.deity-frame.valid-spell-target {
    animation: deity-spell-target 0.8s infinite;
}

@keyframes deity-spell-target {
    0%, 100% { 
        box-shadow: 0 0 25px rgba(147, 51, 234, 0.7);
        border-color: #9333ea;
    }
    50% { 
        box-shadow: 0 0 45px rgba(147, 51, 234, 1);
        border-color: #c084fc;
    }
}

/* ===== SPELL CAST ANIMATION ===== */
.spell-cast-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 40px;
    animation: spell-cast-appear 0.5s ease-out;
}

.spell-cast-card {
    width: 160px;
    height: 220px;
    border-radius: 10px;
    overflow: hidden;
    border: 3px solid var(--gold);
    background: #1a0a2a;
    box-shadow: 0 0 40px var(--gold);
    animation: spell-glow 1s infinite;
}

.spell-cast-card.glow {
    border-color: #ffd700;
    box-shadow: 0 0 50px rgba(255, 215, 0, 0.6);
}

.spell-cast-card.void {
    border-color: #9c27b0;
    box-shadow: 0 0 50px rgba(156, 39, 176, 0.6);
}

.spell-cast-card.gray {
    border-color: #607d8b;
    box-shadow: 0 0 50px rgba(96, 125, 139, 0.6);
}

.spell-cast-card img {
    width: 100%;
    height: 70%;
    object-fit: cover;
}

.spell-cast-info {
    padding: 10px;
    background: rgba(0,0,0,0.9);
    text-align: center;
}

.spell-cast-name {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    color: var(--gold);
}

.spell-cast-arrow {
    font-size: 60px;
    animation: arrow-pulse 0.6s infinite;
    text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
}

@keyframes arrow-pulse {
    0%, 100% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.3); opacity: 1; }
}

.spell-target-deity {
    text-align: center;
    padding: 20px;
    background: linear-gradient(135deg, rgba(255, 0, 0, 0.3) 0%, rgba(100, 0, 0, 0.5) 100%);
    border: 3px solid #ff4444;
    border-radius: 15px;
    animation: target-shake 0.3s infinite;
}

.target-deity-name {
    font-family: 'Cinzel', serif;
    font-size: 18px;
    color: #ff4444;
    margin-bottom: 10px;
}

.spell-damage-preview {
    font-size: 32px;
    font-weight: bold;
    color: #ff0000;
    text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
    animation: damage-flash 0.5s infinite;
}

@keyframes damage-flash {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.1); }
}

.spell-target-avatar {
    text-align: center;
    padding: 15px;
    background: linear-gradient(135deg, rgba(255, 68, 68, 0.2) 0%, rgba(100, 0, 0, 0.4) 100%);
    border: 3px solid #ff4444;
    border-radius: 12px;
}

.spell-target-avatar img {
    width: 120px;
    height: 140px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 10px;
}

.spell-target-name {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    color: #ff4444;
}

.spell-effect-icon {
    font-size: 80px;
    animation: effect-spin 1s ease-out;
}

@keyframes effect-spin {
    0% { transform: rotate(0deg) scale(0.5); opacity: 0; }
    50% { transform: rotate(180deg) scale(1.2); opacity: 1; }
    100% { transform: rotate(360deg) scale(1); opacity: 1; }
}

@keyframes target-shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-3px); }
    75% { transform: translateX(3px); }
}

@keyframes spell-cast-appear {
    0% { transform: scale(0.5); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes spell-glow {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.3); }
}

/* ===== SHARD CHAIN PANEL ===== */
#shard-chain-panel {
    position: fixed;
    left: 15px;
    top: 50%;
    transform: translateY(-50%);
    width: 200px;
    background: linear-gradient(135deg, rgba(10, 5, 20, 0.98) 0%, rgba(30, 10, 50, 0.98) 100%);
    border: 2px solid var(--gold);
    border-radius: 12px;
    padding: 15px;
    z-index: 500;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
    box-shadow: 
        0 0 30px rgba(212, 175, 55, 0.4),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
}

#shard-chain-panel.visible {
    opacity: 1;
    visibility: visible;
}

.shard-chain-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
}

.chain-title {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    font-weight: 700;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 2px;
}

.chain-count {
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.6);
}

.shard-chain-links {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 300px;
    overflow-y: auto;
    margin-bottom: 12px;
}

.chain-link {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    background: linear-gradient(135deg, rgba(147, 51, 234, 0.2) 0%, rgba(76, 29, 149, 0.2) 100%);
    border: 1px solid rgba(147, 51, 234, 0.4);
    border-radius: 8px;
    animation: chain-link-appear 0.3s ease-out;
}

@keyframes chain-link-appear {
    0% { transform: translateX(-20px); opacity: 0; }
    100% { transform: translateX(0); opacity: 1; }
}

.link-number {
    width: 22px;
    height: 22px;
    background: linear-gradient(135deg, #9333ea 0%, #6b21a8 100%);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    font-weight: 700;
    color: #fff;
}

.link-name {
    flex: 1;
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-controller {
    font-family: 'Rajdhani', sans-serif;
    font-size: 10px;
    color: rgba(255, 255, 255, 0.5);
    padding: 2px 6px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
}

.shard-chain-controls {
    display: flex;
    gap: 8px;
}

.chain-btn {
    flex: 1;
    padding: 10px 15px;
    border: none;
    border-radius: 8px;
    font-family: 'Cinzel', serif;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
}

.chain-btn.pass-btn {
    background: linear-gradient(135deg, #475569 0%, #334155 100%);
    color: #fff;
    border: 1px solid #64748b;
}

.chain-btn.pass-btn:hover {
    background: linear-gradient(135deg, #64748b 0%, #475569 100%);
    box-shadow: 0 0 15px rgba(100, 116, 139, 0.4);
}

.chain-btn.respond-btn {
    background: linear-gradient(135deg, #9333ea 0%, #6b21a8 100%);
    color: #fff;
    border: 1px solid #a855f7;
}

.chain-btn.respond-btn:hover {
    background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%);
    box-shadow: 0 0 15px rgba(147, 51, 234, 0.6);
}

/* ===== CARD ZOOM PANEL ===== */
#card-zoom-panel {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

#card-zoom-panel:not(.hidden) {
    opacity: 1;
    visibility: visible;
}

.zoom-close {
    position: absolute;
    top: 20px;
    right: 30px;
    font-size: 48px;
    color: var(--gold);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.zoom-close:hover {
    transform: scale(1.2);
}

.zoom-content {
    display: flex;
    gap: 40px;
    max-width: 900px;
    padding: 30px;
}

.zoom-image-container {
    flex-shrink: 0;
}

.zoom-image-container img {
    width: 300px;
    height: auto;
    border-radius: 12px;
    box-shadow: 0 0 40px rgba(212, 175, 55, 0.4);
}

.zoom-details {
    flex: 1;
    color: #fff;
}

.zoom-details h2 {
    font-family: 'Cinzel', serif;
    font-size: 32px;
    color: var(--gold);
    margin-bottom: 15px;
    text-transform: uppercase;
}

.zoom-stats {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.zoom-type, .zoom-aspect, .zoom-cost {
    padding: 6px 14px;
    border-radius: 20px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
}

.zoom-type {
    background: rgba(107, 33, 168, 0.5);
    border: 1px solid #9333ea;
}

.zoom-aspect.glow { background: rgba(255, 215, 0, 0.3); border: 1px solid #ffd700; color: #ffd700; }
.zoom-aspect.void { background: rgba(75, 0, 130, 0.3); border: 1px solid #8b00ff; color: #c77dff; }
.zoom-aspect.gray { background: rgba(128, 128, 128, 0.3); border: 1px solid #aaa; color: #ccc; }

.zoom-cost {
    background: rgba(0, 200, 255, 0.2);
    border: 1px solid #00c8ff;
    color: #00c8ff;
}

.zoom-stats-row {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 24px;
    font-weight: 700;
}

.zoom-stats-row span {
    padding: 8px 16px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.zoom-effect {
    font-family: 'Rajdhani', sans-serif;
    font-size: 18px;
    line-height: 1.6;
    color: rgba(255, 255, 255, 0.9);
    background: rgba(0, 0, 0, 0.3);
    padding: 20px;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 15px;
}

.zoom-rarity {
    font-family: 'Cinzel', serif;
    font-size: 14px;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.5);
}

/* ===== CODEX OVERLAY ===== */
#codex-overlay {
    background: rgba(10, 10, 20, 0.98);
    z-index: 9500;
}

#codex-overlay:not(.hidden) {
    display: flex;
}

.codex-container {
    width: 90%;
    max-width: 900px;
    max-height: 85vh;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 2px solid var(--gold);
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 0 60px rgba(212, 175, 55, 0.3);
}

.codex-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 25px 30px;
    background: linear-gradient(180deg, rgba(212, 175, 55, 0.2) 0%, transparent 100%);
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
}

.codex-header h1 {
    font-family: 'Cinzel', serif;
    font-size: 28px;
    color: var(--gold);
    letter-spacing: 3px;
}

.codex-close {
    background: none;
    border: none;
    font-size: 36px;
    color: var(--gold);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.codex-close:hover {
    transform: scale(1.2);
}

.codex-tabs {
    display: flex;
    gap: 5px;
    padding: 15px 20px;
    background: rgba(0, 0, 0, 0.3);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    overflow-x: auto;
}

.codex-tab {
    padding: 10px 20px;
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.6);
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
}

.codex-tab:hover {
    background: rgba(212, 175, 55, 0.1);
    color: var(--gold);
}

.codex-tab.active {
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    color: #1a1a2e;
    border-color: var(--gold);
}

.codex-content {
    flex: 1;
    padding: 25px 30px;
    overflow-y: auto;
}

.codex-section {
    display: none;
}

.codex-section.active {
    display: block;
    animation: codex-fade-in 0.3s ease;
}

@keyframes codex-fade-in {
    0% { opacity: 0; transform: translateY(10px); }
    100% { opacity: 1; transform: translateY(0); }
}

.codex-section h2 {
    font-family: 'Cinzel', serif;
    font-size: 20px;
    color: var(--gold);
    margin: 20px 0 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
}

.codex-section h2:first-child {
    margin-top: 0;
}

.codex-section p {
    font-family: 'Rajdhani', sans-serif;
    font-size: 16px;
    line-height: 1.6;
    color: rgba(255, 255, 255, 0.85);
    margin-bottom: 12px;
}

.codex-section ul {
    margin: 10px 0 15px 25px;
    color: rgba(255, 255, 255, 0.8);
}

.codex-section li {
    font-family: 'Rajdhani', sans-serif;
    font-size: 15px;
    line-height: 1.8;
    margin-bottom: 5px;
}

.codex-section strong {
    color: var(--gold-light);
}

.aspect-glow { color: #ffd700; font-weight: 700; }
.aspect-void { color: #c77dff; font-weight: 700; }
.aspect-gray { color: #aaaaaa; font-weight: 700; }

/* ===== MOBILE RESPONSIVENESS ===== */
@media (max-width: 768px) {
    #phase-badge { right: 20px; top: 60px; font-size: 0.85em; }
    .deckbuilder-content { grid-template-columns: 1fr; gap: 10px; }
    .pool-cards { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
    #phase-tracker { padding: 6px 15px; gap: 5px; }
    .phase-step { padding: 4px 8px; }
    .phase-icon { font-size: 16px; }
    .phase-label { font-size: 7px; }
    #side-panel { right: 8px; gap: 8px; }
    .panel-btn { width: 40px; height: 40px; font-size: 14px; }
    #turn-controls { width: 100%; }
}

@media (max-width: 480px) {
    #phase-badge { font-size: 0.7em; padding: 8px 12px; }
    #phase-tracker { flex-wrap: wrap; padding: 5px 10px; }
    .phase-step { padding: 2px 6px; }
    .phase-icon { font-size: 14px; }
    #game-board { padding: 10px; }
    .overlay { padding: 10px; }
    #deckbuilder-overlay { width: 100%; max-width: 100%; max-height: 100%; }
    .deckbuilder-container { width: 100%; max-height: 100%; }
}

.mobile-tabs {
    display: none;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(180deg, #1a0a2e 0%, #0d0d1a 100%);
    border-top: 1px solid var(--gold);
    padding: 8px 0;
    z-index: 5000;
}

.mobile-tab {
    flex: 1;
    padding: 12px 0;
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.5);
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.2s ease;
}

.mobile-tab.active {
    color: var(--gold);
}

/* Legal target highlighting */
.legal-play {
    animation: legal-glow 1s ease-in-out infinite;
}

@keyframes legal-glow {
    0%, 100% { box-shadow: 0 0 10px 2px rgba(0, 255, 100, 0.5); }
    50% { box-shadow: 0 0 20px 4px rgba(0, 255, 100, 0.8); }
}

.legal-target {
    animation: target-glow 1s ease-in-out infinite;
}

@keyframes target-glow {
    0%, 100% { box-shadow: 0 0 10px 2px rgba(255, 100, 100, 0.5); }
    50% { box-shadow: 0 0 20px 4px rgba(255, 100, 100, 0.8); }
}

/* ===== MOBILE MEDIA QUERIES ===== */
@media (max-width: 768px) {
    .mobile-tabs {
        display: flex;
    }
    
    #game-board {
        transform: translate(-50%, -50%) perspective(800px) rotateX(5deg);
        width: 95%;
        height: 60%;
        top: 45%;
    }
    
    #hand-zone {
        bottom: 55px;
        height: 100px;
    }
    
    .hand-card {
        width: 60px;
        height: 84px;
    }
    
    #phase-tracker {
        top: 5px;
        transform: translateX(-50%) scale(0.8);
    }
    
    .phase-step {
        padding: 5px 8px;
    }
    
    #side-panel {
        right: 5px;
        gap: 5px;
    }
    
    .panel-btn {
        width: 35px;
        height: 35px;
        font-size: 14px;
    }
    
    #turn-controls {
        bottom: auto;
        top: 50px;
        right: 5px;
        flex-direction: column;
        gap: 5px;
    }
    
    .turn-btn {
        padding: 8px 12px;
        font-size: 11px;
    }
    
    .life-badge, .kl-badge {
        transform: scale(0.8);
    }
    
    .life-badge.player-1 { top: 60px; left: 5px; }
    .life-badge.player-2 { top: 5px; right: 45px; }
    .kl-badge.player-1 { bottom: 60px; left: 5px; }
    .kl-badge.player-2 { top: 55px; right: 45px; }
    
    #phase-badge {
        top: 5px;
        right: auto;
        left: 50%;
        transform: translateX(-50%) translateY(40px) scale(0.9);
    }
    
    .deity-display {
        width: 80px;
    }
    
    .deity-card-frame {
        width: 60px;
        height: 84px;
    }
    
    .card-slot {
        width: 45px;
        height: 63px;
    }
    
    .zone-label {
        font-size: 9px;
    }
    
    #log-panel {
        width: 100%;
        max-width: 100%;
        bottom: 55px;
        height: calc(40% - 55px);
    }
    
    #shard-chain-panel {
        width: 100%;
        max-width: 100%;
        bottom: 55px;
        right: 0;
        left: 0;
        height: calc(35% - 55px);
        border-radius: 0;
    }
    
    .codex-container {
        width: 95%;
        max-height: 80vh;
    }
    
    .codex-header h1 {
        font-size: 20px;
    }
    
    .codex-tabs {
        padding: 10px;
    }
    
    .codex-tab {
        padding: 8px 12px;
        font-size: 12px;
    }
    
    .zoom-content {
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }
    
    .zoom-image-container img {
        width: 200px;
    }
    
    .zoom-details h2 {
        font-size: 24px;
        text-align: center;
    }
    
    .zoom-stats {
        justify-content: center;
    }
    
}

/* ===== FRIENDS SCREEN ===== */
#friends-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, #1a0a2e 0%, #0d1b2a 50%, #1a0a2e 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

#friends-overlay.hidden {
    display: none;
}

.friends-container {
    max-width: 700px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 40px;
    background: rgba(60, 48, 38, 0.95);
    border: 3px solid var(--gold);
    border-radius: 20px;
    box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8), 0 0 60px rgba(212, 175, 55, 0.3);
}

.friends-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
}

.friends-header h1 {
    font-family: 'Cinzel', serif;
    font-size: 2rem;
    color: var(--gold);
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
}

.friends-close {
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.8), rgba(160, 120, 30, 0.8));
    border: 2px solid var(--gold);
    color: #000;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
}

.friends-close:hover {
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
}

.friends-sections {
    display: flex;
    flex-direction: column;
    gap: 30px;
}

.section {
    padding: 20px;
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 12px;
}

.section h2 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    margin-bottom: 15px;
    font-size: 1.3rem;
}

.add-friend-btn {
    margin-bottom: 15px;
    padding: 10px 15px;
    background: rgba(0, 255, 204, 0.2);
    border: 2px solid #00ffcc;
    color: #00ffcc;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
}

.add-friend-btn:hover {
    background: rgba(0, 255, 204, 0.3);
    box-shadow: 0 0 15px rgba(0, 255, 204, 0.4);
}

.friends-list, .requests-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.friend-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background: linear-gradient(135deg, rgba(50, 100, 100, 0.3), rgba(30, 70, 70, 0.3));
    border: 1px solid rgba(0, 255, 204, 0.3);
    border-radius: 8px;
}

.friend-item.offline {
    background: linear-gradient(135deg, rgba(70, 70, 70, 0.3), rgba(50, 50, 50, 0.3));
    border-color: rgba(200, 200, 200, 0.2);
}

.friend-name {
    font-weight: 600;
    color: #fff;
}

.friend-status {
    font-size: 0.8rem;
    color: #00ffcc;
}

.friend-item.offline .friend-status {
    color: #999;
}

.challenge-btn {
    padding: 8px 16px;
    background: linear-gradient(135deg, rgba(0, 255, 204, 0.7), rgba(0, 200, 180, 0.7));
    border: 1px solid #00ffcc;
    color: #000;
    border-radius: 6px;
    font-weight: 600;
    cursor: pointer;
}

.challenge-btn:hover {
    background: linear-gradient(135deg, #00ffcc, rgba(0, 150, 130, 1));
    transform: scale(1.05);
}

.request-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background: linear-gradient(135deg, rgba(100, 80, 30, 0.3), rgba(70, 50, 20, 0.3));
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 8px;
}

.accept-btn, .decline-btn {
    padding: 6px 12px;
    border: 1px solid;
    border-radius: 6px;
    font-weight: 600;
    cursor: pointer;
    font-size: 0.85rem;
    margin-left: 5px;
}

.accept-btn {
    background: rgba(0, 200, 100, 0.3);
    border-color: #00cc66;
    color: #00ff88;
}

.accept-btn:hover {
    background: rgba(0, 200, 100, 0.5);
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.4);
}

.decline-btn {
    background: rgba(200, 0, 0, 0.3);
    border-color: #cc0000;
    color: #ff6666;
}

.decline-btn:hover {
    background: rgba(200, 0, 0, 0.5);
    box-shadow: 0 0 10px rgba(255, 100, 100, 0.4);
}

/* ===== REPLAY BROWSER ===== */
#replay-browser-overlay, #spectate-browser-overlay, #analytics-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, #1a0a2e 0%, #0d1b2a 50%, #1a0a2e 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

#replay-browser-overlay.hidden, #spectate-browser-overlay.hidden, #analytics-overlay.hidden {
    display: none;
}

.replay-browser-container, .spectate-browser-container, .analytics-container {
    max-width: 700px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 30px;
    background: rgba(60, 48, 38, 0.95);
    border: 3px solid var(--gold);
    border-radius: 20px;
    box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8), 0 0 60px rgba(212, 175, 55, 0.3);
}

.replay-browser-header, .spectate-browser-header, .analytics-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
}

.replay-browser-header h1, .spectate-browser-header h1, .analytics-header h1 {
    font-family: 'Cinzel', serif;
    font-size: 1.8rem;
    color: var(--gold);
}

.close-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid var(--gold);
    background: transparent;
    color: var(--gold);
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.2s;
}

.close-btn:hover {
    background: var(--gold);
    color: #000;
}

.replay-list, .live-matches-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.replay-item, .live-match-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    background: linear-gradient(135deg, rgba(50, 50, 80, 0.4), rgba(30, 30, 50, 0.4));
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
}

.replay-item:hover, .live-match-item:hover {
    border-color: var(--gold);
    background: linear-gradient(135deg, rgba(70, 70, 100, 0.5), rgba(40, 40, 60, 0.5));
    transform: translateX(5px);
}

.replay-matchup {
    display: flex;
    align-items: center;
    gap: 10px;
}

.replay-matchup .deity {
    font-weight: 600;
    color: #fff;
}

.replay-matchup .vs {
    color: rgba(255, 255, 255, 0.5);
    font-size: 0.85rem;
}

.replay-details {
    display: flex;
    gap: 15px;
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.6);
}

.replay-mode {
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 700;
}

.replay-mode.ranked {
    background: rgba(212, 175, 55, 0.3);
    color: var(--gold);
}

.replay-mode.casual {
    background: rgba(100, 100, 100, 0.3);
    color: #aaa;
}

.no-replays, .no-matches, .no-data {
    text-align: center;
    color: rgba(255, 255, 255, 0.5);
    padding: 40px;
    font-style: italic;
}

.replay-browser-footer, .analytics-footer {
    margin-top: 20px;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.secondary-btn {
    padding: 10px 20px;
    background: transparent;
    border: 2px solid rgba(212, 175, 55, 0.5);
    color: var(--gold);
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
}

.secondary-btn:hover {
    background: rgba(212, 175, 55, 0.2);
    border-color: var(--gold);
}

/* ===== REPLAY VIEWER CONTROLS ===== */
.replay-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 500;
    padding: 15px 20px;
    background: linear-gradient(0deg, rgba(10, 5, 20, 0.98), rgba(20, 10, 40, 0.95));
    border-top: 2px solid var(--gold);
}

.replay-controls.hidden {
    display: none;
}

.replay-bar {
    max-width: 1200px;
    margin: 0 auto;
}

.replay-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    color: #fff;
}

.replay-title {
    font-family: 'Cinzel', serif;
    font-weight: 600;
    color: var(--gold);
}

.replay-date {
    color: rgba(255, 255, 255, 0.5);
}

.replay-controls-row {
    display: flex;
    align-items: center;
    gap: 15px;
}

.replay-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid var(--gold);
    background: transparent;
    color: var(--gold);
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.2s;
}

.replay-btn:hover {
    background: var(--gold);
    color: #000;
}

.replay-btn.close {
    margin-left: auto;
    background: rgba(200, 0, 0, 0.3);
    border-color: #ff4444;
    color: #ff4444;
}

.replay-btn.close:hover {
    background: #ff4444;
    color: #fff;
}

.replay-slider {
    flex: 1;
    height: 8px;
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.2);
    cursor: pointer;
    -webkit-appearance: none;
}

.replay-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--gold);
    cursor: pointer;
}

.replay-turn, .replay-action {
    font-family: 'Rajdhani', sans-serif;
    color: rgba(255, 255, 255, 0.7);
    min-width: 100px;
}

/* ===== SPECTATOR CONTROLS ===== */
.spectator-controls {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 500;
    padding: 10px 20px;
    background: linear-gradient(180deg, rgba(100, 0, 0, 0.9), rgba(50, 0, 0, 0.8));
    border-bottom: 2px solid #ff4444;
}

.spectator-controls.hidden {
    display: none;
}

.spectator-bar {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.spectator-info {
    display: flex;
    align-items: center;
    gap: 15px;
}

.spectator-badge {
    background: #ff4444;
    color: #fff;
    padding: 4px 12px;
    border-radius: 4px;
    font-weight: 700;
    font-size: 0.85rem;
    animation: pulse-spectate 2s infinite;
}

@keyframes pulse-spectate {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.spectator-match {
    color: #fff;
    font-weight: 600;
}

.spectator-delay {
    color: rgba(255, 255, 255, 0.5);
    font-size: 0.85rem;
}

.spectator-turn {
    color: var(--gold);
    font-family: 'Cinzel', serif;
}

.spectator-btn {
    padding: 8px 16px;
    background: transparent;
    border: 2px solid #ff4444;
    color: #ff4444;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
}

.spectator-btn:hover {
    background: #ff4444;
    color: #fff;
}

/* ===== ANALYTICS ===== */
.analytics-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}

.analytics-tab {
    padding: 10px 20px;
    background: transparent;
    border: 2px solid rgba(212, 175, 55, 0.3);
    color: rgba(255, 255, 255, 0.7);
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
}

.analytics-tab:hover {
    border-color: rgba(212, 175, 55, 0.6);
    color: #fff;
}

.analytics-tab.active {
    background: rgba(212, 175, 55, 0.2);
    border-color: var(--gold);
    color: var(--gold);
}

.analytics-content {
    min-height: 300px;
    max-height: 400px;
    overflow-y: auto;
}

.analytics-table {
    width: 100%;
    border-collapse: collapse;
}

.analytics-table th, .analytics-table td {
    padding: 10px 12px;
    text-align: left;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.analytics-table th {
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 0.9rem;
}

.analytics-table td {
    color: rgba(255, 255, 255, 0.8);
}

.analytics-table .winrate {
    color: #00ff88;
    font-weight: 600;
}

.analytics-table tbody tr:hover {
    background: rgba(212, 175, 55, 0.1);
}

/* Replay/Spectator mode styling */
.replay-mode #game-board, .spectator-mode #game-board {
    pointer-events: none;
}

.replay-mode .card, .spectator-mode .card {
    cursor: default !important;
}

@media (max-width: 768px) {
    .replay-controls-row {
        flex-wrap: wrap;
    }
    
    .replay-slider {
        order: 3;
        width: 100%;
        margin-top: 10px;
    }
}

@media (max-width: 768px) {
    .mobile-tabs {
        display: flex;
        gap: 0;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 60;
        background: rgba(0, 0, 0, 0.9);
        border-top: 2px solid var(--gold);
    }
    
    .mobile-tab {
        flex: 1;
        padding: 12px;
        border: none;
        background: transparent;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
        border-top: 3px solid transparent;
    }
    
    .mobile-tab.active {
        color: var(--gold);
        border-top-color: var(--gold);
        background: rgba(212, 175, 55, 0.1);
    }
    
    .mobile-tab:active {
        background: rgba(212, 175, 55, 0.2);
    }
}

@media (max-width: 480px) {
    #game-board {
        height: 55%;
        top: 40%;
    }
    
    .board-row {
        gap: 3px;
    }
    
    .card-slot {
        width: 38px;
        height: 53px;
    }
    
    .phase-step {
        padding: 3px 5px;
    }
    
    .phase-icon {
        font-size: 14px;
    }
    
    .phase-label {
        font-size: 9px;
    }
    
    .hand-card {
        width: 50px;
        height: 70px;
    }
    
    .deity-display {
        width: 60px;
    }
    
    .deity-card-frame {
        width: 50px;
        height: 70px;
    }
}

/* ===== QUEUE EXTRAS (Tournaments & Events buttons) ===== */
.queue-extras {
    display: flex;
    gap: 15px;
    margin-top: 25px;
    justify-content: center;
}

.queue-extra-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 25px;
    background: rgba(50, 50, 80, 0.4);
    border: 2px solid rgba(212, 175, 55, 0.4);
    border-radius: 10px;
    color: #fff;
    font-family: 'Rajdhani', sans-serif;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
}

.queue-extra-btn:hover {
    background: rgba(212, 175, 55, 0.2);
    border-color: var(--gold);
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(212, 175, 55, 0.3);
}

.extra-icon {
    font-size: 1.3rem;
}

.extra-title {
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* ===== TOURNAMENT OVERLAY ===== */
#tournament-overlay, #tournament-detail-overlay, #events-overlay, #event-queue-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, #1a0a2e 0%, #0d1b2a 50%, #1a0a2e 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

#tournament-overlay.hidden, #tournament-detail-overlay.hidden, #events-overlay.hidden, #event-queue-overlay.hidden {
    display: none;
}

.tournament-container, .tournament-detail-container, .events-container, .event-queue-container {
    max-width: 800px;
    width: 95%;
    max-height: 85vh;
    overflow-y: auto;
    padding: 30px;
    background: rgba(60, 48, 38, 0.95);
    border: 3px solid var(--gold);
    border-radius: 20px;
    box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8), 0 0 60px rgba(212, 175, 55, 0.3);
}

.tournament-header, .events-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
}

.tournament-header h1, .events-header h1 {
    font-family: 'Cinzel', serif;
    font-size: 1.8rem;
    color: var(--gold);
}

/* Tournament Tabs */
.tournament-tabs {
    display: flex;
    gap: 5px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.tournament-tab {
    padding: 10px 20px;
    background: rgba(50, 50, 80, 0.3);
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.7);
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.tournament-tab:hover {
    background: rgba(212, 175, 55, 0.2);
    color: #fff;
}

.tournament-tab.active {
    background: var(--gold);
    color: #000;
    border-color: var(--gold);
}

.tournament-content {
    min-height: 300px;
}

/* Tournament List */
.tournament-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.tournament-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 18px 20px;
    background: linear-gradient(135deg, rgba(50, 50, 80, 0.4), rgba(30, 30, 50, 0.4));
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s;
}

.tournament-item:hover {
    border-color: var(--gold);
    background: linear-gradient(135deg, rgba(70, 70, 100, 0.5), rgba(40, 40, 60, 0.5));
    transform: translateX(5px);
}

.tournament-info {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.tournament-name {
    font-family: 'Cinzel', serif;
    font-size: 1.1rem;
    color: #fff;
    font-weight: 600;
}

.tournament-meta {
    display: flex;
    gap: 15px;
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.6);
}

.tournament-format {
    padding: 3px 10px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
}

.tournament-format.swiss {
    background: rgba(100, 150, 255, 0.3);
    color: #88bbff;
}

.tournament-format.elimination {
    background: rgba(255, 100, 100, 0.3);
    color: #ff8888;
}

.tournament-players {
    display: flex;
    align-items: center;
    gap: 8px;
    color: rgba(255, 255, 255, 0.8);
}

.tournament-status {
    padding: 5px 12px;
    border-radius: 6px;
    font-size: 0.8rem;
    font-weight: 700;
    text-transform: uppercase;
}

.tournament-status.registration {
    background: rgba(100, 200, 100, 0.3);
    color: #88ff88;
}

.tournament-status.active {
    background: rgba(255, 200, 50, 0.3);
    color: #ffcc33;
}

.tournament-status.completed {
    background: rgba(150, 150, 150, 0.3);
    color: #aaa;
}

/* Tournament Create Form */
.create-tournament-form {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.form-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.form-group label {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 0.9rem;
}

.form-group input, .form-group select {
    padding: 12px 15px;
    background: rgba(30, 30, 50, 0.6);
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 8px;
    color: #fff;
    font-family: 'Rajdhani', sans-serif;
    font-size: 1rem;
}

.form-group input:focus, .form-group select:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
}

.form-group select option {
    background: #1a1a2e;
    color: #fff;
}

.form-row {
    display: flex;
    gap: 15px;
}

.form-row .form-group {
    flex: 1;
}

.create-btn {
    padding: 15px 30px;
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    border: none;
    border-radius: 10px;
    color: #000;
    font-family: 'Cinzel', serif;
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.create-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(212, 175, 55, 0.4);
}

/* Tournament Detail View */
.tournament-detail-header {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
}

.back-btn {
    padding: 8px 15px;
    background: transparent;
    border: 1px solid rgba(212, 175, 55, 0.5);
    border-radius: 6px;
    color: var(--gold);
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.back-btn:hover {
    background: rgba(212, 175, 55, 0.2);
}

.tournament-detail-header h1 {
    font-family: 'Cinzel', serif;
    font-size: 1.5rem;
    color: var(--gold);
    flex: 1;
}

.tournament-detail-info {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
    padding: 15px;
    background: rgba(30, 30, 50, 0.4);
    border-radius: 10px;
}

.info-row {
    display: flex;
    flex-direction: column;
    gap: 3px;
}

.info-label {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
}

.info-row span:last-child {
    font-size: 1.1rem;
    color: #fff;
    font-weight: 600;
}

.tournament-detail-actions {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}

.action-btn {
    padding: 12px 25px;
    border-radius: 8px;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
}

.action-btn.primary {
    background: var(--gold);
    border: none;
    color: #000;
}

.action-btn.primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(212, 175, 55, 0.4);
}

.action-btn.secondary {
    background: transparent;
    border: 1px solid var(--gold);
    color: var(--gold);
}

.action-btn.secondary:hover {
    background: rgba(212, 175, 55, 0.2);
}

.action-btn.danger {
    background: transparent;
    border: 1px solid #ff4444;
    color: #ff4444;
}

.action-btn.danger:hover {
    background: rgba(255, 68, 68, 0.2);
}

/* Detail Tabs */
.tournament-detail-tabs {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
}

.detail-tab {
    padding: 8px 18px;
    background: rgba(50, 50, 80, 0.3);
    border: 1px solid rgba(212, 175, 55, 0.2);
    border-radius: 6px;
    color: rgba(255, 255, 255, 0.7);
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.detail-tab:hover {
    background: rgba(212, 175, 55, 0.15);
}

.detail-tab.active {
    background: var(--gold);
    color: #000;
    border-color: var(--gold);
}

.tournament-detail-content {
    min-height: 200px;
}

/* Matches List */
.matches-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.match-item {
    display: flex;
    align-items: center;
    padding: 15px;
    background: rgba(40, 40, 60, 0.4);
    border: 1px solid rgba(212, 175, 55, 0.2);
    border-radius: 10px;
}

.match-players {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 15px;
}

.match-player {
    flex: 1;
    text-align: center;
    font-weight: 600;
    color: #fff;
}

.match-player.winner {
    color: var(--gold);
}

.match-vs {
    color: rgba(255, 255, 255, 0.4);
    font-size: 0.9rem;
}

.match-result {
    padding: 5px 12px;
    border-radius: 5px;
    font-size: 0.85rem;
    font-weight: 700;
}

.match-result.completed {
    background: rgba(100, 200, 100, 0.2);
    color: #88ff88;
}

.match-result.pending {
    background: rgba(255, 200, 50, 0.2);
    color: #ffcc33;
}

.match-actions {
    display: flex;
    gap: 8px;
}

.report-btn {
    padding: 8px 15px;
    background: var(--gold);
    border: none;
    border-radius: 5px;
    color: #000;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
}

.report-btn:hover {
    transform: scale(1.05);
}

/* Standings Table */
.standings-table {
    width: 100%;
    border-collapse: collapse;
}

.standings-table th, .standings-table td {
    padding: 12px 10px;
    text-align: left;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.standings-table th {
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 0.85rem;
}

.standings-table td {
    color: rgba(255, 255, 255, 0.9);
}

.standings-table .rank {
    font-weight: 700;
    color: var(--gold);
}

.standings-table tbody tr:hover {
    background: rgba(212, 175, 55, 0.1);
}

/* Bracket View */
.bracket-container {
    display: flex;
    gap: 30px;
    overflow-x: auto;
    padding: 20px 0;
}

.bracket-round {
    display: flex;
    flex-direction: column;
    gap: 15px;
    min-width: 200px;
}

.bracket-round-title {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    text-align: center;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    margin-bottom: 10px;
}

.bracket-match {
    background: rgba(40, 40, 60, 0.5);
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 8px;
    overflow: hidden;
}

.bracket-player {
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.bracket-player:last-child {
    border-bottom: none;
}

.bracket-player.winner {
    background: rgba(212, 175, 55, 0.2);
    color: var(--gold);
}

.bracket-player .score {
    font-weight: 700;
}

/* ===== EVENTS OVERLAY ===== */
.events-description {
    text-align: center;
    color: rgba(255, 255, 255, 0.6);
    margin-bottom: 25px;
}

.events-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 15px;
}

.event-card {
    padding: 20px;
    background: linear-gradient(135deg, rgba(50, 50, 80, 0.5), rgba(30, 30, 50, 0.5));
    border: 2px solid rgba(212, 175, 55, 0.3);
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s;
}

.event-card:hover {
    border-color: var(--gold);
    transform: translateY(-5px);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
}

.event-card-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
}

.event-icon {
    font-size: 2rem;
}

.event-card-header h3 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 1.1rem;
}

.event-card-description {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    margin-bottom: 15px;
    line-height: 1.4;
}

.event-card-meta {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.event-tag {
    padding: 4px 10px;
    background: rgba(100, 100, 150, 0.3);
    border-radius: 4px;
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.8);
}

.event-tag.aspect-glow {
    background: rgba(255, 220, 100, 0.2);
    color: #ffee88;
}

.event-tag.aspect-void {
    background: rgba(100, 50, 150, 0.3);
    color: #cc88ff;
}

.event-tag.aspect-gray {
    background: rgba(150, 150, 150, 0.3);
    color: #cccccc;
}

/* Event Queue Confirmation */
.event-queue-container {
    max-width: 500px;
    text-align: center;
}

.event-queue-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    margin-bottom: 25px;
}

.event-queue-header .event-icon {
    font-size: 3rem;
}

.event-queue-header h2 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 1.5rem;
}

.event-queue-rules {
    text-align: left;
    margin-bottom: 25px;
    padding: 20px;
    background: rgba(30, 30, 50, 0.5);
    border-radius: 10px;
}

.event-rule {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.event-rule:last-child {
    border-bottom: none;
}

.event-rule .rule-label {
    color: rgba(255, 255, 255, 0.6);
}

.event-rule .rule-value {
    color: #fff;
    font-weight: 600;
}

.event-queue-actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.queue-btn.event-queue {
    background: linear-gradient(135deg, #8b5cf6, #6d28d9);
    border-color: #a78bfa;
}

.queue-btn.event-queue:hover {
    box-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
}

/* No tournaments message */
.no-tournaments {
    text-align: center;
    color: rgba(255, 255, 255, 0.5);
    padding: 50px 20px;
    font-style: italic;
}

/* ===== LIMITED MODE STYLES ===== */
.limited-container {
    max-width: 700px;
    text-align: center;
}

.limited-header h1 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 2rem;
    margin-bottom: 20px;
}

.limited-modes {
    display: flex;
    gap: 20px;
    justify-content: center;
    padding: 20px;
}

.limited-mode-card {
    flex: 1;
    max-width: 280px;
    padding: 30px 20px;
    background: rgba(30, 30, 50, 0.8);
    border: 2px solid rgba(100, 100, 150, 0.3);
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.limited-mode-card:hover:not(.coming-soon) {
    border-color: var(--gold);
    transform: translateY(-5px);
    box-shadow: 0 10px 30px rgba(212, 175, 55, 0.2);
}

.limited-mode-card.coming-soon {
    opacity: 0.5;
    cursor: not-allowed;
    position: relative;
}

.limited-mode-card .mode-icon {
    font-size: 3rem;
    margin-bottom: 15px;
}

.limited-mode-card h2 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    margin-bottom: 10px;
}

.limited-mode-card p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    margin-bottom: 15px;
}

.limited-mode-card ul {
    list-style: none;
    text-align: left;
    padding: 0;
}

.limited-mode-card li {
    padding: 5px 0;
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.85rem;
}

.limited-mode-card li::before {
    content: '‚ú¶ ';
    color: var(--gold);
}

.coming-soon-badge {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-15deg);
    background: rgba(255, 100, 100, 0.8);
    padding: 10px 20px;
    border-radius: 5px;
    font-weight: 700;
    font-size: 0.9rem;
}

/* Sealed Deckbuilder */
.sealed-container {
    width: 95vw;
    max-width: 1400px;
    height: 85vh;
    display: flex;
    flex-direction: column;
}

.sealed-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.sealed-header h1 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 1.5rem;
}

.sealed-stats {
    display: flex;
    gap: 20px;
}

.sealed-stats span {
    padding: 8px 15px;
    background: rgba(30, 30, 50, 0.6);
    border-radius: 8px;
    font-size: 0.9rem;
}

.sealed-content {
    flex: 1;
    display: flex;
    gap: 20px;
    padding: 20px;
    overflow: hidden;
}

.sealed-pool-section,
.sealed-deck-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: rgba(20, 20, 40, 0.5);
    border-radius: 10px;
    overflow: hidden;
}

.sealed-pool-section h2,
.sealed-deck-section h2 {
    padding: 15px;
    font-family: 'Cinzel', serif;
    font-size: 1rem;
    color: var(--gold);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.sealed-card-grid {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
    padding: 15px;
    overflow-y: auto;
    align-content: start;
}

.sealed-card {
    aspect-ratio: 0.7;
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid transparent;
    position: relative;
}

.sealed-card:hover {
    transform: scale(1.05);
    border-color: var(--gold);
    z-index: 10;
}

.sealed-card .rarity-indicator {
    position: absolute;
    bottom: 5px;
    right: 5px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
}

.sealed-card .rarity-indicator.Mythic { background: linear-gradient(135deg, #ff6b6b, #ffd93d); }
.sealed-card .rarity-indicator.Arcane { background: linear-gradient(135deg, #a855f7, #6366f1); }
.sealed-card .rarity-indicator.Master { background: linear-gradient(135deg, #f97316, #ea580c); }
.sealed-card .rarity-indicator.Adept { background: linear-gradient(135deg, #22c55e, #16a34a); }
.sealed-card .rarity-indicator.Shard { background: linear-gradient(135deg, #94a3b8, #64748b); }

.sealed-actions {
    display: flex;
    justify-content: space-between;
    padding: 15px 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.queue-btn.sealed-play {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    border-color: #4ade80;
}

.queue-btn.sealed-play:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* ===== COSMETICS STYLES ===== */
.cosmetics-container {
    width: 90vw;
    max-width: 1200px;
    height: 80vh;
    display: flex;
    flex-direction: column;
}

.cosmetics-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.cosmetics-header h1 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 1.8rem;
}

.currency-display {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: rgba(30, 30, 50, 0.6);
    border-radius: 25px;
    font-size: 1.1rem;
    font-weight: 600;
}

.shard-icon {
    font-size: 1.3rem;
}

.cosmetics-tabs {
    display: flex;
    gap: 5px;
    padding: 15px 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    overflow-x: auto;
}

.cosmetic-tab {
    padding: 10px 20px;
    background: rgba(50, 50, 80, 0.4);
    border: 1px solid rgba(100, 100, 150, 0.3);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.cosmetic-tab:hover {
    background: rgba(80, 80, 120, 0.5);
}

.cosmetic-tab.active {
    background: linear-gradient(135deg, var(--purple), var(--purple-dark));
    border-color: var(--gold);
    color: #fff;
}

.cosmetics-grid {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 20px;
    padding: 20px;
    overflow-y: auto;
    align-content: start;
}

.cosmetic-item {
    background: rgba(30, 30, 50, 0.7);
    border: 2px solid rgba(100, 100, 150, 0.3);
    border-radius: 12px;
    padding: 20px;
    text-align: center;
    transition: all 0.3s ease;
}

.cosmetic-item:hover {
    border-color: var(--gold);
    transform: translateY(-3px);
}

.cosmetic-item.owned {
    border-color: rgba(34, 197, 94, 0.5);
}

.cosmetic-item.equipped {
    border-color: var(--gold);
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
}

.cosmetic-preview {
    width: 100%;
    aspect-ratio: 1;
    background: rgba(20, 20, 40, 0.5);
    border-radius: 8px;
    margin-bottom: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 3rem;
}

.cosmetic-item h3 {
    font-size: 0.95rem;
    color: #fff;
    margin-bottom: 5px;
}

.cosmetic-rarity {
    font-size: 0.75rem;
    text-transform: uppercase;
    margin-bottom: 10px;
}

.cosmetic-rarity.common { color: #94a3b8; }
.cosmetic-rarity.rare { color: #60a5fa; }
.cosmetic-rarity.epic { color: #a855f7; }
.cosmetic-rarity.legendary { color: #f97316; }
.cosmetic-rarity.mythic { color: #ef4444; }

.cosmetic-price {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    font-weight: 600;
    margin-bottom: 10px;
}

.cosmetic-btn {
    width: 100%;
    padding: 8px 15px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s ease;
}

.cosmetic-btn.purchase {
    background: linear-gradient(135deg, #8b5cf6, #6d28d9);
    color: #fff;
}

.cosmetic-btn.equip {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    color: #fff;
}

.cosmetic-btn.equipped {
    background: rgba(100, 100, 150, 0.3);
    color: rgba(255, 255, 255, 0.5);
    cursor: default;
}

/* ===== SHARD PATH (BATTLE PASS) STYLES ===== */
.shard-path-container {
    width: 95vw;
    max-width: 1400px;
    height: 85vh;
    display: flex;
    flex-direction: column;
}

.shard-path-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    flex-wrap: wrap;
    gap: 15px;
}

.season-info h1 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 1.5rem;
}

.season-info span {
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.85rem;
}

.path-stats {
    display: flex;
    gap: 25px;
    align-items: center;
}

.xp-display {
    display: flex;
    flex-direction: column;
    gap: 5px;
    min-width: 200px;
}

.xp-display > span:first-child {
    font-weight: 600;
    color: var(--gold);
}

.xp-bar {
    height: 8px;
    background: rgba(30, 30, 50, 0.8);
    border-radius: 4px;
    overflow: hidden;
}

.xp-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--gold-dark), var(--gold));
    transition: width 0.5s ease;
}

.xp-display > span:last-child {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.6);
}

.shard-path-tabs {
    display: flex;
    gap: 10px;
    padding: 15px 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.path-tab {
    padding: 10px 25px;
    background: rgba(50, 50, 80, 0.4);
    border: 1px solid rgba(100, 100, 150, 0.3);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    transition: all 0.2s ease;
}

.path-tab:hover {
    background: rgba(80, 80, 120, 0.5);
}

.path-tab.active {
    background: linear-gradient(135deg, var(--gold-dark), var(--gold));
    border-color: var(--gold-light);
    color: #000;
    font-weight: 600;
}

.shard-path-content {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
}

.reward-tracks {
    display: flex;
    flex-direction: column;
    gap: 30px;
}

.track {
    background: rgba(20, 20, 40, 0.5);
    border-radius: 15px;
    padding: 20px;
}

.track h3 {
    font-family: 'Cinzel', serif;
    margin-bottom: 15px;
    color: rgba(255, 255, 255, 0.9);
    display: flex;
    align-items: center;
    gap: 10px;
}

.premium-track h3 {
    color: var(--gold);
}

.track-rewards {
    display: flex;
    gap: 15px;
    overflow-x: auto;
    padding: 10px 0;
}

.reward-node {
    min-width: 120px;
    padding: 15px;
    background: rgba(30, 30, 50, 0.6);
    border: 2px solid rgba(100, 100, 150, 0.3);
    border-radius: 10px;
    text-align: center;
    flex-shrink: 0;
    transition: all 0.3s ease;
}

.reward-node.unlocked {
    border-color: var(--gold);
}

.reward-node.claimed {
    opacity: 0.5;
    border-color: rgba(34, 197, 94, 0.5);
}

.reward-node.locked {
    opacity: 0.4;
}

.reward-level {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.5);
    margin-bottom: 8px;
}

.reward-icon {
    font-size: 2rem;
    margin-bottom: 8px;
}

.reward-name {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 10px;
}

.reward-claim-btn {
    width: 100%;
    padding: 6px 10px;
    border-radius: 5px;
    border: none;
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.reward-claim-btn.claim {
    background: linear-gradient(135deg, var(--gold-dark), var(--gold));
    color: #000;
}

.reward-claim-btn.claimed {
    background: rgba(100, 100, 150, 0.3);
    color: rgba(255, 255, 255, 0.4);
    cursor: default;
}

.reward-claim-btn.locked {
    background: rgba(50, 50, 80, 0.4);
    color: rgba(255, 255, 255, 0.3);
    cursor: not-allowed;
}

/* Quest Styles */
.shard-path-quests {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
}

.shard-path-quests.hidden {
    display: none;
}

.quest-section {
    margin-bottom: 30px;
}

.quest-section h3 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    margin-bottom: 15px;
}

.quest-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.quest-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    background: rgba(30, 30, 50, 0.6);
    border: 1px solid rgba(100, 100, 150, 0.3);
    border-radius: 10px;
}

.quest-item.completed {
    border-color: rgba(34, 197, 94, 0.5);
}

.quest-item.claimed {
    opacity: 0.5;
}

.quest-info {
    flex: 1;
}

.quest-info h4 {
    font-size: 1rem;
    margin-bottom: 5px;
}

.quest-info p {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.6);
}

.quest-progress {
    display: flex;
    align-items: center;
    gap: 15px;
}

.quest-progress-bar {
    width: 150px;
    height: 8px;
    background: rgba(20, 20, 40, 0.8);
    border-radius: 4px;
    overflow: hidden;
}

.quest-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #22c55e, #4ade80);
    transition: width 0.3s ease;
}

.quest-progress-text {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
    min-width: 60px;
    text-align: right;
}

.quest-reward {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 8px 15px;
    background: rgba(50, 50, 80, 0.4);
    border-radius: 6px;
    margin-left: 15px;
}

.quest-claim-btn {
    padding: 8px 20px;
    border-radius: 6px;
    border: none;
    font-weight: 600;
    cursor: pointer;
    margin-left: 15px;
}

.quest-claim-btn.claim {
    background: linear-gradient(135deg, var(--gold-dark), var(--gold));
    color: #000;
}

.quest-claim-btn:disabled {
    background: rgba(100, 100, 150, 0.3);
    color: rgba(255, 255, 255, 0.4);
    cursor: not-allowed;
}

#premium-status.locked {
    opacity: 0.7;
}

#premium-status.unlocked {
    color: var(--gold);
}

/* Queue extras secondary row */
.queue-extras.secondary {
    margin-top: 10px;
}

.queue-extra-btn.cosmetic {
    background: linear-gradient(135deg, rgba(168, 85, 247, 0.3), rgba(107, 33, 168, 0.4));
    border-color: rgba(168, 85, 247, 0.5);
}

.queue-extra-btn.cosmetic:hover {
    background: linear-gradient(135deg, rgba(168, 85, 247, 0.5), rgba(107, 33, 168, 0.6));
    border-color: rgba(168, 85, 247, 0.8);
}

.queue-extra-btn.shardpath {
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.3), rgba(170, 138, 46, 0.4));
    border-color: rgba(212, 175, 55, 0.5);
}

.queue-extra-btn.shardpath:hover {
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.5), rgba(170, 138, 46, 0.6));
    border-color: rgba(212, 175, 55, 0.8);
}

/* Queue extras tertiary row */
.queue-extras.tertiary {
    margin-top: 10px;
}

.queue-extra-btn.sandbox {
    background: linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(22, 163, 74, 0.4));
    border-color: rgba(34, 197, 94, 0.5);
}

.queue-extra-btn.sandbox:hover {
    background: linear-gradient(135deg, rgba(34, 197, 94, 0.5), rgba(22, 163, 74, 0.6));
    border-color: rgba(34, 197, 94, 0.8);
}

.queue-extra-btn.custom {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(37, 99, 235, 0.4));
    border-color: rgba(59, 130, 246, 0.5);
}

.queue-extra-btn.custom:hover {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.5), rgba(37, 99, 235, 0.6));
    border-color: rgba(59, 130, 246, 0.8);
}

/* ===== ACCESSIBILITY SETTINGS ===== */

/* Text Size Scaling */
body.text-small { font-size: 14px; }
body.text-medium { font-size: 16px; }
body.text-large { font-size: 18px; }

body.text-small .game-card { transform: scale(0.9); }
body.text-large .game-card { transform: scale(1.1); }

body.text-small .zoom-details h2 { font-size: 1.3rem; }
body.text-large .zoom-details h2 { font-size: 1.8rem; }

body.text-small .zoom-effect { font-size: 0.9rem; }
body.text-large .zoom-effect { font-size: 1.2rem; }

/* Colorblind Palettes */
body.colorblind-deuteranopia .aspect-glow,
body.colorblind-protanopia .aspect-glow { 
    background: #0077bb !important;
    color: #fff !important;
}

body.colorblind-deuteranopia .aspect-void,
body.colorblind-protanopia .aspect-void { 
    background: #ee7733 !important;
    color: #000 !important;
}

body.colorblind-tritanopia .aspect-glow { 
    background: #009988 !important;
    color: #fff !important;
}

body.colorblind-tritanopia .aspect-void { 
    background: #ee3377 !important;
    color: #fff !important;
}

body.colorblind-deuteranopia .game-card.glow .card-front,
body.colorblind-protanopia .game-card.glow .card-front {
    box-shadow: 0 0 15px rgba(0, 119, 187, 0.6);
}

body.colorblind-deuteranopia .game-card.void .card-front,
body.colorblind-protanopia .game-card.void .card-front {
    box-shadow: 0 0 15px rgba(238, 119, 51, 0.6);
}

/* Low-FX Mode */
body.low-fx * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
}

body.low-fx #game-container::before,
body.low-fx #particle-canvas,
body.low-fx .damage-number,
body.low-fx .essence-particle {
    display: none !important;
}

body.low-fx .game-card:hover {
    transform: none !important;
}

body.low-fx #game-board {
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
}

/* High Contrast Mode */
body.high-contrast {
    --void-black: #000;
}

body.high-contrast .game-card .card-front {
    border: 3px solid #fff;
}

body.high-contrast .game-card.legal-target {
    outline: 4px solid #00ff00;
}

body.high-contrast .overlay {
    background: rgba(0, 0, 0, 0.95);
}

body.high-contrast .queue-btn,
body.high-contrast .phase-btn,
body.high-contrast .panel-btn {
    border: 2px solid #fff;
}

/* Reduce Motion */
body.reduce-motion * {
    animation: none !important;
    transition: none !important;
}

/* ===== SANDBOX MODE ===== */
.sandbox-container {
    max-width: 900px;
    width: 95%;
    max-height: 90vh;
    overflow-y: auto;
    padding: 30px;
}

.sandbox-controls {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin: 20px 0;
}

.sandbox-section {
    background: rgba(20, 20, 40, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 20px;
}

.sandbox-section h3 {
    color: var(--gold);
    margin-bottom: 15px;
    font-size: 1rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.sandbox-player-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

.sandbox-player {
    background: rgba(30, 30, 60, 0.5);
    padding: 15px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.sandbox-player h4 {
    color: var(--essence-glow);
    margin-bottom: 10px;
}

.sandbox-stat {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}

.sandbox-stat label {
    min-width: 70px;
    color: rgba(255, 255, 255, 0.7);
}

.sandbox-stat input {
    width: 60px;
    padding: 6px 10px;
    background: rgba(20, 20, 40, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    color: #fff;
    font-size: 1rem;
    text-align: center;
}

.sandbox-stat span {
    color: rgba(255, 255, 255, 0.5);
}

.sandbox-btn {
    padding: 8px 16px;
    background: linear-gradient(135deg, rgba(34, 197, 94, 0.4), rgba(22, 163, 74, 0.5));
    border: 1px solid rgba(34, 197, 94, 0.5);
    border-radius: 6px;
    color: #fff;
    font-weight: 600;
    cursor: pointer;
    margin-right: 10px;
    margin-top: 10px;
    transition: all 0.2s ease;
}

.sandbox-btn:hover {
    background: linear-gradient(135deg, rgba(34, 197, 94, 0.6), rgba(22, 163, 74, 0.7));
}

.sandbox-btn.danger {
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.4), rgba(220, 38, 38, 0.5));
    border-color: rgba(239, 68, 68, 0.5);
}

.sandbox-btn.danger:hover {
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.6), rgba(220, 38, 38, 0.7));
}

.sandbox-add-card {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.sandbox-add-card select,
.sandbox-add-card input {
    padding: 8px 12px;
    background: rgba(20, 20, 40, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #fff;
    font-family: inherit;
}

.sandbox-add-card input {
    flex: 1;
    min-width: 200px;
}

.sandbox-card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
    max-height: 200px;
    overflow-y: auto;
    padding: 10px;
    background: rgba(10, 10, 20, 0.5);
    border-radius: 6px;
}

.sandbox-card-item {
    background: rgba(30, 30, 60, 0.6);
    padding: 8px;
    border-radius: 6px;
    text-align: center;
    cursor: pointer;
    border: 1px solid transparent;
    transition: all 0.2s ease;
    font-size: 0.75rem;
}

.sandbox-card-item:hover {
    background: rgba(50, 50, 100, 0.8);
    border-color: var(--gold);
}

.sandbox-card-item .card-name {
    color: #fff;
    font-weight: 600;
    margin-bottom: 3px;
}

.sandbox-card-item .card-type {
    color: rgba(255, 255, 255, 0.5);
    font-size: 0.65rem;
}

.sandbox-save-row {
    display: flex;
    gap: 10px;
}

.sandbox-save-row input {
    flex: 1;
    padding: 8px 12px;
    background: rgba(20, 20, 40, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #fff;
}

.sandbox-states-list {
    margin-top: 15px;
    max-height: 150px;
    overflow-y: auto;
}

.sandbox-state-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background: rgba(30, 30, 60, 0.5);
    border-radius: 6px;
    margin-bottom: 8px;
}

.sandbox-state-item .state-name {
    color: #fff;
    font-weight: 600;
}

.sandbox-state-item .state-date {
    color: rgba(255, 255, 255, 0.5);
    font-size: 0.8rem;
}

.sandbox-actions {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 20px;
}

/* ===== CUSTOM LOBBY ===== */
.lobby-container {
    max-width: 700px;
    width: 95%;
    max-height: 90vh;
    overflow-y: auto;
    padding: 30px;
}

.lobby-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}

.lobby-tab {
    flex: 1;
    padding: 12px 20px;
    background: rgba(30, 30, 60, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.7);
    font-family: inherit;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.lobby-tab.active {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.4), rgba(37, 99, 235, 0.5));
    border-color: rgba(59, 130, 246, 0.6);
    color: #fff;
}

.lobby-tab:hover:not(.active) {
    background: rgba(50, 50, 80, 0.6);
}

.lobby-tab-content {
    background: rgba(20, 20, 40, 0.6);
    border-radius: 10px;
    padding: 20px;
}

.lobby-tab-content.hidden {
    display: none;
}

.lobby-settings {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 20px;
}

.lobby-preset-row,
.lobby-setting-row {
    display: flex;
    align-items: center;
    gap: 15px;
}

.lobby-preset-row label,
.lobby-setting-row label {
    min-width: 140px;
    color: rgba(255, 255, 255, 0.8);
}

.lobby-preset-row select,
.lobby-setting-row select,
.lobby-setting-row input {
    flex: 1;
    padding: 10px 14px;
    background: rgba(20, 20, 40, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #fff;
    font-family: inherit;
    font-size: 0.95rem;
}

.lobby-setting-row input[type="number"] {
    max-width: 100px;
}

.lobby-checkboxes {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
}

.lobby-checkboxes label {
    display: flex;
    align-items: center;
    gap: 6px;
    color: rgba(255, 255, 255, 0.8);
    cursor: pointer;
    min-width: auto;
}

.lobby-checkboxes input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.lobby-list {
    max-height: 400px;
    overflow-y: auto;
}

.lobby-empty {
    text-align: center;
    color: rgba(255, 255, 255, 0.5);
    padding: 40px 20px;
}

.lobby-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    background: rgba(30, 30, 60, 0.5);
    border-radius: 8px;
    margin-bottom: 10px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.lobby-item:hover {
    background: rgba(40, 40, 80, 0.6);
    border-color: rgba(255, 255, 255, 0.2);
}

.lobby-item-info h4 {
    color: #fff;
    margin-bottom: 5px;
}

.lobby-item-info p {
    color: rgba(255, 255, 255, 0.5);
    font-size: 0.85rem;
}

.lobby-item-join {
    padding: 8px 20px;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.5), rgba(37, 99, 235, 0.6));
    border: none;
    border-radius: 6px;
    color: #fff;
    font-weight: 600;
    cursor: pointer;
}

.close-overlay-btn {
    margin-top: 20px;
    padding: 12px 30px;
    background: rgba(50, 50, 80, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: #fff;
    font-family: inherit;
    font-size: 1rem;
    cursor: pointer;
}

/* Lobby Waiting Room */
.lobby-waiting-container {
    max-width: 500px;
    width: 95%;
    text-align: center;
    padding: 40px;
}

.lobby-waiting-info {
    margin: 30px 0;
}

.lobby-rules-summary {
    background: rgba(20, 20, 40, 0.6);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    text-align: left;
}

.lobby-rules-summary p {
    margin: 8px 0;
    color: rgba(255, 255, 255, 0.8);
}

.lobby-rules-summary strong {
    color: var(--gold);
}

.lobby-players {
    background: rgba(20, 20, 40, 0.6);
    padding: 20px;
    border-radius: 10px;
}

.lobby-players h3 {
    color: var(--gold);
    margin-bottom: 15px;
}

#lobby-player-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.lobby-player-item {
    padding: 12px 20px;
    background: rgba(30, 30, 60, 0.5);
    border-radius: 6px;
    color: #fff;
}

.lobby-player-item.host::after {
    content: ' (Host)';
    color: var(--gold);
}

.lobby-waiting-actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 20px;
}

#lobby-start-btn:disabled {
    background: rgba(100, 100, 150, 0.3);
    cursor: not-allowed;
}

/* Welcome Screen */
.welcome-container {
    max-width: 700px;
    width: 95%;
    text-align: center;
    animation: slideUp 0.5s ease-out;
}

@keyframes slideUp {
    from { transform: translateY(50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

.welcome-content {
    background: linear-gradient(135deg, rgba(20, 10, 40, 0.95) 0%, rgba(10, 5, 30, 0.95) 100%);
    border: 2px solid rgba(212, 175, 55, 0.3);
    border-radius: 15px;
    padding: 40px;
    backdrop-filter: blur(10px);
}

.welcome-content h1 {
    font-family: 'Cinzel', serif;
    font-size: 2.5em;
    color: var(--gold);
    text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
    margin-bottom: 20px;
}

.welcome-content p {
    color: rgba(255, 255, 255, 0.8);
    font-size: 1.1em;
}

.welcome-info-box {
    background: rgba(30, 20, 50, 0.6);
    border-left: 4px solid var(--gold);
    padding: 20px;
    margin: 20px 0;
    text-align: left;
    border-radius: 8px;
}

.welcome-info-box h3 {
    color: var(--gold);
    font-size: 1.3em;
    margin-bottom: 15px;
    font-family: 'Cinzel', serif;
}

.welcome-info-box ul {
    list-style: none;
    color: rgba(255, 255, 255, 0.8);
}

.welcome-info-box li {
    margin: 10px 0;
    line-height: 1.5;
}

.welcome-buttons {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 30px;
}

.welcome-btn {
    padding: 15px 30px;
    border-radius: 8px;
    border: none;
    font-family: 'Cinzel', serif;
    font-size: 1em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
}

.welcome-btn:first-child {
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    color: #000;
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
}

.welcome-btn:first-child:hover {
    box-shadow: 0 0 40px rgba(212, 175, 55, 0.5);
    transform: translateY(-2px);
}

.welcome-btn.secondary {
    background: rgba(100, 100, 150, 0.3);
    border: 1px solid rgba(212, 175, 55, 0.5);
    color: var(--gold);
}

.welcome-btn.secondary:hover {
    background: rgba(100, 100, 150, 0.5);
}

/* Quick Play Button */
.fullscreen-btn.quick-play {
    display: block;
    margin-top: 15px;
    background: linear-gradient(135deg, var(--essence-glow) 0%, rgba(0, 255, 204, 0.6) 100%);
    color: #000;
}

.fullscreen-btn.quick-play:hover {
    box-shadow: 0 0 40px rgba(0, 255, 204, 0.6);
}

/* ===== CARD DETAIL MODAL ===== */
.card-detail-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    backdrop-filter: blur(4px);
}

.card-detail-modal.hidden {
    display: none;
}

.card-detail-content {
    background: linear-gradient(135deg, #2a1a3a 0%, #1a0a2a 100%);
    border: 2px solid var(--gold);
    border-radius: 16px;
    padding: 30px;
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.card-detail-close {
    position: absolute;
    top: 15px;
    right: 15px;
    background: rgba(255, 100, 100, 0.3);
    border: 1px solid rgba(255, 100, 100, 0.5);
    color: #ff6666;
    font-size: 28px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s;
}

.card-detail-close:hover {
    background: rgba(255, 100, 100, 0.6);
}

.card-detail-image {
    width: 100%;
    aspect-ratio: 3/4;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid rgba(212, 175, 55, 0.3);
}

.card-detail-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.card-detail-info h2 {
    font-family: 'Cinzel', serif;
    font-size: 28px;
    color: var(--gold);
    margin: 0;
    text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
}

.card-detail-meta {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.meta-badge {
    background: rgba(100, 80, 50, 0.6);
    border: 1px solid var(--gold);
    padding: 8px 15px;
    border-radius: 6px;
    font-size: 0.85em;
    color: var(--gold);
    font-weight: 600;
}

.meta-badge.cost {
    background: rgba(50, 150, 100, 0.4);
    border-color: #4ade80;
    color: #4ade80;
}

.card-detail-info .aspects {
    color: rgba(212, 175, 55, 0.8);
    font-size: 0.9em;
    margin: 0;
    font-style: italic;
}

.card-detail-info .stats {
    display: flex;
    gap: 20px;
}

.stat {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #fff;
}

.stat-label {
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.85em;
}

.card-detail-info .effect-text {
    background: rgba(30, 30, 50, 0.6);
    padding: 15px;
    border-radius: 8px;
    border-left: 3px solid var(--gold);
    color: rgba(255, 255, 255, 0.9);
    font-size: 0.95em;
    line-height: 1.5;
    margin: 0;
}

.card-detail-btn {
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    color: #000;
    border: none;
    padding: 14px 28px;
    border-radius: 8px;
    font-family: 'Cinzel', serif;
    font-size: 0.95em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.card-detail-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.4);
}

.card-detail-btn:active {
    transform: translateY(0);
}

/* ===== ENHANCED BATTLE EFFECTS CSS ===== */

/* Low Health Warning */
.low-health-pulse {
    animation: lowHealthPulse 0.5s ease-in-out infinite !important;
}

@keyframes lowHealthPulse {
    0%, 100% { 
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.8), inset 0 0 15px rgba(255, 0, 0, 0.3);
        border-color: #ff0000;
    }
    50% { 
        box-shadow: 0 0 40px rgba(255, 0, 0, 1), inset 0 0 25px rgba(255, 0, 0, 0.5);
        border-color: #ff4444;
    }
}

.low-health-vignette::after {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 9998;
    box-shadow: inset 0 0 200px rgba(255, 0, 0, 0.3);
    animation: vignetteFlash 1s ease-in-out infinite;
}

@keyframes vignetteFlash {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
}

/* Critical Moment Overlay */
.critical-moment-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10002;
    background: radial-gradient(circle, transparent 30%, rgba(0, 0, 0, 0.7) 100%);
    animation: criticalFlash 0.3s ease-out;
}

@keyframes criticalFlash {
    0% { background: rgba(255, 255, 255, 0.8); }
    100% { background: radial-gradient(circle, transparent 30%, rgba(0, 0, 0, 0.7) 100%); }
}

.critical-text {
    font-family: 'Cinzel', serif;
    font-size: 72px;
    font-weight: 900;
    color: #ff0000;
    text-shadow: 
        0 0 30px rgba(255, 0, 0, 0.8),
        0 0 60px rgba(255, 0, 0, 0.5),
        0 4px 0 #880000,
        0 6px 0 #660000;
    animation: criticalTextSlam 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    letter-spacing: 10px;
}

@keyframes criticalTextSlam {
    0% { transform: scale(3); opacity: 0; }
    60% { transform: scale(0.9); }
    100% { transform: scale(1); opacity: 1; }
}

/* Lethal Warning */
.lethal-warning {
    position: fixed;
    top: 15%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10001;
    animation: lethalSlide 0.5s ease-out;
}

@keyframes lethalSlide {
    0% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
    100% { transform: translateX(-50%) translateY(0); opacity: 1; }
}

.lethal-text {
    font-family: 'Cinzel', serif;
    font-size: 28px;
    font-weight: 700;
    color: #ff0000;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(50, 0, 0, 0.9));
    padding: 15px 40px;
    border: 3px solid #ff0000;
    border-radius: 8px;
    text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
    box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
    animation: lethalPulse 0.5s ease-in-out infinite alternate;
}

@keyframes lethalPulse {
    0% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.5); }
    100% { box-shadow: 0 0 50px rgba(255, 0, 0, 0.8); }
}

/* Card Drawing Animation */
.card-drawing {
    animation: cardDraw 0.3s ease-out;
}

@keyframes cardDraw {
    0% { transform: translateY(-50px) scale(0.8); opacity: 0; }
    50% { transform: translateY(-10px) scale(1.05); }
    100% { transform: translateY(0) scale(1); opacity: 1; }
}

/* Creature Destroying Animation */
.destroying {
    animation: creatureDestroy 0.6s ease-out forwards;
}

@keyframes creatureDestroy {
    0% { transform: scale(1); opacity: 1; filter: brightness(1); }
    30% { transform: scale(1.1); filter: brightness(2) saturate(0); }
    60% { transform: scale(1.2); opacity: 0.5; filter: brightness(3); }
    100% { transform: scale(0); opacity: 0; filter: brightness(0); }
}

/* Attack Lunge */
.attack-lunge {
    animation: attackLunge 0.4s ease-out;
}

@keyframes attackLunge {
    0% { transform: translateX(0); }
    30% { transform: translateX(-20px); }
    60% { transform: translateX(80px) scale(1.1); }
    100% { transform: translateX(0); }
}

/* Hit Impact */
.hit-impact {
    animation: hitImpact 0.4s ease-out;
}

@keyframes hitImpact {
    0% { transform: scale(1); filter: brightness(1); }
    20% { transform: scale(0.9); filter: brightness(3) saturate(0); }
    40% { transform: scale(1.1); filter: brightness(2) hue-rotate(20deg); }
    100% { transform: scale(1); filter: brightness(1); }
}

/* Direct Attack Charge */
.direct-attack-charge {
    animation: directCharge 0.3s ease-out;
}

@keyframes directCharge {
    0% { transform: scale(1); filter: drop-shadow(0 0 0 transparent); }
    50% { transform: scale(1.2); filter: drop-shadow(0 0 20px #ff0000); }
    100% { transform: scale(1); }
}

/* Essence Damage Pulse */
.essence-damage-pulse {
    animation: essencePulse 0.5s ease-out;
}

@keyframes essencePulse {
    0%, 100% { filter: none; }
    25% { filter: brightness(0.8) saturate(1.5) hue-rotate(-10deg); }
    50% { filter: brightness(1.2) saturate(2); }
    75% { filter: brightness(0.9); }
}

/* Summoning Animation */
.summoning {
    animation: summonPulse 0.4s ease-out;
    filter: brightness(2) saturate(0);
}

@keyframes summonPulse {
    0% { transform: scale(0) rotateY(180deg); opacity: 0; }
    50% { transform: scale(1.2) rotateY(90deg); }
    100% { transform: scale(1) rotateY(0); opacity: 1; }
}

.summoned {
    animation: summonGlow 0.5s ease-out;
}

@keyframes summonGlow {
    0% { filter: brightness(2) saturate(0); box-shadow: 0 0 50px rgba(0, 255, 204, 0.8); }
    100% { filter: brightness(1) saturate(1); box-shadow: none; }
}

/* Spell Casting */
.spell-casting {
    animation: spellCast 0.5s ease-out;
}

@keyframes spellCast {
    0% { filter: brightness(1); transform: scale(1); }
    50% { filter: brightness(2) hue-rotate(30deg); transform: scale(1.1); }
    100% { filter: brightness(1); transform: scale(1); }
}

/* Summon Portal */
.summon-portal {
    position: fixed;
    width: 150px;
    height: 150px;
    transform: translate(-50%, -50%);
    border: 4px solid #00ffcc;
    border-radius: 50%;
    animation: portalSpin 0.6s linear;
    z-index: 9999;
    pointer-events: none;
}

@keyframes portalSpin {
    0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2) rotate(180deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1) rotate(360deg); opacity: 1; }
}

.summon-portal.collapse {
    animation: portalCollapse 0.5s ease-in forwards;
}

@keyframes portalCollapse {
    to { transform: translate(-50%, -50%) scale(0); opacity: 0; }
}

.portal-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100%;
    height: 100%;
    border: 2px solid currentColor;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    animation: ringPulse 0.3s ease-out forwards;
    opacity: 0.5;
}

@keyframes ringPulse {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
}

/* Rune Circle */
.rune-circle {
    position: fixed;
    width: 200px;
    height: 200px;
    transform: translate(-50%, -50%);
    border: 3px solid #9333ea;
    border-radius: 50%;
    animation: runeRotate 1s linear;
    z-index: 9999;
    pointer-events: none;
    box-shadow: 0 0 30px rgba(147, 51, 234, 0.5), inset 0 0 30px rgba(147, 51, 234, 0.3);
}

@keyframes runeRotate {
    0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); opacity: 0; }
    30% { transform: translate(-50%, -50%) scale(1) rotate(120deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1.5) rotate(360deg); opacity: 0; }
}

/* Shockwave Ring */
.shockwave-ring {
    position: fixed;
    width: 20px;
    height: 20px;
    transform: translate(-50%, -50%);
    border: 3px solid rgba(255, 100, 0, 0.8);
    border-radius: 50%;
    animation: shockwaveExpand 0.6s ease-out forwards;
    z-index: 9999;
    pointer-events: none;
}

@keyframes shockwaveExpand {
    0% { width: 20px; height: 20px; opacity: 1; }
    100% { width: 300px; height: 300px; opacity: 0; border-width: 1px; }
}

/* Slash Mark */
.slash-mark {
    position: fixed;
    width: 100px;
    height: 100px;
    transform: translate(-50%, -50%);
    z-index: 9999;
    pointer-events: none;
}

.slash-line {
    position: absolute;
    width: 100%;
    height: 4px;
    background: linear-gradient(90deg, transparent, #ffffff, #ffaa00, #ff4444, transparent);
    top: 50%;
    left: 0;
    transform-origin: center;
    animation: slashAppear 0.3s ease-out;
    box-shadow: 0 0 15px rgba(255, 100, 0, 0.8);
}

.slash-line:first-child {
    transform: rotate(45deg);
}

.slash-line:last-child {
    transform: rotate(-45deg);
}

@keyframes slashAppear {
    0% { transform: rotate(45deg) scaleX(0); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: rotate(45deg) scaleX(1); opacity: 1; }
}

.slash-line:last-child {
    animation-name: slashAppear2;
}

@keyframes slashAppear2 {
    0% { transform: rotate(-45deg) scaleX(0); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: rotate(-45deg) scaleX(1); opacity: 1; }
}

.slash-mark.fade-out .slash-line {
    animation: slashFade 0.5s ease-out forwards;
}

@keyframes slashFade {
    to { opacity: 0; transform: scale(1.5); }
}

/* Profile Setup Card Styling */
.mode-card.profile-setup {
    background: linear-gradient(135deg, rgba(100, 200, 255, 0.2), rgba(50, 150, 200, 0.15));
    border: 2px solid rgba(100, 200, 255, 0.8);
    order: -1;
}

.mode-card.profile-setup:hover {
    background: linear-gradient(135deg, rgba(100, 200, 255, 0.35), rgba(50, 150, 200, 0.25));
    border-color: rgba(100, 200, 255, 1);
    box-shadow: 0 0 30px rgba(100, 200, 255, 0.4);
}

.mode-card.profile-setup .mode-icon {
    animation: profilePulse 2s infinite;
}

@keyframes profilePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
}

@keyframes pulse-glow {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

/* ===== COLLECTION SECTIONS ===== */
.collection-section {
    margin-bottom: 40px;
}

.section-title {
    font-family: 'Cinzel', serif;
    font-size: 1.3em;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 15px;
    border-bottom: 2px solid rgba(212, 175, 55, 0.3);
    padding-bottom: 10px;
}

.collection-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 15px;
}

.coll-card {
    position: relative;
    cursor: grab;
    transition: all 0.2s;
}

.coll-card:active {
    cursor: grabbing;
    opacity: 0.8;
}

.coll-card-hint {
    font-size: 0.6em;
    color: rgba(255, 255, 255, 0.4);
    text-align: center;
    margin-top: 3px;
}

/* ===== DECK BUILDER SECTIONS ===== */
.pool-section {
    margin-bottom: 25px;
}

.pool-section-title {
    font-family: 'Cinzel', serif;
    font-size: 1em;
    color: rgba(212, 175, 55, 0.8);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 10px;
    margin-left: 5px;
}

.pool-cards-group {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
    gap: 10px;
}

/* ===== BATTLE EFFECTS SYSTEM ===== */

/* Screen Flash */
.screen-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.1s ease-out;
}

/* Chromatic Aberration */
.chromatic-aberration {
    animation: chromatic 0.5s ease-out;
}

@keyframes chromatic {
    0%, 100% { filter: none; }
    25% { filter: drop-shadow(-3px 0 0 rgba(255, 0, 0, 0.5)) drop-shadow(3px 0 0 rgba(0, 255, 255, 0.5)); }
    50% { filter: drop-shadow(-5px 0 0 rgba(255, 0, 0, 0.7)) drop-shadow(5px 0 0 rgba(0, 255, 255, 0.7)); }
    75% { filter: drop-shadow(-3px 0 0 rgba(255, 0, 0, 0.5)) drop-shadow(3px 0 0 rgba(0, 255, 255, 0.5)); }
}

/* Slow Motion */
.slow-motion * {
    transition-duration: 2s !important;
    animation-duration: 2s !important;
}

/* Energy Beam */
.energy-beam {
    position: fixed;
    height: 8px;
    border-radius: 4px;
    pointer-events: none;
    z-index: 9998;
    transform-origin: left center;
    transition: opacity 0.2s;
}

/* Summon Portal */
.summon-portal {
    position: fixed;
    width: 150px;
    height: 150px;
    margin-left: -75px;
    margin-top: -75px;
    border: 4px solid;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9997;
    animation: portal-expand 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.summon-portal.collapse {
    animation: portal-collapse 0.5s ease-in forwards;
}

@keyframes portal-expand {
    0% { transform: scale(0) rotate(0deg); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: scale(1) rotate(180deg); opacity: 1; }
}

@keyframes portal-collapse {
    0% { transform: scale(1) rotate(180deg); opacity: 1; }
    100% { transform: scale(0) rotate(360deg); opacity: 0; }
}

.portal-ring {
    position: absolute;
    width: 100%;
    height: 100%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    animation: ring-pulse 0.6s ease-out infinite;
}

@keyframes ring-pulse {
    0% { transform: scale(0.8); opacity: 1; }
    100% { transform: scale(1.5); opacity: 0; }
}

/* Rune Circle */
.rune-circle {
    position: fixed;
    width: 200px;
    height: 200px;
    margin-left: -100px;
    margin-top: -100px;
    border: 3px solid;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9997;
    animation: rune-spin 1s linear infinite;
}

.rune-circle.fade-out {
    animation: rune-fade 0.5s ease-out forwards;
}

@keyframes rune-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

@keyframes rune-fade {
    to { transform: scale(2); opacity: 0; }
}

.rune-inner {
    position: absolute;
    top: 20%;
    left: 20%;
    width: 60%;
    height: 60%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    animation: rune-spin 0.5s linear infinite reverse;
}

.rune-symbols {
    position: absolute;
    width: 100%;
    text-align: center;
    top: 50%;
    transform: translateY(-50%);
    font-size: 16px;
    color: rgba(255, 255, 255, 0.8);
    letter-spacing: 8px;
    animation: symbols-pulse 0.5s ease-in-out infinite alternate;
}

@keyframes symbols-pulse {
    from { opacity: 0.5; text-shadow: 0 0 10px currentColor; }
    to { opacity: 1; text-shadow: 0 0 30px currentColor; }
}

/* Shockwave Ring */
.shockwave-ring {
    position: fixed;
    width: 20px;
    height: 20px;
    margin-left: -10px;
    margin-top: -10px;
    border: 4px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    pointer-events: none;
    z-index: 9996;
    animation: shockwave 0.6s ease-out forwards;
}

@keyframes shockwave {
    0% { transform: scale(1); opacity: 1; border-width: 4px; }
    100% { transform: scale(15); opacity: 0; border-width: 1px; }
}

/* Slash Marks */
.slash-mark {
    position: fixed;
    width: 100px;
    height: 100px;
    margin-left: -50px;
    margin-top: -50px;
    pointer-events: none;
    z-index: 9995;
}

.slash-mark.fade-out {
    animation: slash-fade 0.5s ease-out forwards;
}

.slash-line {
    position: absolute;
    width: 100%;
    height: 4px;
    background: linear-gradient(90deg, transparent, #ff4444, #ffaa00, #ff4444, transparent);
    top: 50%;
    box-shadow: 0 0 20px #ff4444, 0 0 40px #ff6600;
}

.slash-line:first-child {
    transform: rotate(45deg);
    animation: slash-appear 0.2s ease-out;
}

.slash-line:last-child {
    transform: rotate(-45deg);
    animation: slash-appear 0.2s ease-out 0.1s both;
}

@keyframes slash-appear {
    from { transform: rotate(45deg) scaleX(0); }
    to { transform: rotate(45deg) scaleX(1); }
}

@keyframes slash-fade {
    to { opacity: 0; transform: scale(1.5); }
}

/* Damage Numbers */
.damage-number {
    position: fixed;
    font-family: 'Cinzel', serif;
    font-size: 48px;
    font-weight: bold;
    pointer-events: none;
    z-index: 10001;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8),
                 0 0 20px currentColor,
                 0 0 40px currentColor;
    animation: damage-float-up 1.5s ease-out forwards;
    transform: translate(-50%, -50%);
}

.damage-number.damage {
    color: #ff4444;
}

.damage-number.heal {
    color: #00ff88;
}

@keyframes damage-float-up {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
    20% { transform: translate(-50%, -50%) scale(1.3); }
    40% { transform: translate(-50%, -80%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -150%) scale(0.8); }
}

/* Essence/KL Effects */
.essence-damage {
    animation: essence-damage-pulse 0.5s ease-out;
}

.essence-heal {
    animation: essence-heal-pulse 0.5s ease-out;
}

@keyframes essence-damage-pulse {
    0%, 100% { color: inherit; text-shadow: none; }
    50% { color: #ff4444; text-shadow: 0 0 20px #ff4444, 0 0 40px #ff0000; transform: scale(1.3); }
}

@keyframes essence-heal-pulse {
    0%, 100% { color: inherit; text-shadow: none; }
    50% { color: #00ff88; text-shadow: 0 0 20px #00ff88, 0 0 40px #00ffcc; transform: scale(1.3); }
}

.kl-spend {
    animation: kl-drain 0.3s ease-out;
}

@keyframes kl-drain {
    0% { filter: brightness(1); }
    50% { filter: brightness(2) drop-shadow(0 0 10px #ffaa00); }
    100% { filter: brightness(1); }
}

body.essence-damage-pulse::after {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    background: radial-gradient(circle at center, transparent 30%, rgba(255, 0, 0, 0.3) 100%);
    z-index: 9990;
    animation: essence-vignette 0.5s ease-out forwards;
}

@keyframes essence-vignette {
    0% { opacity: 0; }
    50% { opacity: 1; }
    100% { opacity: 0; }
}

/* Phase Transition */
.phase-transition-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.7);
    z-index: 10002;
    animation: phase-fade-in 0.3s ease-out;
}

.phase-transition-overlay.fade-out {
    animation: phase-fade-out 0.5s ease-out forwards;
}

@keyframes phase-fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes phase-fade-out {
    from { opacity: 1; }
    to { opacity: 0; }
}

.phase-transition-content {
    display: flex;
    align-items: center;
    gap: 30px;
}

.phase-transition-line {
    width: 200px;
    height: 3px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
    animation: line-extend 0.5s ease-out;
}

.phase-transition-line.left {
    transform-origin: right;
}

.phase-transition-line.right {
    transform-origin: left;
}

@keyframes line-extend {
    from { transform: scaleX(0); }
    to { transform: scaleX(1); }
}

.phase-transition-text {
    font-family: 'Cinzel', serif;
    font-size: 48px;
    font-weight: bold;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 8px;
    text-shadow: 0 0 30px var(--gold), 0 0 60px var(--gold);
    animation: phase-text-appear 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes phase-text-appear {
    0% { opacity: 0; transform: scale(0.5); }
    100% { opacity: 1; transform: scale(1); }
}

/* Turn Banner */
.turn-banner {
    position: fixed;
    top: 50%;
    left: 0;
    width: 100%;
    transform: translateY(-50%);
    z-index: 10003;
    pointer-events: none;
    animation: banner-slide-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.turn-banner.exit {
    animation: banner-slide-out 0.5s ease-in forwards;
}

@keyframes banner-slide-in {
    from { transform: translateY(-50%) translateX(-100%); }
    to { transform: translateY(-50%) translateX(0); }
}

@keyframes banner-slide-out {
    from { transform: translateY(-50%) translateX(0); }
    to { transform: translateY(-50%) translateX(100%); }
}

.turn-banner-content {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
    padding: 30px 50px;
    background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.9) 20%, rgba(0, 0, 0, 0.9) 80%, transparent);
}

.turn-banner.your-turn .turn-banner-content {
    border-top: 3px solid var(--glow);
    border-bottom: 3px solid var(--glow);
    box-shadow: 0 0 50px rgba(0, 255, 204, 0.3);
}

.turn-banner.opponent-turn .turn-banner-content {
    border-top: 3px solid var(--void);
    border-bottom: 3px solid var(--void);
    box-shadow: 0 0 50px rgba(147, 51, 234, 0.3);
}

.turn-banner-icon {
    font-size: 48px;
}

.turn-banner-text {
    font-family: 'Cinzel', serif;
    font-size: 36px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 8px;
}

.turn-banner.your-turn .turn-banner-text {
    color: var(--glow);
    text-shadow: 0 0 30px var(--glow);
}

.turn-banner.opponent-turn .turn-banner-text {
    color: var(--void);
    text-shadow: 0 0 30px var(--void);
}

/* God Code Activation */
.god-code-activation {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 400px;
    height: 400px;
    margin-left: -200px;
    margin-top: -200px;
    border: 5px solid var(--gold);
    border-radius: 50%;
    z-index: 10004;
    animation: god-code-expand 1.5s ease-out;
    box-shadow: 0 0 100px var(--gold), inset 0 0 100px rgba(212, 175, 55, 0.3);
}

.god-code-activation.fade-out {
    animation: god-code-fade 0.5s ease-out forwards;
}

@keyframes god-code-expand {
    0% { transform: scale(0) rotate(0deg); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: scale(1) rotate(360deg); opacity: 1; }
}

@keyframes god-code-fade {
    to { transform: scale(2); opacity: 0; }
}

/* Deity Ability Display */
.deity-ability-display {
    position: fixed;
    font-family: 'Cinzel', serif;
    font-size: 28px;
    font-weight: bold;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 4px;
    text-shadow: 0 0 30px var(--gold), 0 0 60px var(--gold);
    transform: translateX(-50%);
    z-index: 10005;
    animation: ability-appear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    white-space: nowrap;
}

.deity-ability-display.fade-out {
    animation: ability-fade 0.5s ease-out forwards;
}

@keyframes ability-appear {
    0% { opacity: 0; transform: translateX(-50%) translateY(20px) scale(0.8); }
    100% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
}

@keyframes ability-fade {
    to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
}

/* Defeat Effect */
body.defeat-effect {
    filter: grayscale(0.7) brightness(0.6);
    transition: filter 0.5s ease-out;
}

.screen-cracks {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10006;
    opacity: 0;
    animation: cracks-appear 0.3s ease-out forwards;
}

.screen-cracks svg {
    width: 100%;
    height: 100%;
}

@keyframes cracks-appear {
    from { opacity: 0; }
    to { opacity: 0.8; }
}

/* Card Summoning Animation */
.summoning {
    animation: card-summon 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    z-index: 100;
}

@keyframes card-summon {
    0% { transform: scale(0) rotateY(180deg); opacity: 0; filter: brightness(3); }
    50% { transform: scale(1.2) rotateY(90deg); opacity: 1; filter: brightness(2); }
    100% { transform: scale(1) rotateY(0deg); opacity: 1; filter: brightness(1); }
}

.summoned {
    animation: summoned-pulse 0.5s ease-out;
}

@keyframes summoned-pulse {
    0% { box-shadow: 0 0 30px var(--gold); }
    100% { box-shadow: none; }
}

/* Spell Casting */
.spell-casting {
    animation: spell-channel 0.6s ease-out;
}

@keyframes spell-channel {
    0% { filter: brightness(1) saturate(1); }
    50% { filter: brightness(2) saturate(2); transform: scale(1.1); }
    100% { filter: brightness(1) saturate(1); transform: scale(1); }
}

/* Attack Animations */
.attack-lunge {
    animation: lunge-attack 0.5s ease-out;
}

@keyframes lunge-attack {
    0% { transform: translateY(0) scale(1); }
    30% { transform: translateY(-30px) scale(1.1); }
    60% { transform: translateY(-50px) scale(1.15); filter: brightness(1.5); }
    100% { transform: translateY(0) scale(1); }
}

.direct-attack-charge {
    animation: charge-up 0.3s ease-out;
}

@keyframes charge-up {
    0% { filter: brightness(1); box-shadow: none; }
    100% { filter: brightness(1.5); box-shadow: 0 0 40px #ff4444, 0 0 80px #ff0000; }
}

/* Hit Impact */
.hit-impact {
    animation: impact-shake 0.4s ease-out;
}

@keyframes impact-shake {
    0%, 100% { transform: translateX(0) rotate(0deg); }
    20% { transform: translateX(-10px) rotate(-5deg); }
    40% { transform: translateX(10px) rotate(5deg); }
    60% { transform: translateX(-5px) rotate(-3deg); }
    80% { transform: translateX(5px) rotate(3deg); }
}

/* Card Destruction */
.destroying {
    animation: card-destroy 0.5s ease-out forwards;
}

@keyframes card-destroy {
    0% { transform: scale(1); opacity: 1; filter: brightness(1); }
    30% { transform: scale(1.1); filter: brightness(2) saturate(0); }
    100% { transform: scale(0) rotate(180deg); opacity: 0; }
}

/* ===== RANK UP NOTIFICATION ===== */
.rank-up-notification {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20000;
    background: rgba(0, 0, 0, 0.85);
    animation: fade-in 0.5s ease-out;
}

.rank-up-content {
    position: relative;
    background: linear-gradient(135deg, #1a0533 0%, #3b0764 50%, #1a0533 100%);
    border: 3px solid var(--gold);
    border-radius: 20px;
    padding: 50px 80px;
    text-align: center;
    box-shadow: 
        0 0 60px rgba(212, 175, 55, 0.6),
        0 0 120px rgba(107, 33, 168, 0.4),
        inset 0 0 40px rgba(212, 175, 55, 0.1);
    animation: rank-up-appear 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.rank-up-glow {
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(212, 175, 55, 0.3) 0%, transparent 50%);
    animation: rank-glow-pulse 2s ease-in-out infinite;
    pointer-events: none;
}

@keyframes rank-glow-pulse {
    0%, 100% { opacity: 0.5; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.1); }
}

.rank-up-content h2 {
    font-family: 'Cinzel', serif;
    font-size: 3rem;
    color: var(--gold);
    text-shadow: 0 0 30px var(--gold), 0 0 60px var(--gold);
    margin-bottom: 20px;
    animation: rank-text-glow 1.5s ease-in-out infinite;
}

@keyframes rank-text-glow {
    0%, 100% { text-shadow: 0 0 20px var(--gold), 0 0 40px var(--gold); }
    50% { text-shadow: 0 0 40px var(--gold), 0 0 80px var(--gold-light); }
}

.new-rank {
    font-family: 'Cinzel', serif;
    font-size: 2.5rem;
    font-weight: 700;
    color: white;
    background: linear-gradient(135deg, var(--gold-light), var(--gold), var(--gold-dark));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 30px;
    padding: 10px 30px;
    border: 2px solid var(--gold);
    border-radius: 10px;
    display: inline-block;
}

.rank-rewards {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 30px;
}

.reward-item {
    font-family: 'Rajdhani', sans-serif;
    font-size: 1.3rem;
    color: #00ffcc;
    padding: 10px 20px;
    background: rgba(0, 255, 204, 0.1);
    border: 1px solid rgba(0, 255, 204, 0.3);
    border-radius: 8px;
    animation: reward-pop 0.5s ease-out backwards;
}

.reward-item:nth-child(1) { animation-delay: 0.2s; }
.reward-item:nth-child(2) { animation-delay: 0.4s; }
.reward-item:nth-child(3) { animation-delay: 0.6s; }

@keyframes reward-pop {
    from { opacity: 0; transform: scale(0.5) translateY(20px); }
    to { opacity: 1; transform: scale(1) translateY(0); }
}

.rank-up-content button {
    font-family: 'Rajdhani', sans-serif;
    font-size: 1.2rem;
    font-weight: 600;
    padding: 15px 50px;
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    border: none;
    border-radius: 10px;
    color: #1a0533;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.rank-up-content button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 30px var(--gold);
}

@keyframes rank-up-appear {
    from { opacity: 0; transform: scale(0.3) rotateY(90deg); }
    to { opacity: 1; transform: scale(1) rotateY(0deg); }
}

/* ===== SHOP/COSMETICS ENHANCEMENT ===== */
.mode-card.shop {
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.2) 0%, rgba(107, 33, 168, 0.3) 100%);
    border: 2px solid var(--gold);
}

.mode-card.shop:hover {
    border-color: var(--gold-light);
    box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
}

.cosmetics-container {
    background: linear-gradient(135deg, rgba(26, 5, 51, 0.98) 0%, rgba(59, 7, 100, 0.98) 100%);
}

.cosmetics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 20px;
    padding: 20px;
    max-height: 60vh;
    overflow-y: auto;
}

.cosmetic-item {
    position: relative;
    background: 
        linear-gradient(135deg, rgba(25, 18, 42, 0.95) 0%, rgba(18, 12, 32, 0.98) 100%);
    border: 2px solid rgba(212, 175, 55, 0.35);
    border-radius: 12px;
    padding: 20px;
    text-align: center;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: pointer;
    box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.cosmetic-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.cosmetic-item:hover {
    border-color: var(--gold);
    transform: translateY(-8px);
    box-shadow: 
        0 15px 40px rgba(0, 0, 0, 0.5),
        0 0 30px rgba(212, 175, 55, 0.25);
}

.cosmetic-item:hover::before {
    opacity: 1;
}

.cosmetic-item.owned {
    border-color: var(--essence-glow);
    background: 
        linear-gradient(135deg, rgba(0, 255, 204, 0.08) 0%, rgba(18, 12, 32, 0.98) 100%);
}

.cosmetic-item.equipped {
    border-color: var(--gold);
    box-shadow: 
        0 0 25px rgba(212, 175, 55, 0.4),
        inset 0 0 30px rgba(212, 175, 55, 0.1);
}

.cosmetic-preview {
    width: 90px;
    height: 90px;
    margin: 0 auto 15px;
    background: 
        linear-gradient(135deg, rgba(139, 92, 246, 0.3) 0%, rgba(107, 33, 168, 0.4) 100%);
    border: 2px solid rgba(139, 92, 246, 0.4);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.5rem;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
}

.cosmetic-name {
    font-family: 'Rajdhani', sans-serif;
    font-size: 1.1rem;
    font-weight: 600;
    color: white;
    margin-bottom: 5px;
}

.cosmetic-rarity {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.cosmetic-rarity.common { color: #888; }
.cosmetic-rarity.rare { color: #00aaff; }
.cosmetic-rarity.epic { color: #aa00ff; }
.cosmetic-rarity.legendary { color: var(--gold); }
.cosmetic-rarity.mythic { color: #ff4444; text-shadow: 0 0 10px #ff4444; }

.cosmetic-price {
    margin-top: 10px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 1.1rem;
    color: var(--gold);
}

.cosmetic-btn {
    margin-top: 10px;
    padding: 8px 20px;
    border: none;
    border-radius: 5px;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.cosmetic-btn.buy {
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    color: #1a0533;
}

.cosmetic-btn.equip {
    background: linear-gradient(135deg, #00ffcc, #00aa88);
    color: #1a0533;
}

.cosmetic-btn.equipped {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    cursor: default;
}

.cosmetic-btn:hover:not(.equipped) {
    transform: scale(1.05);
}

/* ===== ENHANCED GAMEBOARD VISUALS ===== */
#game-board {
    background: radial-gradient(ellipse at center, rgba(50, 20, 80, 0.9) 0%, rgba(10, 5, 30, 0.95) 100%);
    box-shadow: inset 0 0 100px rgba(100, 50, 150, 0.4), 0 0 150px rgba(150, 100, 200, 0.3);
    border: 3px solid rgba(100, 50, 200, 0.6);
}
.player-zone {
    box-shadow: inset 0 0 40px rgba(100, 50, 150, 0.3), 0 0 40px rgba(100, 50, 150, 0.2);
    border: 2px solid rgba(100, 50, 200, 0.4);
    animation: zone-pulse 3s ease-in-out infinite;
}
@keyframes zone-pulse { 0%, 100% { box-shadow: inset 0 0 40px rgba(100, 50, 150, 0.3), 0 0 40px rgba(100, 50, 150, 0.2); } 50% { box-shadow: inset 0 0 60px rgba(100, 50, 150, 0.5), 0 0 60px rgba(100, 50, 150, 0.4); } }
.board-row { box-shadow: inset 0 0 20px rgba(100, 50, 200, 0.2), 0 0 20px rgba(100, 50, 200, 0.1); }
.card-slot:hover { box-shadow: inset 0 0 30px rgba(100, 50, 200, 0.3), 0 0 20px rgba(100, 50, 200, 0.2); border-color: rgba(150, 100, 250, 0.6); }

/* ===== PROFILE VIEWER ===== */
.player-profile.clickable { cursor: pointer; transition: all 0.3s ease; }
.player-profile.clickable:hover { transform: scale(1.05); }
.click-hint { font-size: 0.8rem; color: rgba(212, 175, 55, 0.7); margin-top: 5px; }
.profile-modal {
    width: 90vw; max-width: 900px; max-height: 85vh;
    background: linear-gradient(135deg, #1a0533 0%, #3b0764 50%, #1a0533 100%);
    border: 3px solid var(--gold); border-radius: 20px; padding: 30px;
    box-shadow: 0 0 60px rgba(212, 175, 55, 0.5);
    display: flex; flex-direction: column; overflow-y: auto;
}
.profile-header { margin-bottom: 30px; padding-bottom: 20px; border-bottom: 2px solid rgba(212, 175, 55, 0.3); }
.profile-avatar-section { display: flex; gap: 30px; align-items: center; }
.profile-avatar {
    width: 120px; height: 120px;
    background: linear-gradient(135deg, var(--purple), var(--purple-dark));
    border: 3px solid var(--gold); border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 4rem; box-shadow: 0 0 40px rgba(212, 175, 55, 0.4);
}
.profile-info h1 { font-family: 'Cinzel', serif; color: var(--gold); font-size: 2.2rem; margin-bottom: 10px; }
.profile-tier { display: flex; gap: 20px; font-size: 1.2rem; color: #00ffcc; }
.profile-tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid rgba(212, 175, 55, 0.2); }
.profile-tab {
    padding: 12px 25px; background: rgba(100, 100, 200, 0.2);
    border: 1px solid rgba(100, 100, 200, 0.3); border-radius: 8px 8px 0 0;
    color: rgba(255, 255, 255, 0.7); cursor: pointer; transition: all 0.2s ease; font-weight: 600;
}
.profile-tab.active { background: linear-gradient(135deg, rgba(212, 175, 55, 0.3), rgba(100, 100, 200, 0.3)); border-color: var(--gold); color: var(--gold); }
.profile-tab-content { display: none; }
.profile-tab-content.active { display: block; }
.stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin-bottom: 30px; }
.stat-box { background: rgba(100, 50, 150, 0.2); border: 2px solid rgba(212, 175, 55, 0.3); border-radius: 12px; padding: 20px; text-align: center; }
.stat-label { font-size: 0.9rem; color: rgba(255, 255, 255, 0.6); text-transform: uppercase; letter-spacing: 1px; }
.stat-value { font-family: 'Cinzel', serif; font-size: 2rem; font-weight: 700; color: var(--gold); text-shadow: 0 0 20px rgba(212, 175, 55, 0.4); }
.match-entry { background: rgba(50, 25, 100, 0.3); border: 1px solid rgba(100, 100, 200, 0.2); border-radius: 8px; padding: 12px; font-size: 0.95rem; color: rgba(255, 255, 255, 0.8); }
.match-entry.win { border-left: 4px solid #00ff00; background: rgba(0, 255, 0, 0.05); }
.match-entry.loss { border-left: 4px solid #ff4444; background: rgba(255, 68, 68, 0.05); }
.owned-cosmetics-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; }
.cosmetic-preview-mini {
    background: linear-gradient(135deg, var(--purple), var(--purple-dark));
    border: 2px solid rgba(212, 175, 55, 0.3); border-radius: 10px; padding: 15px;
    text-align: center; cursor: pointer; transition: all 0.2s ease;
}
.cosmetic-preview-mini:hover { border-color: var(--gold); transform: scale(1.05); box-shadow: 0 0 20px rgba(212, 175, 55, 0.3); }
.cosmetic-preview-mini-icon { font-size: 2.5rem; margin-bottom: 8px; }
.cosmetic-preview-mini-name { font-size: 0.8rem; color: rgba(255, 255, 255, 0.8); }

.boss-dialogue-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10002;
    animation: fadeIn 0.3s ease-out;
}

.boss-dialogue-overlay.fade-out {
    animation: fadeOut 0.3s ease-out forwards;
}

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

.boss-dialogue-container {
    background: linear-gradient(135deg, #1a0533 0%, #3b0764 50%, #1a0533 100%);
    border: 4px solid var(--gold);
    border-radius: 25px;
    padding: 50px 60px;
    text-align: center;
    max-width: 600px;
    box-shadow: 0 0 100px rgba(100, 50, 150, 0.8), 0 0 200px rgba(212, 175, 55, 0.3);
}

.boss-portrait-large {
    font-size: 120px;
    margin-bottom: 20px;
    filter: drop-shadow(0 0 30px rgba(212, 175, 55, 0.8));
    animation: bossFloat 3s ease-in-out infinite;
}

@keyframes bossFloat {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-15px); }
}

.boss-dialogue-name {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 2.5rem;
    margin-bottom: 15px;
    text-shadow: 0 0 20px rgba(212, 175, 55, 0.7);
}

.boss-ability-badge {
    background: rgba(212, 175, 55, 0.15);
    border: 2px solid var(--gold);
    border-radius: 20px;
    padding: 10px 20px;
    margin-bottom: 25px;
    color: var(--gold);
    font-size: 0.95rem;
}

.boss-dialogue-text {
    color: rgba(255, 255, 255, 0.95);
    font-size: 1.4rem;
    line-height: 1.6;
    min-height: 60px;
    font-style: italic;
}

.dialogue-animate { animation: textPop 0.3s ease-out; }
@keyframes textPop { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

.boss-dialogue-btn {
    background: linear-gradient(135deg, var(--gold), #b8860b);
    border: none;
    border-radius: 12px;
    padding: 15px 40px;
    color: #1a0533;
    font-weight: 700;
    font-size: 1.1rem;
    cursor: pointer;
    margin-top: 25px;
    transition: all 0.2s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.boss-dialogue-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
}

.boss-quick-dialogue {
    position: fixed;
    top: 100px;
    right: 30px;
    background: linear-gradient(135deg, #2d0a4e 0%, #4a1a7a 100%);
    border: 3px solid var(--gold);
    border-radius: 20px;
    padding: 20px 25px;
    display: flex;
    align-items: center;
    gap: 15px;
    z-index: 9500;
    max-width: 400px;
    transform: translateX(120%);
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow: 0 0 40px rgba(100, 50, 150, 0.6);
}

.boss-quick-dialogue.show { transform: translateX(0); }

.boss-quick-portrait {
    font-size: 50px;
    filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.6));
}

.boss-quick-text {
    color: rgba(255, 255, 255, 0.95);
    font-size: 1.1rem;
    font-style: italic;
}

.boss-victory-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10003;
    animation: victoryFadeIn 0.5s ease-out;
}

@keyframes victoryFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.boss-victory-container {
    background: linear-gradient(135deg, #1a0533 0%, #2d0a4e 30%, #4a1a7a 70%, #1a0533 100%);
    border: 5px solid var(--gold);
    border-radius: 30px;
    padding: 50px 70px;
    text-align: center;
    max-width: 650px;
    box-shadow: 0 0 150px rgba(212, 175, 55, 0.5), 0 0 300px rgba(100, 50, 150, 0.4);
    animation: victoryPulse 2s ease-in-out infinite;
}

@keyframes victoryPulse {
    0%, 100% { box-shadow: 0 0 150px rgba(212, 175, 55, 0.5), 0 0 300px rgba(100, 50, 150, 0.4); }
    50% { box-shadow: 0 0 200px rgba(212, 175, 55, 0.7), 0 0 400px rgba(100, 50, 150, 0.6); }
}

.victory-portrait {
    font-size: 100px;
    margin-bottom: 20px;
    opacity: 0.7;
    filter: grayscale(0.5) drop-shadow(0 0 20px rgba(128, 128, 128, 0.5));
}

.boss-victory-container h2 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    font-size: 3.5rem;
    margin-bottom: 10px;
    text-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
    animation: victoryText 1s ease-out;
}

@keyframes victoryText {
    from { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.2); }
    to { transform: scale(1); opacity: 1; }
}

.boss-victory-container h3 {
    color: rgba(255, 255, 255, 0.8);
    font-size: 1.5rem;
    margin-bottom: 25px;
}

.defeat-dialogue {
    color: rgba(255, 255, 255, 0.7);
    font-style: italic;
    font-size: 1.2rem;
    margin-bottom: 25px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
}

.story-text {
    color: var(--gold);
    font-size: 1.1rem;
    line-height: 1.8;
    margin-bottom: 25px;
    padding: 20px;
    background: rgba(212, 175, 55, 0.1);
    border: 2px solid rgba(212, 175, 55, 0.3);
    border-radius: 15px;
    white-space: pre-line;
}

.victory-rewards {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 25px;
}

.victory-rewards .reward-item {
    background: rgba(212, 175, 55, 0.2);
    border: 2px solid var(--gold);
    border-radius: 15px;
    padding: 15px 25px;
    color: var(--gold);
    font-size: 1.3rem;
    font-weight: 600;
}

.victory-btn {
    background: linear-gradient(135deg, var(--gold), #b8860b);
    border: none;
    border-radius: 15px;
    padding: 18px 50px;
    color: #1a0533;
    font-weight: 700;
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.victory-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 50px rgba(212, 175, 55, 0.8);
}

.chapter-portrait {
    font-size: 50px;
    margin-bottom: 10px;
}

.boss-ability-preview {
    background: rgba(100, 50, 150, 0.3);
    border: 1px solid rgba(100, 50, 150, 0.6);
    border-radius: 10px;
    padding: 5px 10px;
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.8);
    margin: 10px 0;
}

/* ========================================
   PREMIUM TCG VISUAL UPGRADE
   ======================================== */

/* === 1. AVATAR MANIFEST ANIMATION === */
.ec-anim-manifest {
    animation: ec-manifest-slot 0.5s ease-out forwards;
}

.ec-anim-manifest-card {
    animation: ec-manifest-card 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.ec-anim-manifest-complete .game-card {
    box-shadow: 0 0 30px var(--ec-amethyst), 0 0 60px rgba(124, 58, 237, 0.4);
    animation: ec-manifest-pulse 0.6s ease-out;
}

@keyframes ec-manifest-slot {
    0% { background: rgba(124, 58, 237, 0.3); box-shadow: inset 0 0 40px var(--ec-amethyst); }
    50% { background: rgba(246, 196, 83, 0.2); box-shadow: inset 0 0 60px var(--ec-gold); }
    100% { background: transparent; box-shadow: none; }
}

@keyframes ec-manifest-card {
    0% { opacity: 0; transform: scale(0.3) translateY(100px); }
    50% { opacity: 1; transform: scale(1.15) translateY(-10px); }
    100% { opacity: 1; transform: scale(1) translateY(0); }
}

@keyframes ec-manifest-pulse {
    0% { box-shadow: 0 0 30px var(--ec-amethyst), 0 0 60px rgba(124, 58, 237, 0.6); }
    50% { box-shadow: 0 0 50px var(--ec-gold), 0 0 100px rgba(246, 196, 83, 0.5); }
    100% { box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); }
}

/* === 2. ASPECT / RELIC IMPACT ANIMATION === */
.ec-anim-aspect-impact {
    animation: ec-aspect-impact 0.4s ease-out;
}

@keyframes ec-aspect-impact {
    0% { box-shadow: 0 0 0 rgba(124, 58, 237, 0); border-color: var(--ec-border); }
    30% { box-shadow: 0 0 40px var(--ec-amethyst), 0 0 80px rgba(124, 58, 237, 0.5); border-color: var(--ec-amethyst); }
    100% { box-shadow: 0 0 0 rgba(124, 58, 237, 0); border-color: var(--ec-border); }
}

/* === 3. ESSENCE DAMAGE FLOATER === */
.ec-damage-floater {
    position: fixed;
    font-family: 'Cinzel', serif;
    font-size: 1.8rem;
    font-weight: 700;
    pointer-events: none;
    z-index: 10005;
    transform: translateX(-50%);
    opacity: 0;
    text-shadow: 0 0 10px currentColor, 0 2px 4px rgba(0, 0, 0, 0.8);
    transition: all 1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.ec-damage-floater.damage {
    color: var(--damage-red);
}

.ec-damage-floater.heal {
    color: var(--essence-glow);
}

.ec-damage-floater.animate {
    opacity: 1;
    transform: translateX(-50%) translateY(-60px);
}

/* === 4. SHARD CLAIM ANIMATION === */
.ec-anim-shard-claim {
    animation: ec-shard-claim 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes ec-shard-claim {
    0% { transform: scale(1); box-shadow: 0 0 0 rgba(246, 196, 83, 0); }
    30% { transform: scale(1.4); box-shadow: 0 0 40px var(--ec-gold), 0 0 80px rgba(246, 196, 83, 0.6); }
    60% { transform: scale(1.2); }
    100% { transform: scale(0.8); opacity: 0.5; }
}

.ec-shard--claimed {
    opacity: 0.3;
    filter: grayscale(0.8);
    transform: scale(0.85);
}

/* === 5. CROWN VICTORY / DEFEAT OVERLAY === */
.ec-crown-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10010;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.ec-crown-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.ec-crown-overlay.victory {
    background: radial-gradient(ellipse at center, rgba(246, 196, 83, 0.3) 0%, rgba(5, 0, 18, 0.95) 70%);
}

.ec-crown-overlay.defeat {
    background: radial-gradient(ellipse at center, rgba(255, 68, 68, 0.2) 0%, rgba(5, 0, 18, 0.95) 70%);
}

.ec-crown-title {
    font-family: 'Cinzel', serif;
    font-size: 4rem;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 8px;
    text-align: center;
    animation: ec-crown-appear 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.ec-crown-overlay.victory .ec-crown-title {
    color: var(--ec-gold);
    text-shadow: 0 0 30px var(--ec-gold), 0 0 60px rgba(246, 196, 83, 0.6), 0 4px 8px rgba(0, 0, 0, 0.8);
}

.ec-crown-overlay.defeat .ec-crown-title {
    color: var(--damage-red);
    text-shadow: 0 0 30px var(--damage-red), 0 0 60px rgba(255, 68, 68, 0.5), 0 4px 8px rgba(0, 0, 0, 0.8);
}

@keyframes ec-crown-appear {
    0% { opacity: 0; transform: scale(0.5); }
    50% { transform: scale(1.1); }
    100% { opacity: 1; transform: scale(1); }
}

/* === 6. REACTION BAR === */
.ec-reaction-bar {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    background: linear-gradient(180deg, rgba(12, 5, 25, 0.98) 0%, rgba(20, 10, 35, 0.95) 100%);
    border: 2px solid var(--ec-teal);
    border-radius: 16px;
    padding: 16px 24px;
    display: flex;
    align-items: center;
    gap: 20px;
    z-index: 9998;
    opacity: 0;
    pointer-events: none;
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow: 0 0 40px rgba(20, 244, 255, 0.3), 0 10px 40px rgba(0, 0, 0, 0.5);
}

.ec-reaction-bar.visible {
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) translateY(0);
}

.ec-reaction-prompt {
    font-family: 'Rajdhani', sans-serif;
    font-size: 1rem;
    font-weight: 600;
    color: var(--ec-teal);
    white-space: nowrap;
}

.ec-reaction-cards {
    display: flex;
    gap: 8px;
}

.ec-reaction-card-btn {
    background: rgba(20, 244, 255, 0.1);
    border: 1px solid rgba(20, 244, 255, 0.4);
    border-radius: 8px;
    padding: 8px 14px;
    color: #fff;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.ec-reaction-card-btn:hover {
    background: rgba(20, 244, 255, 0.25);
    border-color: var(--ec-teal);
    transform: translateY(-2px);
}

.ec-reaction-actions {
    display: flex;
    gap: 10px;
}

.ec-reaction-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.ec-reaction-btn--respond {
    background: linear-gradient(135deg, var(--ec-teal), #0ea5e9);
    color: #050012;
}

.ec-reaction-btn--pass {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: rgba(255, 255, 255, 0.8);
}

.ec-reaction-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(20, 244, 255, 0.3);
}

.ec-reaction-autopass {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.6);
    border-left: 1px solid rgba(255, 255, 255, 0.2);
    padding-left: 15px;
    margin-left: 5px;
}

.ec-reaction-autopass input {
    accent-color: var(--ec-teal);
}

.ec-reaction-candidate {
    animation: ec-candidate-pulse 0.6s ease-in-out infinite;
    box-shadow: 0 0 20px var(--ec-teal) !important;
}

@keyframes ec-candidate-pulse {
    0%, 100% { box-shadow: 0 0 20px var(--ec-teal); }
    50% { box-shadow: 0 0 40px var(--ec-teal), 0 0 60px rgba(20, 244, 255, 0.5); }
}

/* === 7. TARGETING VISUALS === */
.ec-targetable {
    cursor: pointer !important;
    animation: ec-targetable-glow 1s ease-in-out infinite;
}

@keyframes ec-targetable-glow {
    0%, 100% { box-shadow: 0 0 15px rgba(20, 244, 255, 0.4); }
    50% { box-shadow: 0 0 30px rgba(20, 244, 255, 0.7), 0 0 50px rgba(20, 244, 255, 0.3); }
}

.ec-targeted {
    box-shadow: 0 0 0 3px var(--ec-teal), 0 0 40px var(--ec-teal) !important;
    animation: none !important;
}

.ec-target-line {
    position: fixed;
    height: 4px;
    background: linear-gradient(90deg, var(--ec-teal), transparent 20%, var(--ec-teal) 80%, transparent);
    transform-origin: left center;
    pointer-events: none;
    z-index: 9997;
    opacity: 0;
    transition: opacity 0.2s ease;
    border-radius: 2px;
    box-shadow: 0 0 15px var(--ec-teal), 0 0 30px rgba(20, 244, 255, 0.5);
}

.ec-target-line.visible {
    opacity: 1;
}

/* === 8. ENHANCED CODEX VIEW === */
.ec-codex-card {
    padding: 16px;
}

.ec-codex-name {
    font-family: 'Cinzel', serif;
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--ec-gold);
    margin-bottom: 8px;
    text-shadow: 0 0 10px rgba(246, 196, 83, 0.3);
}

.ec-codex-meta {
    font-size: 0.9rem;
    color: var(--ec-amethyst);
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(124, 58, 237, 0.3);
}

.ec-codex-meta .ec-meta-type {
    font-weight: 600;
}

.ec-codex-meta .ec-meta-cost {
    color: var(--ec-teal);
    margin-left: 10px;
}

.ec-codex-body {
    font-size: 0.95rem;
    color: rgba(255, 255, 255, 0.9);
    line-height: 1.6;
    margin-bottom: 12px;
}

.ec-codex-body .ec-ability {
    display: block;
    margin-bottom: 8px;
    padding-left: 12px;
    border-left: 2px solid var(--ec-amethyst);
}

.ec-codex-body .ec-ability-name {
    font-weight: 700;
    color: var(--ec-teal);
}

.ec-codex-body .ec-ability-manifest { border-left-color: var(--ec-gold); }
.ec-codex-body .ec-ability-active { border-left-color: var(--ec-teal); }
.ec-codex-body .ec-ability-cycle { border-left-color: var(--ec-amethyst); }
.ec-codex-body .ec-ability-crownbound { border-left-color: var(--damage-red); }

.ec-codex-flavor {
    font-size: 0.85rem;
    font-style: italic;
    color: rgba(255, 255, 255, 0.5);
    padding-top: 10px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

/* === 9. HUD POLISH - STAT PULSES === */
.ec-pulse-gold {
    animation: ec-pulse-gold 0.4s ease-out;
}

@keyframes ec-pulse-gold {
    0% { box-shadow: 0 0 0 rgba(246, 196, 83, 0); }
    50% { box-shadow: 0 0 30px var(--ec-gold), 0 0 50px rgba(246, 196, 83, 0.5); }
    100% { box-shadow: 0 0 0 rgba(246, 196, 83, 0); }
}

.ec-pulse-damage {
    animation: ec-pulse-damage 0.4s ease-out;
}

@keyframes ec-pulse-damage {
    0% { box-shadow: 0 0 0 rgba(255, 68, 68, 0); }
    50% { box-shadow: 0 0 30px var(--damage-red), 0 0 50px rgba(255, 68, 68, 0.5); }
    100% { box-shadow: 0 0 0 rgba(255, 68, 68, 0); }
}

.ec-pulse-heal {
    animation: ec-pulse-heal 0.4s ease-out;
}

@keyframes ec-pulse-heal {
    0% { box-shadow: 0 0 0 rgba(0, 255, 204, 0); }
    50% { box-shadow: 0 0 30px var(--essence-glow), 0 0 50px rgba(0, 255, 204, 0.5); }
    100% { box-shadow: 0 0 0 rgba(0, 255, 204, 0); }
}

.ec-pulse-teal {
    animation: ec-pulse-teal 0.4s ease-out;
}

@keyframes ec-pulse-teal {
    0% { box-shadow: 0 0 0 rgba(20, 244, 255, 0); }
    50% { box-shadow: 0 0 30px var(--ec-teal), 0 0 50px rgba(20, 244, 255, 0.5); }
    100% { box-shadow: 0 0 0 rgba(20, 244, 255, 0); }
}

/* Essence bar smooth transition */
.ec-essence-fill {
    transition: width 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Phase indicator enhanced */
.ec-phase-display #phase-badge {
    transition: all 0.3s ease;
}

.ec-phase-display #phase-badge.phase-change {
    animation: ec-phase-change 0.5s ease-out;
}

@keyframes ec-phase-change {
    0% { transform: scale(1); }
    30% { transform: scale(1.1); box-shadow: 0 0 30px var(--ec-gold); }
    100% { transform: scale(1); }
}

.phase-step.active {
    transform: scale(1.1);
    transition: all 0.3s ease;
}

.phase-step.active .phase-icon {
    text-shadow: 0 0 15px var(--ec-gold);
}

/* ============================================
   PREMIUM DECK BUILDER - COSMIC FORGE THEME
   ============================================ */

.ec-deckbuilder {
    width: 98vw;
    max-width: 1600px;
    height: 95vh;
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    background: linear-gradient(160deg, 
        rgba(15, 10, 35, 0.98) 0%,
        rgba(25, 15, 50, 0.98) 30%,
        rgba(20, 12, 45, 0.98) 70%,
        rgba(10, 8, 30, 0.98) 100%);
    border: 2px solid;
    border-image: linear-gradient(135deg, var(--gold), transparent, var(--gold)) 1;
    border-radius: 20px;
    box-shadow: 
        0 0 60px rgba(147, 51, 234, 0.3),
        inset 0 0 100px rgba(212, 175, 55, 0.05);
    overflow: hidden;
    position: relative;
}

.ec-deckbuilder::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        radial-gradient(ellipse at 20% 20%, rgba(147, 51, 234, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(212, 175, 55, 0.08) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
}

/* === HEADER BAR === */
.ec-deckbuilder-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 25px;
    background: linear-gradient(90deg, 
        rgba(30, 20, 50, 0.9) 0%,
        rgba(40, 25, 60, 0.9) 50%,
        rgba(30, 20, 50, 0.9) 100%);
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    position: relative;
    z-index: 10;
}

.ec-db-title {
    display: flex;
    align-items: center;
    gap: 12px;
}

.ec-db-icon {
    font-size: 2rem;
    filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.6));
}

.ec-db-title h1 {
    font-family: 'Cinzel Decorative', serif;
    font-size: 1.8rem;
    background: linear-gradient(135deg, var(--gold) 0%, #fff 50%, var(--gold) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    margin: 0;
    letter-spacing: 3px;
}

.ec-db-deck-meta {
    display: flex;
    align-items: center;
    gap: 20px;
}

.ec-db-name-input {
    padding: 10px 20px;
    background: rgba(20, 15, 40, 0.8);
    border: 1px solid rgba(212, 175, 55, 0.4);
    border-radius: 8px;
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 1.1rem;
    min-width: 200px;
    transition: all 0.3s ease;
}

.ec-db-name-input:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
}

.ec-db-card-counter {
    display: flex;
    align-items: baseline;
    padding: 8px 16px;
    background: rgba(10, 8, 30, 0.8);
    border-radius: 8px;
    border: 1px solid rgba(0, 255, 204, 0.3);
}

.ec-db-count {
    font-size: 2rem;
    font-weight: 700;
    color: var(--essence-glow);
    text-shadow: 0 0 15px var(--essence-glow);
}

.ec-db-count-max {
    font-size: 1.2rem;
    color: rgba(255, 255, 255, 0.5);
}

.ec-db-actions {
    display: flex;
    gap: 10px;
}

.ec-db-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    font-family: 'Cinzel', serif;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
}

.ec-db-btn .btn-icon {
    font-size: 1.1rem;
}

.ec-db-btn.save {
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    color: #000;
}

.ec-db-btn.save:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(212, 175, 55, 0.5);
}

.ec-db-btn.clear {
    background: rgba(100, 50, 50, 0.6);
    color: #fff;
    border: 1px solid rgba(255, 100, 100, 0.4);
}

.ec-db-btn.clear:hover {
    background: rgba(150, 60, 60, 0.8);
    border-color: rgba(255, 100, 100, 0.8);
}

.ec-db-btn.play {
    background: linear-gradient(135deg, #00ccaa, var(--essence-glow));
    color: #000;
}

.ec-db-btn.play:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(0, 255, 204, 0.5);
}

/* === THREE-COLUMN GRID === */
.ec-deckbuilder-grid {
    flex: 1;
    display: grid;
    grid-template-columns: 1.5fr 1fr 1fr;
    gap: 20px;
    padding: 20px;
    min-height: 0;
    position: relative;
    z-index: 5;
}

/* === CARD POOL PANEL === */
.ec-db-pool {
    display: flex;
    flex-direction: column;
    background: rgba(15, 10, 35, 0.7);
    border-radius: 16px;
    border: 1px solid rgba(147, 51, 234, 0.3);
    padding: 15px;
    overflow: hidden;
}

.ec-db-filter-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 15px;
    padding: 12px;
    background: rgba(30, 20, 50, 0.6);
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.ec-filter-search {
    flex: 1;
    min-width: 200px;
    position: relative;
    display: flex;
    align-items: center;
}

.ec-filter-search .search-icon {
    position: absolute;
    left: 12px;
    font-size: 1rem;
    opacity: 0.6;
}

.ec-filter-search input {
    width: 100%;
    padding: 10px 15px 10px 40px;
    background: rgba(10, 8, 30, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: #fff;
    font-family: inherit;
    transition: all 0.3s ease;
}

.ec-filter-search input:focus {
    outline: none;
    border-color: var(--essence-glow);
    box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
}

.ec-filter-chips {
    display: flex;
    gap: 10px;
}

.ec-filter-select {
    padding: 10px 15px;
    background: rgba(10, 8, 30, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: #fff;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.3s ease;
}

.ec-filter-select:hover {
    border-color: var(--gold);
}

.ec-db-pool-cards {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
    overflow-y: auto;
    padding-right: 8px;
}

/* Enhanced pool cards */
.pool-card {
    background: linear-gradient(145deg, 
        rgba(40, 30, 70, 0.9) 0%,
        rgba(25, 18, 50, 0.9) 100%);
    border-radius: 10px;
    padding: 10px;
    cursor: grab;
    transition: all 0.3s ease;
    position: relative;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.pool-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 10px;
    padding: 1px;
    background: linear-gradient(135deg, transparent, rgba(212, 175, 55, 0.3), transparent);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.pool-card:hover::before {
    opacity: 1;
}

.pool-card:hover {
    transform: translateY(-5px) scale(1.02);
    box-shadow: 
        0 10px 30px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(147, 51, 234, 0.3);
    border-color: var(--gold);
}

.pool-card:active {
    cursor: grabbing;
    transform: scale(0.98);
}

.pool-card img {
    width: 100%;
    border-radius: 6px;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
}

.pool-card-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    padding: 6px 0;
}

.pool-card-name {
    font-size: 0.8rem;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex: 1;
}

.pool-card-cost {
    background: rgba(0, 255, 204, 0.2);
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    color: var(--essence-glow);
    font-weight: 600;
}

.pool-card-hint {
    font-size: 0.65rem;
    color: rgba(255, 255, 255, 0.4);
    text-align: center;
    margin-top: 5px;
}

/* Pool section headers */
.pool-section {
    margin-bottom: 20px;
}

.pool-section-title {
    font-family: 'Cinzel', serif;
    font-size: 1rem;
    color: var(--gold);
    margin: 0 0 10px 0;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    display: flex;
    align-items: center;
    gap: 8px;
}

.pool-section-title::before {
    content: '‚óÜ';
    font-size: 0.6rem;
}

/* === STATS PANEL === */
.ec-db-stats {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.ec-stats-panel, .ec-saved-panel {
    background: rgba(15, 10, 35, 0.7);
    border-radius: 16px;
    border: 1px solid rgba(212, 175, 55, 0.2);
    padding: 18px;
}

.ec-stats-panel {
    flex: 1;
}

.ec-saved-panel {
    flex: 0 0 auto;
    max-height: 200px;
}

.ec-stats-title {
    font-family: 'Cinzel', serif;
    font-size: 1rem;
    color: var(--gold);
    margin: 0 0 15px 0;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(212, 175, 55, 0.2);
    text-transform: uppercase;
    letter-spacing: 2px;
}

.ec-stat-section {
    margin-bottom: 18px;
}

.ec-stat-section h4 {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.7);
    margin: 0 0 10px 0;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* KL Curve Histogram */
.ec-kl-curve {
    display: flex;
    align-items: flex-end;
    gap: 6px;
    height: 80px;
    padding: 10px 5px;
    background: rgba(10, 8, 30, 0.5);
    border-radius: 8px;
}

.ec-kl-bar {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100%;
}

.ec-kl-bar .bar-fill {
    width: 100%;
    background: linear-gradient(180deg, var(--essence-glow) 0%, rgba(0, 255, 204, 0.4) 100%);
    border-radius: 4px 4px 0 0;
    min-height: 4px;
    transition: height 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
}

.ec-kl-bar span {
    margin-top: auto;
    font-size: 0.7rem;
    color: rgba(255, 255, 255, 0.6);
    padding-top: 4px;
}

/* Type Breakdown Bars */
.ec-type-bars {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.ec-type-row {
    display: grid;
    grid-template-columns: 60px 1fr 30px;
    align-items: center;
    gap: 10px;
}

.type-label {
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.7);
}

.type-bar {
    height: 12px;
    background: rgba(30, 20, 50, 0.6);
    border-radius: 6px;
    overflow: hidden;
}

.type-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.3s ease;
}

.type-fill.avatar { background: linear-gradient(90deg, #9333ea, #a855f7); }
.type-fill.spell { background: linear-gradient(90deg, #3b82f6, #60a5fa); }
.type-fill.domain { background: linear-gradient(90deg, var(--gold), #fcd34d); }
.type-fill.relic { background: linear-gradient(90deg, var(--essence-glow), #5eead4); }

.type-count {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.8);
    text-align: right;
}

/* Aspect Distribution */
.ec-aspect-rings {
    display: flex;
    justify-content: center;
    gap: 20px;
}

.ec-aspect-badge {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    padding: 12px 18px;
    border-radius: 12px;
    transition: all 0.3s ease;
}

.ec-aspect-badge.glow {
    background: linear-gradient(145deg, rgba(255, 220, 100, 0.2), rgba(255, 200, 50, 0.1));
    border: 1px solid rgba(255, 220, 100, 0.4);
}

.ec-aspect-badge.void {
    background: linear-gradient(145deg, rgba(147, 51, 234, 0.2), rgba(100, 30, 180, 0.1));
    border: 1px solid rgba(147, 51, 234, 0.4);
}

.ec-aspect-badge.gray {
    background: linear-gradient(145deg, rgba(150, 150, 150, 0.2), rgba(100, 100, 100, 0.1));
    border: 1px solid rgba(200, 200, 200, 0.3);
}

.aspect-icon {
    font-size: 1.4rem;
}

.aspect-count {
    font-size: 1.2rem;
    font-weight: 600;
    color: #fff;
}

/* Saved Decks */
.ec-saved-decks {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 120px;
    overflow-y: auto;
}

.ec-saved-deck-card {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    background: rgba(30, 25, 55, 0.6);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
}

.ec-saved-deck-card:hover {
    background: rgba(50, 40, 80, 0.8);
    border-color: var(--gold);
    transform: translateX(5px);
}

.ec-saved-deck-card .deck-icon {
    font-size: 1.2rem;
}

.ec-saved-deck-card .deck-name {
    flex: 1;
    color: #fff;
    font-size: 0.85rem;
}

.ec-saved-deck-card .deck-count {
    color: var(--essence-glow);
    font-size: 0.75rem;
}

.ec-saved-deck-card .deck-actions {
    display: flex;
    gap: 5px;
}

.ec-saved-deck-card .deck-action-btn {
    padding: 4px 10px;
    border: none;
    border-radius: 4px;
    font-size: 0.7rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.ec-saved-deck-card .deck-action-btn.load {
    background: rgba(0, 255, 204, 0.2);
    color: var(--essence-glow);
}

.ec-saved-deck-card .deck-action-btn.load:hover {
    background: rgba(0, 255, 204, 0.4);
}

.ec-saved-deck-card .deck-action-btn.delete {
    background: rgba(255, 100, 100, 0.2);
    color: #ff6666;
}

.ec-saved-deck-card .deck-action-btn.delete:hover {
    background: rgba(255, 100, 100, 0.4);
}

/* === DECK LIST PANEL === */
.ec-db-decklist {
    display: flex;
    flex-direction: column;
    background: rgba(15, 10, 35, 0.7);
    border-radius: 16px;
    border: 1px solid rgba(0, 255, 204, 0.2);
    padding: 15px;
    overflow: hidden;
}

.ec-decklist-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.ec-decklist-title {
    font-family: 'Cinzel', serif;
    font-size: 1rem;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 2px;
}

.ec-deck-validity {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 5px 12px;
    border-radius: 6px;
    font-size: 0.75rem;
}

.ec-deck-validity.invalid {
    background: rgba(255, 100, 100, 0.2);
    border: 1px solid rgba(255, 100, 100, 0.4);
    color: #ff8888;
}

.ec-deck-validity.valid {
    background: rgba(0, 255, 204, 0.2);
    border: 1px solid rgba(0, 255, 204, 0.4);
    color: var(--essence-glow);
}

.ec-deck-cards {
    flex: 1;
    overflow-y: auto;
    padding-right: 8px;
}

/* Enhanced deck card entries */
.deck-card-entry {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    background: linear-gradient(135deg, rgba(40, 30, 65, 0.6), rgba(30, 22, 50, 0.6));
    border-radius: 8px;
    margin-bottom: 6px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    cursor: grab;
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
}

.deck-card-entry::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 3px;
    background: var(--gold);
    opacity: 0;
    transition: opacity 0.2s ease;
}

.deck-card-entry:hover::before {
    opacity: 1;
}

.deck-card-entry:hover {
    background: linear-gradient(135deg, rgba(60, 45, 90, 0.8), rgba(45, 35, 70, 0.8));
    transform: translateX(5px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.deck-card-entry.ec-flash-add {
    animation: ec-flash-teal 0.4s ease-out;
}

.deck-card-entry.ec-flash-remove {
    animation: ec-flash-crimson 0.3s ease-out;
}

@keyframes ec-flash-teal {
    0% { box-shadow: 0 0 0 rgba(0, 255, 204, 0); background: rgba(0, 255, 204, 0.3); }
    100% { box-shadow: 0 0 20px rgba(0, 255, 204, 0); background: linear-gradient(135deg, rgba(40, 30, 65, 0.6), rgba(30, 22, 50, 0.6)); }
}

@keyframes ec-flash-crimson {
    0% { box-shadow: 0 0 0 rgba(255, 100, 100, 0); background: rgba(255, 100, 100, 0.3); }
    100% { box-shadow: 0 0 20px rgba(255, 100, 100, 0); background: linear-gradient(135deg, rgba(40, 30, 65, 0.6), rgba(30, 22, 50, 0.6)); }
}

.deck-card-thumb {
    width: 40px;
    height: 56px;
    border-radius: 4px;
    object-fit: cover;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
}

.deck-card-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.deck-card-name {
    color: #fff;
    font-size: 0.85rem;
}

.deck-card-meta {
    display: flex;
    gap: 8px;
    font-size: 0.7rem;
    color: rgba(255, 255, 255, 0.5);
}

.deck-card-count {
    background: rgba(212, 175, 55, 0.2);
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 0.85rem;
    color: var(--gold);
    font-weight: 600;
}

.deck-card-remove {
    padding: 6px 10px;
    cursor: pointer;
    color: rgba(255, 100, 100, 0.6);
    font-size: 1.1rem;
    transition: all 0.2s ease;
    border-radius: 4px;
}

.deck-card-remove:hover {
    color: #ff6666;
    background: rgba(255, 100, 100, 0.2);
}

/* === BACK BUTTON === */
.ec-db-back {
    position: absolute;
    bottom: 15px;
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 30px;
    background: rgba(30, 25, 50, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: #fff;
    font-family: 'Cinzel', serif;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 20;
}

.ec-db-back:hover {
    background: rgba(50, 40, 80, 0.9);
    border-color: var(--gold);
}

/* === DRAG & DROP STATES === */
.ec-db-decklist.drag-over {
    border-color: var(--essence-glow);
    box-shadow: inset 0 0 30px rgba(0, 255, 204, 0.1);
}

.pool-card.dragging {
    opacity: 0.5;
    transform: scale(0.95);
}

/* === RESPONSIVE === */
@media (max-width: 1400px) {
    .ec-deckbuilder-grid {
        grid-template-columns: 1.2fr 1fr 1fr;
    }
}

@media (max-width: 1200px) {
    .ec-deckbuilder-grid {
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr auto;
    }
    
    .ec-db-pool {
        grid-column: 1 / -1;
    }
    
    .ec-db-stats {
        flex-direction: row;
    }
    
    .ec-stats-panel, .ec-saved-panel {
        flex: 1;
    }
}

@media (max-width: 992px) {
    .ec-deckbuilder-header {
        flex-wrap: wrap;
        gap: 15px;
    }
    
    .ec-db-actions {
        width: 100%;
        justify-content: center;
    }
    
    .ec-deckbuilder-grid {
        grid-template-columns: 1fr;
    }
    
    .ec-db-stats {
        flex-direction: column;
    }
}

/* ===== SITEWIDE RESPONSIVE FIXES ===== */

/* Ensure all overlays are scrollable */
.overlay,
.collection-overlay,
.solo-overlay,
.campaign-overlay,
.deckbuilder-overlay,
.profile-overlay,
.shop-overlay,
.multiplayer-overlay {
    overflow-y: auto !important;
    overflow-x: hidden !important;
    -webkit-overflow-scrolling: touch;
}

/* All containers should not clip content */
.overlay > div,
.modal-content,
.panel-content {
    max-height: none;
    overflow: visible;
}

/* Scrollable containers within overlays */
.overlay-content,
.modal-body,
.panel-body,
.collection-grid,
.campaign-chapters,
.shop-grid {
    overflow-y: auto;
    max-height: calc(90vh - 120px);
    max-height: calc(90dvh - 120px);
}

/* Fix field rows on smaller screens */
@media (max-width: 1200px) {
    .ec-field-row {
        grid-template-columns: 1fr 1.5fr 1fr;
        gap: 8px;
    }
    
    .ec-card-slot {
        width: clamp(45px, 5.5vw, 65px);
        height: clamp(63px, 7.7vw, 90px);
    }
    
    .board-row {
        gap: 4px;
    }
}

@media (max-width: 900px) {
    .ec-field-row {
        grid-template-columns: 1fr;
        gap: 6px;
    }
    
    .ec-zone-panel {
        padding: 8px;
    }
    
    .ec-hud {
        padding: 8px 12px;
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .ec-hud-crest {
        width: 45px;
        height: 45px;
    }
    
    .ec-hud-name {
        font-size: 14px;
    }
    
    .ec-essence-bar {
        width: 120px;
        height: 22px;
    }
    
    .menu-logo h1 {
        font-size: 2em;
    }
    
    .menu-logo h2 {
        font-size: 1.2em;
    }
    
    .menu-header {
        padding: 15px 20px;
        flex-wrap: wrap;
    }
}

@media (max-width: 600px) {
    .ec-card-slot {
        width: clamp(40px, 12vw, 55px);
        height: clamp(56px, 16.8vw, 77px);
    }
    
    .board-row.avatar-row {
        flex-wrap: wrap;
        justify-content: center;
    }
    
    .mode-card {
        min-height: 140px;
        padding: 15px 12px;
    }
    
    .menu-modes {
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        padding: 0 10px;
    }
    
    .mode-icon {
        font-size: 2em;
    }
    
    .mode-info h3 {
        font-size: 1em;
    }
    
    .mode-info p {
        font-size: 0.8em;
    }
    
    .menu-profile {
        padding: 10px 15px;
    }
    
    .ec-hud-bars {
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .ec-pill {
        padding: 4px 8px;
    }
}

/* Hand bar responsive */
@media (max-width: 1000px) {
    .ec-hand-bar {
        padding: 8px;
    }
    
    .ec-hand-content {
        gap: 8px;
    }
}

/* Ensure deity rings don't cause overflow */
.deity-ring {
    flex-shrink: 0;
}

/* Fix zone label positioning */
.zone-label {
    position: relative;
    transform: none;
}

/* Prevent horizontal scroll from card slots */
.board-row,
.avatar-row,
.domain-row,
.support-line,
.shard-relic-row {
    min-width: 0;
    overflow-x: auto;
    overflow-y: visible;
    -webkit-overflow-scrolling: touch;
}

/* Ensure all zones can shrink */
.ec-zone-body,
.ec-zone-panel {
    min-width: 0;
}

/* ============================================== */
/* PHASE 2: COMPREHENSIVE RESPONSIVE BREAKPOINTS */
/* ============================================== */

/* === LAPTOP BREAKPOINT (1366px) === */
@media (max-width: 1400px) {
    /* HUD adjustments */
    .ec-hud {
        padding: 10px 16px;
    }
    
    .ec-hud-name {
        font-size: 16px;
    }
    
    .deity-ring {
        width: 50px;
        height: 50px;
    }
    
    /* Phase tracker */
    .ec-phase-display {
        transform: scale(0.9);
    }
    
    #phase-tracker {
        gap: 6px;
    }
    
    .phase-step {
        padding: 4px 8px;
        font-size: 0.85em;
    }
    
    /* Hand bar */
    .ec-hand-cards .game-card {
        width: 70px;
        min-width: 70px;
        height: 98px;
    }
    
    /* Zone panels */
    .zone-label {
        font-size: 10px;
    }
    
    .ec-card-slot {
        width: clamp(45px, 6vw, 60px);
        height: clamp(63px, 8.4vw, 84px);
    }
    
    /* Essence counter */
    .essence-value {
        font-size: 28px;
    }
    
    .kl-text {
        font-size: 14px;
    }
}

/* === SMALL LAPTOP / LARGE TABLET (1200px) === */
@media (max-width: 1200px) {
    /* Side panels hide on smaller screens */
    .ec-side-panels {
        display: none;
    }
    
    .ec-main {
        grid-template-columns: 1fr;
    }
    
    /* HUD compact mode */
    .ec-hud {
        padding: 8px 12px;
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .ec-hud-player {
        gap: 10px;
    }
    
    .deity-ring {
        width: 45px;
        height: 45px;
    }
    
    .ec-hud-name {
        font-size: 14px;
    }
    
    .ec-hud-title {
        font-size: 10px;
    }
    
    /* Phase tracker compact */
    #phase-tracker {
        padding: 6px 10px;
        gap: 4px;
    }
    
    .phase-icon {
        font-size: 14px;
    }
    
    .phase-label {
        font-size: 9px;
    }
    
    /* Hand cards smaller */
    .ec-hand-cards .game-card {
        width: 65px;
        min-width: 65px;
        height: 91px;
    }
    
    .ec-hand-cards .game-card .card-name {
        font-size: 8px;
    }
    
    /* Zone slots */
    .ec-card-slot {
        width: clamp(40px, 5.5vw, 55px);
        height: clamp(56px, 7.7vw, 77px);
    }
    
    .ec-card-slot--avatar {
        width: clamp(42px, 6vw, 58px);
    }
}

/* === TABLET BREAKPOINT (992px) === */
@media (max-width: 992px) {
    /* Game container fills screen */
    #game-container {
        padding: 0;
    }
    
    .ec-frame {
        border-radius: 0;
    }
    
    /* HUD even more compact */
    .ec-hud {
        padding: 6px 10px;
    }
    
    .essence-counter {
        flex-direction: row;
        gap: 6px;
    }
    
    .essence-value {
        font-size: 22px;
    }
    
    .kl-display {
        flex-direction: row;
        gap: 6px;
    }
    
    .kl-pips {
        display: none;
    }
    
    /* Hide HUD stats on mobile */
    .ec-hud-stats {
        display: none;
    }
    
    /* Hand bar adjustments */
    .ec-hand-bar {
        padding: 6px 8px 10px;
    }
    
    .ec-hand-header {
        display: none;
    }
    
    .ec-hand-cards {
        min-height: 90px;
        gap: 6px;
    }
    
    .ec-hand-cards .game-card {
        width: 55px;
        min-width: 55px;
        height: 77px;
    }
    
    .ec-hand-cards .game-card .card-cost {
        width: 18px;
        height: 18px;
        font-size: 10px;
    }
    
    .ec-hand-cards .game-card:hover {
        transform: translateY(-15px) scale(1.08);
    }
    
    /* Deck and graveyard piles */
    .ec-deck-pile,
    .ec-graveyard-pile {
        width: 45px;
    }
    
    /* Zone panels compact */
    .ec-zone-panel {
        margin: 2px 0;
    }
    
    .zone-label {
        font-size: 9px;
        padding: 2px 6px;
    }
    
    .ec-card-slot {
        width: clamp(35px, 10vw, 50px);
        height: clamp(49px, 14vw, 70px);
    }
    
    /* Domain zone */
    .ec-domain-zone {
        padding: 6px;
        margin: 4px 0;
    }
    
    .ec-domain-title {
        font-size: 10px;
    }
    
    .ec-domain-name {
        font-size: 14px;
    }
    
    .ec-domain-text {
        display: none;
    }
    
    /* Phase tracker minimal */
    .ec-phase-display {
        position: fixed;
        top: auto;
        bottom: auto;
        right: 5px;
        transform: scale(0.8);
    }
    
    #phase-badge {
        padding: 6px 10px;
    }
    
    .turn-number {
        font-size: 12px;
    }
    
    .phase-name {
        font-size: 10px;
    }
    
    #phase-tracker {
        flex-wrap: wrap;
        max-width: 200px;
    }
}

/* === SMALL TABLET / PHONE BREAKPOINT (768px) === */
@media (max-width: 768px) {
    /* HUD ultra-compact */
    .ec-hud {
        padding: 4px 8px;
        justify-content: center;
    }
    
    .ec-hud-player {
        gap: 6px;
    }
    
    .deity-ring {
        width: 36px;
        height: 36px;
    }
    
    .ec-hud-text {
        display: none;
    }
    
    .essence-counter {
        gap: 4px;
    }
    
    .essence-glyph {
        width: 20px;
        height: 20px;
    }
    
    .essence-value {
        font-size: 18px;
    }
    
    .kl-text {
        font-size: 12px;
    }
    
    /* Hand cards very compact */
    .ec-hand-cards {
        min-height: 70px;
        gap: 4px;
        padding: 4px 0;
    }
    
    .ec-hand-cards .game-card {
        width: 48px;
        min-width: 48px;
        height: 67px;
    }
    
    .ec-hand-cards .game-card .card-cost {
        width: 16px;
        height: 16px;
        font-size: 9px;
    }
    
    .ec-hand-cards .game-card .card-name {
        font-size: 7px;
    }
    
    .ec-hand-cards .game-card .card-stats .stat {
        font-size: 8px;
    }
    
    .ec-hand-cards .game-card:hover {
        transform: translateY(-10px) scale(1.05);
    }
    
    /* Zone slots minimal */
    .ec-card-slot {
        width: clamp(32px, 12vw, 45px);
        height: clamp(45px, 16.8vw, 63px);
    }
    
    /* Phase tracker hide labels */
    .phase-label {
        display: none;
    }
    
    .phase-icon {
        font-size: 12px;
    }
    
    /* Game controls */
    .ec-game-controls {
        top: auto;
        bottom: 10px;
        right: 10px;
        flex-direction: row;
        gap: 8px;
    }
    
    .ec-ctrl-btn {
        width: 36px;
        height: 36px;
    }
    
    /* Overlay containers */
    .overlay .queue-container,
    .overlay .solo-container,
    .overlay .campaign-container {
        padding: 15px;
        max-height: 95vh;
        overflow-y: auto;
    }
    
    .difficulty-grid {
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }
    
    .difficulty-card {
        padding: 15px 10px;
    }
    
    /* Menu modes */
    .menu-modes {
        grid-template-columns: 1fr;
        gap: 8px;
    }
    
    .mode-card {
        padding: 12px 15px;
    }
    
    /* Back buttons always visible */
    .back-btn {
        position: sticky;
        top: 0;
        z-index: 100;
        margin-bottom: 10px;
    }
}

/* === TURN INDICATOR IMPROVEMENTS === */
.turn-indicator {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Cinzel', serif;
    font-size: 24px;
    font-weight: 700;
    padding: 15px 40px;
    background: linear-gradient(135deg, rgba(20, 10, 40, 0.95) 0%, rgba(40, 20, 60, 0.95) 100%);
    border: 2px solid var(--ec-gold);
    border-radius: 12px;
    color: var(--ec-gold);
    text-shadow: 0 0 20px rgba(246, 196, 83, 0.5);
    box-shadow: 
        0 0 40px rgba(246, 196, 83, 0.3),
        inset 0 0 20px rgba(246, 196, 83, 0.1);
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    animation: turnIndicatorPulse 2s ease-out forwards;
}

@keyframes turnIndicatorPulse {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
    20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
    }
    80% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
    }
}

.turn-indicator.p1 {
    border-color: var(--ec-gold);
    color: var(--ec-gold);
}

.turn-indicator.p2 {
    border-color: var(--ec-amethyst);
    color: var(--ec-amethyst);
}

/* === BUTTON HOVER STATES === */
.ec-ctrl-btn:hover {
    background: linear-gradient(135deg, rgba(124, 58, 237, 0.5) 0%, rgba(80, 40, 160, 0.5) 100%);
    border-color: var(--ec-gold);
    transform: scale(1.1);
}

.ec-ctrl-btn:active {
    transform: scale(0.95);
}

.back-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: linear-gradient(135deg, rgba(30, 20, 50, 0.9) 0%, rgba(50, 30, 80, 0.9) 100%);
    border: 2px solid var(--ec-amethyst);
    border-radius: 8px;
    color: #fff;
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.back-btn:hover {
    background: linear-gradient(135deg, rgba(124, 58, 237, 0.4) 0%, rgba(80, 40, 160, 0.4) 100%);
    border-color: var(--ec-gold);
    color: var(--ec-gold);
    transform: translateX(-3px);
}

.deity-back-btn {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 10;
}

/* Victory screen responsive */
#victory-overlay {
    padding: 20px;
}

@media (max-width: 768px) {
    #victory-overlay .victory-content {
        padding: 20px;
        max-width: 90%;
    }
    
    #victory-overlay .victory-title {
        font-size: 2em;
    }
    
    #victory-overlay .victory-btn {
        padding: 12px 24px;
        font-size: 14px;
    }
}

/* Phase hint styling */
#action-prompt {
    position: fixed;
    bottom: 180px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, rgba(20, 10, 40, 0.95) 0%, rgba(40, 20, 60, 0.95) 100%);
    border: 2px solid var(--ec-teal);
    border-radius: 8px;
    padding: 10px 20px;
    color: #fff;
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    text-align: center;
    z-index: 500;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    max-width: 90%;
}

#action-prompt.visible {
    opacity: 1;
}

@media (max-width: 768px) {
    #action-prompt {
        bottom: 140px;
        font-size: 12px;
        padding: 8px 15px;
    }
}

/* Settings screen disabled */
#settings-screen {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
    height: 0 !important;
    overflow: hidden !important;
}

/* ============================================== */
/* ESSENCE CROWN: SHARD WARS - SUN ALTAR THEME   */
/* Premium Digital Tabletop Visual Language      */
/* ============================================== */

:root {
    /* Domain Color Palette */
    --domain-second-sun: #FFD700;
    --domain-second-sun-glow: rgba(255, 215, 0, 0.4);
    --domain-nullgrid: #8B5CF6;
    --domain-nullgrid-glow: rgba(139, 92, 246, 0.4);
    --domain-new-earth: #10B981;
    --domain-new-earth-glow: rgba(16, 185, 129, 0.4);
    --domain-crownline: #C0C0C0;
    --domain-crownline-glow: rgba(192, 192, 192, 0.4);
    --domain-solara: #F59E0B;
    --domain-solara-glow: rgba(245, 158, 11, 0.4);
    --domain-gray-court: #6B7280;
    --domain-gray-court-glow: rgba(107, 114, 128, 0.4);
    --domain-shattered-sun: #EF4444;
    --domain-shattered-sun-glow: rgba(239, 68, 68, 0.4);
    --domain-sanctuary-void: #1F2937;
    --domain-sanctuary-void-glow: rgba(31, 41, 55, 0.6);
    
    /* Aspect Colors */
    --aspect-glow: #FBBF24;
    --aspect-void: #7C3AED;
    --aspect-gray: #9CA3AF;
    --aspect-beast: #059669;
    
    /* Sun Altar Theme */
    --altar-stone: #1a1625;
    --altar-stone-light: #2d2640;
    --altar-engrave: rgba(139, 92, 246, 0.15);
    --altar-constellation: rgba(255, 215, 0, 0.08);
    --altar-border: rgba(255, 215, 0, 0.3);
    
    /* Floating Effects */
    --float-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
    --deity-glow: 0 0 40px rgba(255, 215, 0, 0.5);
    --card-lift: translateY(-8px);
}

/* ============================================== */
/* SUN ALTAR BATTLEFIELD                          */
/* ============================================== */

.sun-altar {
    position: relative;
    width: 100%;
    height: 100%;
    background: 
        /* Constellation lines overlay */
        repeating-linear-gradient(
            0deg,
            transparent,
            transparent 80px,
            var(--altar-constellation) 80px,
            var(--altar-constellation) 81px
        ),
        repeating-linear-gradient(
            90deg,
            transparent,
            transparent 80px,
            var(--altar-constellation) 80px,
            var(--altar-constellation) 81px
        ),
        /* Shard engravings */
        radial-gradient(
            ellipse at 20% 30%,
            var(--altar-engrave) 0%,
            transparent 50%
        ),
        radial-gradient(
            ellipse at 80% 70%,
            var(--altar-engrave) 0%,
            transparent 50%
        ),
        radial-gradient(
            ellipse at 50% 50%,
            var(--altar-engrave) 0%,
            transparent 40%
        ),
        /* Cosmic stone base */
        linear-gradient(
            135deg,
            var(--altar-stone) 0%,
            var(--altar-stone-light) 25%,
            var(--altar-stone) 50%,
            var(--altar-stone-light) 75%,
            var(--altar-stone) 100%
        );
    border: 2px solid var(--altar-border);
    border-radius: 12px;
    overflow: visible;
}

.sun-altar::before {
    content: '';
    position: absolute;
    inset: 0;
    background: 
        radial-gradient(
            circle at 50% 0%,
            rgba(255, 215, 0, 0.1) 0%,
            transparent 40%
        ),
        radial-gradient(
            circle at 50% 100%,
            rgba(139, 92, 246, 0.1) 0%,
            transparent 40%
        );
    pointer-events: none;
    z-index: 1;
}

/* Domain-colored edges */
.sun-altar[data-domain="second-sun"] {
    border-color: var(--domain-second-sun);
    box-shadow: 
        inset 0 0 100px var(--domain-second-sun-glow),
        0 0 30px var(--domain-second-sun-glow);
}

.sun-altar[data-domain="nullgrid"] {
    border-color: var(--domain-nullgrid);
    box-shadow: 
        inset 0 0 100px var(--domain-nullgrid-glow),
        0 0 30px var(--domain-nullgrid-glow);
}

.sun-altar[data-domain="new-earth"] {
    border-color: var(--domain-new-earth);
    box-shadow: 
        inset 0 0 100px var(--domain-new-earth-glow),
        0 0 30px var(--domain-new-earth-glow);
}

.sun-altar[data-domain="crownline"] {
    border-color: var(--domain-crownline);
    box-shadow: 
        inset 0 0 100px var(--domain-crownline-glow),
        0 0 30px var(--domain-crownline-glow);
}

.sun-altar[data-domain="gray-court"] {
    border-color: var(--domain-gray-court);
    box-shadow: 
        inset 0 0 100px var(--domain-gray-court-glow),
        0 0 30px var(--domain-gray-court-glow);
}

.sun-altar[data-domain="shattered-sun"] {
    border-color: var(--domain-shattered-sun);
    box-shadow: 
        inset 0 0 100px var(--domain-shattered-sun-glow),
        0 0 30px var(--domain-shattered-sun-glow);
}

/* ============================================== */
/* FLOATING DEITY CIRCLES                         */
/* ============================================== */

.deity-ring {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: 
        radial-gradient(
            circle,
            rgba(30, 20, 50, 0.95) 0%,
            rgba(20, 10, 35, 0.98) 100%
        );
    border: 3px solid var(--domain-second-sun);
    box-shadow: 
        var(--deity-glow),
        var(--float-shadow),
        inset 0 0 20px rgba(255, 215, 0, 0.2);
    animation: deity-float 4s ease-in-out infinite;
    z-index: 10;
}

.deity-ring::before {
    content: '';
    position: absolute;
    inset: -8px;
    border-radius: 50%;
    border: 2px solid transparent;
    background: 
        linear-gradient(
            135deg,
            rgba(255, 215, 0, 0.5) 0%,
            transparent 50%,
            rgba(139, 92, 246, 0.5) 100%
        ) border-box;
    mask: 
        linear-gradient(#fff 0 0) padding-box, 
        linear-gradient(#fff 0 0);
    mask-composite: exclude;
    animation: deity-halo-rotate 10s linear infinite;
}

.deity-ring::after {
    content: '';
    position: absolute;
    inset: -20px;
    border-radius: 50%;
    background: radial-gradient(
        circle,
        transparent 60%,
        rgba(255, 215, 0, 0.1) 80%,
        transparent 100%
    );
    animation: deity-pulse 3s ease-in-out infinite;
    pointer-events: none;
}

@keyframes deity-float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
}

@keyframes deity-halo-rotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes deity-pulse {
    0%, 100% { opacity: 0.5; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.1); }
}

/* Deity card inside the ring */
.deity-ring .deity-card-inner {
    width: 70px;
    height: 98px;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

.deity-ring .deity-card-inner img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* Ability trigger flare */
.deity-ring.ability-active::before {
    animation: deity-ability-flare 0.6s ease-out;
    border-color: var(--domain-second-sun);
}

@keyframes deity-ability-flare {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.8; }
    100% { transform: scale(2); opacity: 0; }
}

/* ============================================== */
/* PLAYER ZONES - ESSENCE CROWN LAYOUT           */
/* ============================================== */

.zone-wrapper {
    position: relative;
    padding: 8px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.15);
}

.zone-label {
    position: absolute;
    top: -10px;
    left: 12px;
    padding: 2px 10px;
    background: linear-gradient(135deg, #2d2640 0%, #1a1625 100%);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 4px;
    font-family: 'Cinzel', serif;
    font-size: 10px;
    font-weight: 600;
    color: var(--domain-second-sun);
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Avatar Line - Front Row Combat */
.avatar-line {
    display: flex;
    gap: 8px;
    justify-content: center;
    padding: 12px 8px;
    background: 
        linear-gradient(
            180deg,
            rgba(255, 215, 0, 0.05) 0%,
            transparent 100%
        );
    border: 1px dashed rgba(255, 215, 0, 0.2);
    border-radius: 8px;
}

/* Support Line - Back Row Utility */
.support-line {
    display: flex;
    gap: 8px;
    justify-content: center;
    padding: 12px 8px;
    background: 
        linear-gradient(
            180deg,
            rgba(139, 92, 246, 0.05) 0%,
            transparent 100%
        );
    border: 1px dashed rgba(139, 92, 246, 0.2);
    border-radius: 8px;
}

/* Shard/Relic Row - Crystalline Frames */
.shard-relic-row {
    display: flex;
    gap: 10px;
    justify-content: center;
    padding: 10px;
}

.shard-slot {
    width: 50px;
    height: 50px;
    background: 
        radial-gradient(
            circle,
            rgba(139, 92, 246, 0.1) 0%,
            transparent 70%
        );
    border: 2px solid rgba(139, 92, 246, 0.3);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition: all 0.3s ease;
}

.shard-slot::before {
    content: '';
    position: absolute;
    inset: 2px;
    border: 1px solid rgba(139, 92, 246, 0.2);
    border-radius: 6px;
    background: linear-gradient(
        135deg,
        rgba(139, 92, 246, 0.1) 0%,
        transparent 50%
    );
}

.shard-slot:hover {
    border-color: var(--domain-nullgrid);
    box-shadow: 0 0 20px var(--domain-nullgrid-glow);
}

.shard-slot.active {
    border-color: var(--domain-second-sun);
    box-shadow: 
        0 0 20px var(--domain-second-sun-glow),
        inset 0 0 15px var(--domain-second-sun-glow);
}

/* Spell Row - Temporary Display */
.spell-row {
    display: flex;
    gap: 8px;
    justify-content: center;
    padding: 8px;
    background: 
        linear-gradient(
            90deg,
            transparent 0%,
            rgba(239, 68, 68, 0.05) 50%,
            transparent 100%
        );
    border-radius: 8px;
    min-height: 80px;
}

.spell-slot {
    position: relative;
    width: 60px;
    height: 84px;
    border: 2px dashed rgba(239, 68, 68, 0.3);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.spell-slot.casting {
    animation: spell-burn 1.5s ease-out forwards;
}

@keyframes spell-burn {
    0% { 
        border-color: var(--domain-shattered-sun);
        box-shadow: 0 0 30px var(--domain-shattered-sun-glow);
    }
    50% {
        border-color: var(--domain-second-sun);
        box-shadow: 0 0 50px var(--domain-second-sun-glow);
    }
    100% {
        border-color: transparent;
        box-shadow: none;
    }
}

/* Deck Zone - Card Back Stack */
.deck-zone {
    position: relative;
    width: 70px;
    height: 98px;
}

.deck-stack {
    position: relative;
    width: 100%;
    height: 100%;
}

.deck-card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    background: 
        linear-gradient(
            135deg,
            #2a1f4d 0%,
            #1a1030 50%,
            #2a1f4d 100%
        );
    border: 2px solid var(--domain-second-sun);
    border-radius: 6px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
}

.deck-card-back::before {
    content: 'üëë';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    opacity: 0.8;
}

.deck-card-back:nth-child(1) { transform: translateY(-4px) rotate(-1deg); }
.deck-card-back:nth-child(2) { transform: translateY(-2px) rotate(0.5deg); }
.deck-card-back:nth-child(3) { transform: translateY(0); }

.deck-count-badge {
    position: absolute;
    bottom: -8px;
    right: -8px;
    width: 28px;
    height: 28px;
    background: linear-gradient(135deg, #2d2640 0%, #1a1625 100%);
    border: 2px solid var(--domain-second-sun);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    font-weight: 700;
    color: var(--domain-second-sun);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
}

/* The Fracture - Graveyard Zone */
.fracture-zone {
    position: relative;
    width: 70px;
    height: 98px;
    background: 
        radial-gradient(
            ellipse at center,
            rgba(239, 68, 68, 0.1) 0%,
            rgba(30, 20, 50, 0.5) 100%
        );
    border: 2px solid rgba(239, 68, 68, 0.4);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.fracture-zone::before {
    content: '';
    position: absolute;
    inset: 0;
    background: 
        linear-gradient(
            45deg,
            transparent 0%,
            transparent 45%,
            rgba(239, 68, 68, 0.2) 45%,
            rgba(239, 68, 68, 0.2) 55%,
            transparent 55%
        ),
        linear-gradient(
            -45deg,
            transparent 0%,
            transparent 45%,
            rgba(239, 68, 68, 0.2) 45%,
            rgba(239, 68, 68, 0.2) 55%,
            transparent 55%
        );
    background-size: 20px 20px;
    opacity: 0.5;
}

.fracture-icon {
    font-size: 32px;
    opacity: 0.6;
    z-index: 1;
}

.fracture-count {
    position: absolute;
    bottom: 4px;
    right: 4px;
    padding: 2px 6px;
    background: rgba(0, 0, 0, 0.7);
    border-radius: 4px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 11px;
    font-weight: 700;
    color: #ef4444;
}

/* ============================================== */
/* ESSENCE & KL HUD                               */
/* ============================================== */

.essence-hud {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 16px;
    background: rgba(0, 0, 0, 0.6);
    border-radius: 12px;
    border: 1px solid rgba(255, 215, 0, 0.2);
}

.essence-counter {
    position: relative;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.essence-glyph {
    position: absolute;
    inset: 0;
    background: 
        radial-gradient(
            circle,
            rgba(255, 215, 0, 0.2) 0%,
            transparent 70%
        );
    border: 2px solid var(--domain-second-sun);
    border-radius: 50%;
    animation: essence-glow 3s ease-in-out infinite;
}

.essence-glyph::before {
    content: '';
    position: absolute;
    inset: 4px;
    border: 1px solid rgba(255, 215, 0, 0.4);
    border-radius: 50%;
}

.essence-value {
    position: relative;
    font-family: 'Cinzel', serif;
    font-size: 24px;
    font-weight: 700;
    color: var(--domain-second-sun);
    text-shadow: 0 0 10px var(--domain-second-sun-glow);
    z-index: 1;
}

@keyframes essence-glow {
    0%, 100% { box-shadow: 0 0 15px var(--domain-second-sun-glow); }
    50% { box-shadow: 0 0 30px var(--domain-second-sun-glow); }
}

/* KL Resource Pips */
.kl-display {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.kl-label {
    font-family: 'Rajdhani', sans-serif;
    font-size: 10px;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.6);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.kl-pips {
    display: flex;
    gap: 4px;
}

.kl-pip {
    width: 16px;
    height: 20px;
    background: 
        linear-gradient(
            180deg,
            rgba(139, 92, 246, 0.3) 0%,
            rgba(139, 92, 246, 0.1) 100%
        );
    border: 1px solid rgba(139, 92, 246, 0.4);
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    transition: all 0.3s ease;
}

.kl-pip.active {
    background: 
        linear-gradient(
            180deg,
            var(--domain-nullgrid) 0%,
            rgba(139, 92, 246, 0.6) 100%
        );
    border-color: var(--domain-nullgrid);
    box-shadow: 0 0 10px var(--domain-nullgrid-glow);
}

.kl-pip.spent {
    background: rgba(50, 40, 70, 0.5);
    border-color: rgba(100, 80, 120, 0.3);
    opacity: 0.4;
}

.kl-pip.cracked {
    animation: pip-crack 0.3s ease-out;
}

@keyframes pip-crack {
    0% { transform: scale(1); }
    50% { transform: scale(0.8); opacity: 0.5; }
    100% { transform: scale(1); opacity: 0.4; }
}

/* ============================================== */
/* HAND & CARD INSPECT                            */
/* ============================================== */

.hand-fan {
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding: 10px 20px 20px;
    perspective: 1200px;
}

.hand-card {
    position: relative;
    width: 80px;
    height: 112px;
    margin: 0 -15px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    transform-origin: bottom center;
    cursor: pointer;
}

.hand-card:hover {
    transform: translateY(-30px) scale(1.15) !important;
    z-index: 100;
    margin: 0 10px;
}

.hand-card:hover .card-domain-edge {
    opacity: 1;
}

.card-domain-edge {
    position: absolute;
    inset: -3px;
    border-radius: 8px;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

.card-domain-edge.glow {
    box-shadow: 0 0 20px var(--aspect-glow);
    border: 2px solid var(--aspect-glow);
}

.card-domain-edge.void {
    box-shadow: 0 0 20px var(--aspect-void);
    border: 2px solid var(--aspect-void);
}

.card-domain-edge.gray {
    box-shadow: 0 0 20px var(--aspect-gray);
    border: 2px solid var(--aspect-gray);
}

.card-domain-edge.beast {
    box-shadow: 0 0 20px var(--aspect-beast);
    border: 2px solid var(--aspect-beast);
}

/* Card Detail Panel */
.card-detail-panel {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 280px;
    background: 
        linear-gradient(
            135deg,
            rgba(30, 20, 50, 0.98) 0%,
            rgba(20, 10, 35, 0.98) 100%
        );
    border: 2px solid var(--altar-border);
    border-radius: 12px;
    padding: 16px;
    z-index: 200;
    box-shadow: 
        0 10px 40px rgba(0, 0, 0, 0.8),
        0 0 30px var(--domain-second-sun-glow);
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.card-detail-panel.visible {
    opacity: 1;
    visibility: visible;
}

.card-detail-art {
    width: 100%;
    height: 160px;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 12px;
    border: 2px solid rgba(255, 215, 0, 0.3);
}

.card-detail-art img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.card-detail-name {
    font-family: 'Cinzel', serif;
    font-size: 18px;
    font-weight: 700;
    color: var(--domain-second-sun);
    margin-bottom: 4px;
}

.card-detail-type {
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.6);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 8px;
}

.card-detail-domains {
    display: flex;
    gap: 6px;
    margin-bottom: 12px;
}

.domain-tag {
    padding: 3px 8px;
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 4px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 10px;
    font-weight: 600;
    color: var(--domain-second-sun);
    text-transform: uppercase;
}

.card-detail-stats {
    display: flex;
    gap: 12px;
    margin-bottom: 12px;
    padding: 8px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 6px;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.stat-value {
    font-family: 'Cinzel', serif;
    font-size: 20px;
    font-weight: 700;
    color: #fff;
}

.stat-label {
    font-family: 'Rajdhani', sans-serif;
    font-size: 10px;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
}

.card-detail-text {
    font-family: 'Rajdhani', sans-serif;
    font-size: 13px;
    line-height: 1.5;
    color: rgba(255, 255, 255, 0.85);
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 6px;
    border-left: 3px solid var(--domain-nullgrid);
}

/* ============================================== */
/* SHATTERED SUN CHRONICLE - CAMPAIGN PANEL      */
/* ============================================== */

.chronicle-panel {
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 280px;
    max-height: 420px;
    background: 
        linear-gradient(
            135deg,
            rgba(25, 18, 42, 0.97) 0%,
            rgba(18, 12, 32, 0.98) 100%
        );
    border: 2px solid rgba(212, 175, 55, 0.5);
    border-radius: 8px;
    overflow: hidden;
    z-index: 150;
    box-shadow: 
        0 15px 50px rgba(0, 0, 0, 0.7),
        0 0 30px rgba(212, 175, 55, 0.15),
        inset 0 0 40px rgba(139, 92, 246, 0.08);
}

.chronicle-panel::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 70%;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
}

.chronicle-header {
    padding: 14px 18px;
    background: 
        linear-gradient(
            135deg,
            rgba(212, 175, 55, 0.15) 0%,
            rgba(139, 92, 246, 0.08) 100%
        );
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.chronicle-title {
    font-family: 'Cinzel', serif;
    font-size: 13px;
    font-weight: 700;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 3px;
    text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
}

.chronicle-toggle {
    width: 26px;
    height: 26px;
    background: rgba(212, 175, 55, 0.1);
    border: 1px solid rgba(212, 175, 55, 0.4);
    border-radius: 4px;
    color: var(--gold);
    cursor: pointer;
    transition: all 0.2s ease;
}

.chronicle-toggle:hover {
    background: rgba(212, 175, 55, 0.2);
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
}

.chronicle-content {
    padding: 18px;
    overflow-y: auto;
    max-height: 340px;
}

.chronicle-chapter {
    font-family: 'Cinzel', serif;
    font-size: 17px;
    font-weight: 700;
    color: var(--gold);
    margin-bottom: 6px;
    text-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
}

.chronicle-act {
    font-family: 'Rajdhani', sans-serif;
    font-size: 11px;
    color: var(--ec-amethyst);
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 14px;
    padding: 4px 10px;
    background: rgba(139, 92, 246, 0.15);
    border-radius: 4px;
    display: inline-block;
}

.chronicle-story {
    font-family: 'Rajdhani', sans-serif;
    font-size: 13px;
    line-height: 1.7;
    color: rgba(255, 255, 255, 0.85);
    margin-bottom: 18px;
    padding: 12px 14px;
    background: 
        linear-gradient(135deg, rgba(139, 92, 246, 0.08) 0%, rgba(0, 0, 0, 0.2) 100%);
    border-left: 3px solid var(--domain-second-sun);
    border-radius: 0 6px 6px 0;
}

.chronicle-objectives {
    margin-bottom: 16px;
}

.objective-title {
    font-family: 'Rajdhani', sans-serif;
    font-size: 10px;
    font-weight: 700;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 8px;
}

.objective-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 0;
    font-family: 'Rajdhani', sans-serif;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
}

.objective-icon {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(16, 185, 129, 0.2);
    border: 1px solid var(--domain-new-earth);
    border-radius: 4px;
    font-size: 10px;
}

.objective-item.complete .objective-icon {
    background: var(--domain-new-earth);
    color: #fff;
}

/* Campaign Progress Map */
.chronicle-progress {
    display: flex;
    gap: 4px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 6px;
}

.progress-node {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: rgba(50, 40, 70, 0.5);
    border: 2px solid rgba(100, 80, 120, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    color: rgba(255, 255, 255, 0.4);
    transition: all 0.3s ease;
}

.progress-node.complete {
    background: var(--domain-new-earth);
    border-color: var(--domain-new-earth);
    color: #fff;
}

.progress-node.current {
    background: var(--domain-second-sun);
    border-color: var(--domain-second-sun);
    color: #000;
    box-shadow: 0 0 15px var(--domain-second-sun-glow);
    animation: node-pulse 2s ease-in-out infinite;
}

@keyframes node-pulse {
    0%, 100% { box-shadow: 0 0 15px var(--domain-second-sun-glow); }
    50% { box-shadow: 0 0 25px var(--domain-second-sun-glow); }
}

/* ============================================== */
/* TARGETING & INTERACTIONS                       */
/* ============================================== */

.targeting-line {
    position: absolute;
    pointer-events: none;
    z-index: 500;
    stroke-width: 3;
    stroke-linecap: round;
    filter: drop-shadow(0 0 8px currentColor);
}

.targeting-line.domain-second-sun {
    stroke: var(--domain-second-sun);
}

.targeting-line.domain-nullgrid {
    stroke: var(--domain-nullgrid);
}

.targeting-line.domain-new-earth {
    stroke: var(--domain-new-earth);
}

.targeting-line.domain-shattered-sun {
    stroke: var(--domain-shattered-sun);
}

/* Ability Resolve Effect */
.ability-resolve {
    position: absolute;
    inset: 0;
    background: radial-gradient(
        circle at center,
        var(--domain-second-sun-glow) 0%,
        transparent 70%
    );
    animation: ability-resolve-anim 0.8s ease-out forwards;
    pointer-events: none;
}

@keyframes ability-resolve-anim {
    0% { opacity: 0; transform: scale(0.5); }
    30% { opacity: 1; transform: scale(1.2); }
    100% { opacity: 0; transform: scale(1.5); }
}

/* Sigil Display */
.sigil-overlay {
    position: absolute;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    animation: sigil-appear 0.6s ease-out forwards;
    pointer-events: none;
}

@keyframes sigil-appear {
    0% { opacity: 0; transform: scale(0) rotate(-45deg); }
    50% { opacity: 1; transform: scale(1.2) rotate(0deg); }
    100% { opacity: 0; transform: scale(1) rotate(0deg) translateY(-20px); }
}

/* Attack / Damage Effects */
.damage-burst {
    position: absolute;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: damage-burst-anim 0.5s ease-out forwards;
    pointer-events: none;
}

.damage-burst::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(
        circle,
        rgba(239, 68, 68, 0.8) 0%,
        transparent 70%
    );
    animation: burst-expand 0.5s ease-out forwards;
}

@keyframes burst-expand {
    0% { transform: scale(0); opacity: 1; }
    100% { transform: scale(2); opacity: 0; }
}

.crown-shatter {
    position: absolute;
    font-size: 32px;
    animation: crown-shatter-anim 0.8s ease-out forwards;
}

@keyframes crown-shatter-anim {
    0% { opacity: 1; transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.3) rotate(10deg); }
    100% { opacity: 0; transform: scale(0.5) rotate(-20deg) translateY(30px); }
}

/* Essence Flare */
.essence-flare {
    position: absolute;
    width: 80px;
    height: 80px;
    background: 
        radial-gradient(
            circle,
            rgba(255, 215, 0, 0.6) 0%,
            rgba(255, 215, 0, 0.2) 40%,
            transparent 70%
        );
    animation: essence-flare-anim 0.6s ease-out forwards;
    pointer-events: none;
}

@keyframes essence-flare-anim {
    0% { opacity: 0; transform: scale(0.3); }
    40% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(1.5); }
}

/* ============================================== */
/* CARD PHYSICAL APPEARANCE                       */
/* ============================================== */

.ec-physical-card {
    position: relative;
    width: 80px;
    height: 112px;
    background: linear-gradient(135deg, #2a1f4d 0%, #1a1030 100%);
    border: 2px solid rgba(255, 215, 0, 0.5);
    border-radius: 6px;
    overflow: hidden;
    box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    transition: all 0.3s ease;
}

.ec-physical-card:hover {
    transform: var(--card-lift);
    box-shadow: 
        0 12px 30px rgba(0, 0, 0, 0.6),
        0 0 20px var(--domain-second-sun-glow),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.ec-physical-card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: 
        linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.15) 0%,
            transparent 50%,
            rgba(0, 0, 0, 0.15) 100%
        );
    pointer-events: none;
    z-index: 1;
}

/* Card particle border effect */
.ec-physical-card::after {
    content: '';
    position: absolute;
    inset: -2px;
    background: 
        linear-gradient(
            90deg,
            transparent 0%,
            rgba(255, 215, 0, 0.3) 50%,
            transparent 100%
        );
    animation: card-shimmer 3s linear infinite;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.ec-physical-card:hover::after {
    opacity: 1;
}

@keyframes card-shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

/* ============================================== */
/* ESSENCE SHARD TABLETOP DESIGN SYSTEM          */
/* Premium Card-as-UI Components                 */
/* ============================================== */

/* === CARD FRAME COMPONENT === */
/* Use for any content block that should look like a TCG card */
.es-card {
    position: relative;
    background: linear-gradient(
        135deg,
        rgba(20, 15, 35, 0.95) 0%,
        rgba(30, 20, 50, 0.98) 50%,
        rgba(20, 15, 35, 0.95) 100%
    );
    border: 2px solid rgba(212, 175, 55, 0.4);
    border-radius: 12px;
    overflow: hidden;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.es-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.es-card:hover {
    transform: translateY(-6px);
    border-color: var(--gold);
    box-shadow: 
        0 15px 40px rgba(0, 0, 0, 0.5),
        0 0 30px rgba(212, 175, 55, 0.2);
}

.es-card:hover::before {
    opacity: 1;
}

/* Card Header (Title Bar) */
.es-card-header {
    padding: 12px 16px;
    background: linear-gradient(
        135deg,
        rgba(212, 175, 55, 0.15) 0%,
        rgba(107, 33, 168, 0.1) 100%
    );
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
}

.es-card-title {
    font-family: 'Cinzel', serif;
    font-size: 1.1em;
    font-weight: 600;
    color: var(--gold);
    text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    margin: 0;
}

.es-card-badge {
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.75em;
    font-weight: 600;
    background: rgba(100, 100, 150, 0.4);
    color: rgba(255, 255, 255, 0.8);
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Card Body */
.es-card-body {
    padding: 16px;
    color: rgba(255, 255, 255, 0.85);
    font-size: 0.95em;
    line-height: 1.6;
}

/* Card Footer */
.es-card-footer {
    padding: 12px 16px;
    background: rgba(0, 0, 0, 0.2);
    border-top: 1px solid rgba(212, 175, 55, 0.2);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
}

/* Card Icon */
.es-card-icon {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2em;
    margin-bottom: 12px;
}

/* === DOMAIN-COLORED CARDS === */
.es-card[data-domain="second-sun"] { border-color: var(--domain-second-sun); }
.es-card[data-domain="second-sun"]:hover { box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5), 0 0 30px var(--domain-second-sun-glow); }

.es-card[data-domain="nullgrid"] { border-color: var(--domain-nullgrid); }
.es-card[data-domain="nullgrid"]:hover { box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5), 0 0 30px var(--domain-nullgrid-glow); }

.es-card[data-domain="new-earth"] { border-color: var(--domain-new-earth); }
.es-card[data-domain="new-earth"]:hover { box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5), 0 0 30px var(--domain-new-earth-glow); }

.es-card[data-domain="gray-court"] { border-color: var(--domain-gray-court); }
.es-card[data-domain="gray-court"]:hover { box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5), 0 0 30px var(--domain-gray-court-glow); }

.es-card[data-domain="shattered-sun"] { border-color: var(--domain-shattered-sun); }
.es-card[data-domain="shattered-sun"]:hover { box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5), 0 0 30px var(--domain-shattered-sun-glow); }

/* === NAVIGATION HAND OF CARDS === */
.es-nav {
    display: flex;
    align-items: flex-end;
    justify-content: center;
    gap: 4px;
    padding: 10px 20px 0;
    perspective: 1000px;
}

.es-nav-card {
    position: relative;
    padding: 12px 20px;
    background: linear-gradient(
        135deg,
        rgba(30, 20, 50, 0.95) 0%,
        rgba(20, 15, 35, 0.98) 100%
    );
    border: 2px solid rgba(212, 175, 55, 0.3);
    border-radius: 10px 10px 0 0;
    color: rgba(255, 255, 255, 0.8);
    font-family: 'Cinzel', serif;
    font-size: 0.9em;
    font-weight: 600;
    text-decoration: none;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    transform-origin: bottom center;
    transform: rotateX(5deg);
    box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.3);
}

.es-nav-card:hover {
    transform: rotateX(0deg) translateY(-8px);
    border-color: var(--gold);
    color: var(--gold);
    box-shadow: 
        0 -8px 25px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(212, 175, 55, 0.3);
    z-index: 10;
}

.es-nav-card.active {
    background: linear-gradient(
        135deg,
        rgba(212, 175, 55, 0.2) 0%,
        rgba(107, 33, 168, 0.15) 100%
    );
    border-color: var(--gold);
    color: var(--gold);
    transform: rotateX(0deg) translateY(-4px);
}

.es-nav-card::before {
    content: '';
    position: absolute;
    top: -2px;
    left: 50%;
    transform: translateX(-50%);
    width: 60%;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.es-nav-card:hover::before,
.es-nav-card.active::before {
    opacity: 1;
}

.es-nav-icon {
    margin-right: 8px;
    font-size: 1.1em;
}

/* Fan effect for nav cards */
.es-nav-card:nth-child(1) { transform: rotateX(5deg) rotate(-3deg); }
.es-nav-card:nth-child(2) { transform: rotateX(5deg) rotate(-1.5deg); }
.es-nav-card:nth-child(3) { transform: rotateX(5deg) rotate(0deg); }
.es-nav-card:nth-child(4) { transform: rotateX(5deg) rotate(1.5deg); }
.es-nav-card:nth-child(5) { transform: rotateX(5deg) rotate(3deg); }

.es-nav-card:nth-child(1):hover,
.es-nav-card:nth-child(2):hover,
.es-nav-card:nth-child(3):hover,
.es-nav-card:nth-child(4):hover,
.es-nav-card:nth-child(5):hover {
    transform: rotateX(0deg) rotate(0deg) translateY(-10px);
}

/* === GLOW UTILITIES === */
.es-glow-gold {
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
}

.es-glow-violet {
    box-shadow: 0 0 20px rgba(139, 92, 246, 0.4);
}

.es-glow-teal {
    box-shadow: 0 0 20px rgba(20, 244, 255, 0.4);
}

.es-glow-pulse {
    animation: es-glow-pulse 2s ease-in-out infinite;
}

@keyframes es-glow-pulse {
    0%, 100% { box-shadow: 0 0 20px rgba(212, 175, 55, 0.4); }
    50% { box-shadow: 0 0 40px rgba(212, 175, 55, 0.7); }
}

/* === COSMIC TABLETOP BACKGROUND === */
.es-tabletop-bg {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        /* Vignette */
        radial-gradient(
            ellipse at center,
            transparent 0%,
            rgba(0, 0, 0, 0.3) 70%,
            rgba(0, 0, 0, 0.7) 100%
        ),
        /* Shard patterns */
        radial-gradient(
            circle at 20% 30%,
            rgba(139, 92, 246, 0.1) 0%,
            transparent 40%
        ),
        radial-gradient(
            circle at 80% 70%,
            rgba(212, 175, 55, 0.08) 0%,
            transparent 40%
        ),
        radial-gradient(
            circle at 50% 50%,
            rgba(0, 255, 204, 0.05) 0%,
            transparent 50%
        ),
        /* Constellation grid */
        repeating-linear-gradient(
            0deg,
            transparent,
            transparent 100px,
            rgba(255, 215, 0, 0.03) 100px,
            rgba(255, 215, 0, 0.03) 101px
        ),
        repeating-linear-gradient(
            90deg,
            transparent,
            transparent 100px,
            rgba(255, 215, 0, 0.03) 100px,
            rgba(255, 215, 0, 0.03) 101px
        ),
        /* Base */
        linear-gradient(180deg, #0a0515 0%, #120824 50%, #0a0515 100%);
    pointer-events: none;
    z-index: -1;
}

/* === BUTTON CARDS === */
.es-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px 24px;
    background: linear-gradient(
        135deg,
        rgba(30, 20, 50, 0.95) 0%,
        rgba(20, 15, 35, 0.98) 100%
    );
    border: 2px solid rgba(212, 175, 55, 0.4);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.9);
    font-family: 'Cinzel', serif;
    font-size: 0.95em;
    font-weight: 600;
    text-decoration: none;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.es-btn:hover {
    transform: translateY(-3px);
    border-color: var(--gold);
    color: var(--gold);
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(212, 175, 55, 0.3);
}

.es-btn--primary {
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    border-color: var(--gold);
    color: #000;
}

.es-btn--primary:hover {
    background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold) 100%);
    color: #000;
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.4),
        0 0 30px rgba(212, 175, 55, 0.5);
}

/* === HERO CARD (DM Intro Section) === */
.es-hero-card {
    position: relative;
    max-width: 600px;
    margin: 0 auto;
    padding: 40px;
    background: linear-gradient(
        135deg,
        rgba(20, 15, 35, 0.95) 0%,
        rgba(30, 20, 50, 0.98) 50%,
        rgba(20, 15, 35, 0.95) 100%
    );
    border: 3px solid var(--gold);
    border-radius: 16px;
    text-align: center;
    box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 0 40px rgba(212, 175, 55, 0.2),
        inset 0 0 80px rgba(139, 92, 246, 0.1);
}

.es-hero-card::before {
    content: '';
    position: absolute;
    top: -3px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    height: 3px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
}

.es-hero-card::after {
    content: '';
    position: absolute;
    bottom: -3px;
    left: 50%;
    transform: translateX(-50%);
    width: 60%;
    height: 3px;
    background: linear-gradient(90deg, transparent, var(--ec-amethyst), transparent);
}

.es-hero-title {
    font-family: 'Cinzel', serif;
    font-size: 2.5em;
    font-weight: 700;
    color: var(--gold);
    text-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
    margin-bottom: 8px;
}

.es-hero-subtitle {
    font-family: 'Cinzel', serif;
    font-size: 1.3em;
    color: rgba(212, 175, 55, 0.7);
    letter-spacing: 4px;
    margin-bottom: 20px;
}

.es-hero-text {
    color: rgba(255, 255, 255, 0.8);
    font-size: 1.05em;
    line-height: 1.7;
    margin-bottom: 24px;
}

/* === CARD GRID === */
.es-card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    padding: 20px;
}

/* === SCROLL CALLOUT (D&D Style) === */
.es-scroll {
    position: relative;
    padding: 24px 30px;
    background: 
        linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
        linear-gradient(to bottom, rgba(30, 25, 45, 0.95) 0%, rgba(25, 20, 40, 0.98) 100%);
    border: 2px solid rgba(139, 92, 246, 0.4);
    border-radius: 4px;
    margin: 20px 0;
}

.es-scroll::before,
.es-scroll::after {
    content: '‚óÜ';
    position: absolute;
    color: var(--ec-amethyst);
    font-size: 1.2em;
    text-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
}

.es-scroll::before {
    top: -12px;
    left: 20px;
}

.es-scroll::after {
    bottom: -12px;
    right: 20px;
}

.es-scroll-title {
    font-family: 'Cinzel', serif;
    font-size: 1.1em;
    color: var(--ec-amethyst);
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 2px;
}

/* === TYPOGRAPHY === */
.es-heading-1 {
    font-family: 'Cinzel', serif;
    font-size: 2.5em;
    font-weight: 700;
    color: var(--gold);
    text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
    margin-bottom: 16px;
}

.es-heading-2 {
    font-family: 'Cinzel', serif;
    font-size: 1.8em;
    font-weight: 600;
    color: var(--gold);
    margin-bottom: 12px;
}

.es-heading-3 {
    font-family: 'Cinzel', serif;
    font-size: 1.3em;
    font-weight: 600;
    color: var(--gold);
    margin-bottom: 8px;
}

.es-text {
    color: rgba(255, 255, 255, 0.85);
    font-size: 1em;
    line-height: 1.6;
}

.es-text-muted {
    color: rgba(255, 255, 255, 0.5);
    font-size: 0.9em;
}

/* === ASPECT BADGES === */
.es-aspect-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.8em;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.es-aspect-badge--glow {
    background: linear-gradient(135deg, var(--aspect-glow), #e6a915);
    color: #000;
}

.es-aspect-badge--void {
    background: linear-gradient(135deg, var(--aspect-void), #5b21b6);
    color: #fff;
}

.es-aspect-badge--gray {
    background: linear-gradient(135deg, var(--aspect-gray), #6b7280);
    color: #fff;
}

.es-aspect-badge--beast {
    background: linear-gradient(135deg, var(--aspect-beast), #047857);
    color: #fff;
}

/* === RESPONSIVE ADJUSTMENTS === */
@media (max-width: 900px) {
    .es-nav {
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .es-nav-card {
        padding: 10px 16px;
        font-size: 0.85em;
        transform: none !important;
    }
    
    .es-nav-card:hover {
        transform: translateY(-6px) !important;
    }
    
    .es-hero-card {
        padding: 30px 20px;
        margin: 0 10px;
    }
    
    .es-hero-title {
        font-size: 1.8em;
    }
    
    .es-heading-1 {
        font-size: 2em;
    }
}

@media (max-width: 600px) {
    .es-card-grid {
        grid-template-columns: 1fr;
        gap: 15px;
        padding: 15px;
    }
    
    .es-card-header {
        padding: 10px 12px;
    }
    
    .es-card-body {
        padding: 12px;
    }
    
    .es-btn {
        padding: 10px 18px;
        font-size: 0.9em;
    }
}

/* ============================================== */
/* FINAL POLISH - ANIMATIONS & PARTICLES          */
/* ============================================== */

/* Floating Particle Effect */
@keyframes es-float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.es-float {
    animation: es-float 3s ease-in-out infinite;
}

/* Sparkle Animation */
@keyframes es-sparkle {
    0%, 100% { opacity: 0.3; transform: scale(0.8); }
    50% { opacity: 1; transform: scale(1.2); }
}

.es-sparkle {
    animation: es-sparkle 2s ease-in-out infinite;
}

/* Card Shimmer Effect */
@keyframes es-shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
}

.es-shimmer::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.08) 50%,
        transparent 100%
    );
    background-size: 200% 100%;
    animation: es-shimmer 3s linear infinite;
    pointer-events: none;
}

/* Domain Pulse Effects */
@keyframes es-domain-pulse-gold {
    0%, 100% { box-shadow: 0 0 20px rgba(212, 175, 55, 0.3); }
    50% { box-shadow: 0 0 40px rgba(212, 175, 55, 0.6); }
}

@keyframes es-domain-pulse-violet {
    0%, 100% { box-shadow: 0 0 20px rgba(139, 92, 246, 0.3); }
    50% { box-shadow: 0 0 40px rgba(139, 92, 246, 0.6); }
}

@keyframes es-domain-pulse-teal {
    0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 204, 0.3); }
    50% { box-shadow: 0 0 40px rgba(0, 255, 204, 0.6); }
}

.es-pulse-gold { animation: es-domain-pulse-gold 2s ease-in-out infinite; }
.es-pulse-violet { animation: es-domain-pulse-violet 2s ease-in-out infinite; }
.es-pulse-teal { animation: es-domain-pulse-teal 2s ease-in-out infinite; }

/* Card Entrance Animation */
@keyframes es-card-enter {
    0% { 
        opacity: 0; 
        transform: translateY(30px) scale(0.9); 
    }
    100% { 
        opacity: 1; 
        transform: translateY(0) scale(1); 
    }
}

.es-card-enter {
    animation: es-card-enter 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

/* Victory/Crown Glow */
@keyframes es-crown-glow {
    0%, 100% { 
        filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.5));
    }
    50% { 
        filter: drop-shadow(0 0 30px rgba(212, 175, 55, 0.9));
    }
}

.es-crown-glow {
    animation: es-crown-glow 1.5s ease-in-out infinite;
}

/* Shard Collect Animation */
@keyframes es-shard-collect {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.3); opacity: 0.8; }
    100% { transform: scale(0); opacity: 0; }
}

.es-shard-collect {
    animation: es-shard-collect 0.6s ease-out forwards;
}

/* Border Gradient Animation */
@keyframes es-border-flow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.es-border-animated {
    background: linear-gradient(
        90deg,
        var(--gold),
        var(--ec-amethyst),
        var(--ec-teal),
        var(--gold)
    );
    background-size: 300% 100%;
    animation: es-border-flow 4s ease infinite;
}

/* Hover Lift Utility */
.es-lift {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.es-lift:hover {
    transform: translateY(-6px);
}

/* Scale on Hover */
.es-scale {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.es-scale:hover {
    transform: scale(1.05);
}

/* Premium Focus Ring */
.es-focus:focus {
    outline: none;
    box-shadow: 
        0 0 0 3px rgba(212, 175, 55, 0.4),
        0 0 20px rgba(212, 175, 55, 0.3);
}

/* Rarity Glow Effects */
.es-rarity-common { border-color: #94a3b8; }
.es-rarity-rare { 
    border-color: #60a5fa; 
    box-shadow: 0 0 15px rgba(96, 165, 250, 0.3);
}
.es-rarity-epic { 
    border-color: #a855f7; 
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.4);
}
.es-rarity-legendary { 
    border-color: var(--gold); 
    box-shadow: 0 0 25px rgba(212, 175, 55, 0.5);
}
.es-rarity-mythic { 
    border-color: #f97316;
    box-shadow: 0 0 30px rgba(249, 115, 22, 0.5);
    animation: es-glow-pulse 2s ease-in-out infinite;
}

/* ============================================== */
/* PREMIUM BATTLE SCREEN REDESIGN                 */
/* Cards-First, Immersive Combat Experience       */
/* ============================================== */

/* === COLLAPSE SIDE PANELS - ARENA TAKES FULL WIDTH === */
.ec-main {
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 0 !important;
    padding: 0 !important;
}

.ec-side-panels {
    position: fixed !important;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 60px !important;
    z-index: 200;
    flex-direction: column !important;
    gap: 8px !important;
    background: transparent !important;
}

/* Hide Codex by default - Chronicle becomes collapsible */
.ec-panel--codex {
    display: none !important;
}

/* Chronicle Panel - Collapsible Log */
.ec-panel--chronicle {
    position: fixed !important;
    bottom: 180px !important;
    right: 80px !important;
    width: 320px !important;
    max-height: 350px !important;
    background: rgba(10, 5, 25, 0.98) !important;
    border: 2px solid var(--ec-gold) !important;
    border-radius: 12px !important;
    transform: translateX(400px);
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 180;
    overflow: hidden;
}

.ec-panel--chronicle.open {
    transform: translateX(0);
    opacity: 1;
}

.ec-panel--chronicle .ec-panel-header {
    padding: 10px 14px !important;
    background: linear-gradient(90deg, rgba(212, 175, 55, 0.2) 0%, transparent 100%) !important;
    cursor: pointer;
}

.ec-panel--chronicle .ec-chronicle-body {
    max-height: 280px;
    overflow-y: auto;
    font-size: 11px !important;
}

/* Actions panel becomes floating mini-toolbar */
.ec-panel--actions {
    position: fixed !important;
    right: 15px !important;
    top: 50% !important;
    transform: translateY(-50%) !important;
    width: auto !important;
    background: rgba(10, 5, 25, 0.95) !important;
    border: 2px solid var(--ec-gold) !important;
    border-radius: 16px !important;
    padding: 12px !important;
    box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
    z-index: 190;
}

.ec-panel--actions #turn-controls {
    flex-direction: column !important;
    gap: 8px !important;
}

/* Show log toggle button in side panel */
.ec-panel--actions #side-panel {
    display: flex !important;
    flex-direction: column !important;
    gap: 6px !important;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(212, 175, 55, 0.3);
}

.ec-panel--actions .panel-btn {
    width: 40px !important;
    height: 40px !important;
    border-radius: 50% !important;
    background: linear-gradient(135deg, rgba(30, 15, 50, 0.95) 0%, rgba(15, 5, 30, 0.95) 100%) !important;
    border: 2px solid rgba(212, 175, 55, 0.5) !important;
    color: var(--ec-gold) !important;
    font-size: 16px !important;
    cursor: pointer;
    transition: all 0.3s ease;
}

.ec-panel--actions .panel-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
    border-color: var(--ec-gold) !important;
}

.ec-panel--actions .turn-btn {
    padding: 10px 16px !important;
    font-size: 11px !important;
    font-weight: 700 !important;
    border-radius: 10px !important;
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.3) 0%, rgba(139, 0, 0, 0.5) 100%) !important;
    border: 2px solid var(--ec-gold) !important;
    color: #fff !important;
    text-transform: uppercase !important;
    letter-spacing: 1px !important;
    cursor: pointer;
    transition: all 0.3s ease;
}

.ec-panel--actions .turn-btn:hover {
    background: linear-gradient(135deg, rgba(212, 175, 55, 0.6) 0%, rgba(139, 0, 0, 0.8) 100%) !important;
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
}

/* === ARENA TAKES FULL SCREEN === */
.ec-arena {
    width: 100% !important;
    max-width: none !important;
    padding: 20px 40px !important;
}

.ec-arena-content {
    max-width: 1200px;
    margin: 0 auto;
}

/* === PREMIUM CARD STYLING FOR BATTLEFIELD === */
.ec-card-slot {
    width: clamp(90px, 8vw, 120px) !important;
    height: clamp(126px, 11.2vw, 168px) !important;
    background: radial-gradient(ellipse at center, rgba(139, 92, 246, 0.1) 0%, rgba(10, 5, 20, 0.6) 100%) !important;
    border: 2px dashed rgba(139, 92, 246, 0.3) !important;
    border-radius: 10px !important;
    transition: all 0.3s ease !important;
    position: relative;
}

.ec-card-slot::before {
    content: '';
    position: absolute;
    inset: -4px;
    border-radius: 14px;
    background: linear-gradient(45deg, transparent 30%, rgba(212, 175, 55, 0.2) 50%, transparent 70%);
    background-size: 200% 200%;
    animation: slot-shimmer 3s ease-in-out infinite;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

.ec-card-slot:hover::before {
    opacity: 1;
}

@keyframes slot-shimmer {
    0%, 100% { background-position: 200% 200%; }
    50% { background-position: 0% 0%; }
}

.ec-card-slot.active {
    border-style: solid !important;
    border-color: rgba(212, 175, 55, 0.5) !important;
    box-shadow: 
        0 0 20px rgba(139, 92, 246, 0.3),
        inset 0 0 30px rgba(139, 92, 246, 0.1);
}

.ec-card-slot.legal-play {
    border-color: var(--ec-teal) !important;
    box-shadow: 0 0 25px rgba(0, 255, 204, 0.5) !important;
    animation: legal-pulse 1.5s ease-in-out infinite;
}

@keyframes legal-pulse {
    0%, 100% { box-shadow: 0 0 25px rgba(0, 255, 204, 0.3); }
    50% { box-shadow: 0 0 40px rgba(0, 255, 204, 0.7); }
}

/* === GAME CARDS - PREMIUM POKEMON-LEVEL VISUALS === */
.game-card {
    width: clamp(85px, 7.5vw, 115px) !important;
    height: clamp(119px, 10.5vw, 161px) !important;
    border-radius: 10px !important;
    position: relative !important;
    cursor: pointer !important;
    transform-style: preserve-3d !important;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;
    z-index: 1;
}

.game-card .card-front {
    width: 100% !important;
    height: 100% !important;
    border-radius: 10px !important;
    overflow: hidden !important;
    border: 3px solid #8b7355 !important;
    background: linear-gradient(135deg, #1a0a30 0%, #0a0515 100%) !important;
    position: relative !important;
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.6),
        0 0 0 1px rgba(255, 215, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
}

/* Card Image - Premium Display */
.game-card .card-image {
    width: 100% !important;
    height: 60% !important;
    object-fit: cover !important;
    border-bottom: 2px solid rgba(139, 92, 246, 0.3);
}

/* Card Info Panel */
.game-card .card-info {
    position: absolute !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.95) 40%) !important;
    padding: 25px 6px 6px !important;
}

/* Card Name - Crisp and Readable */
.game-card .card-name {
    font-family: 'Cinzel', serif !important;
    font-size: clamp(7px, 0.65vw, 10px) !important;
    font-weight: 700 !important;
    color: #fff !important;
    text-align: center !important;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8) !important;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    letter-spacing: 0.5px;
}

/* Card Cost Badge - Top Left */
.game-card .card-cost {
    position: absolute !important;
    top: 5px !important;
    left: 5px !important;
    width: 26px !important;
    height: 26px !important;
    border-radius: 50% !important;
    background: linear-gradient(135deg, #8b5cf6 0%, #4c1d95 100%) !important;
    border: 2px solid #ffd700 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-family: 'Rajdhani', sans-serif !important;
    font-size: 13px !important;
    font-weight: 700 !important;
    color: #fff !important;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8) !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    z-index: 10;
}

/* Card Stats - Power & Guard */
.game-card .card-stats {
    display: flex !important;
    justify-content: space-between !important;
    margin-top: 4px !important;
    gap: 4px;
}

.game-card .stat {
    font-family: 'Rajdhani', sans-serif !important;
    font-size: 11px !important;
    font-weight: 700 !important;
    padding: 2px 6px !important;
    border-radius: 4px !important;
    min-width: 28px;
    text-align: center;
}

.game-card .stat.attack {
    background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%) !important;
    color: #fff !important;
    border: 1px solid #fca5a5;
    box-shadow: 0 2px 6px rgba(239, 68, 68, 0.4);
}

.game-card .stat.health {
    background: linear-gradient(135deg, #22c55e 0%, #15803d 100%) !important;
    color: #fff !important;
    border: 1px solid #86efac;
    box-shadow: 0 2px 6px rgba(34, 197, 94, 0.4);
}

/* === CARD HOVER EFFECTS - DRAMATIC LIFT === */
.game-card:hover {
    transform: translateY(-15px) scale(1.15) !important;
    z-index: 100 !important;
}

.game-card:hover .card-front {
    box-shadow: 
        0 20px 50px rgba(0, 0, 0, 0.7),
        0 0 40px rgba(212, 175, 55, 0.5),
        0 0 60px rgba(139, 92, 246, 0.3) !important;
    border-color: var(--ec-gold) !important;
}

/* === ASPECT GLOW EFFECTS - VIBRANT DOMAIN COLORS === */
.game-card.glow .card-front {
    border-color: #ffd700 !important;
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.6),
        0 0 30px rgba(255, 215, 0, 0.6),
        0 0 50px rgba(255, 215, 0, 0.3),
        inset 0 0 15px rgba(255, 215, 0, 0.2) !important;
}

.game-card.void .card-front {
    border-color: #a855f7 !important;
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.6),
        0 0 30px rgba(168, 85, 247, 0.6),
        0 0 50px rgba(168, 85, 247, 0.3),
        inset 0 0 15px rgba(168, 85, 247, 0.2) !important;
}

.game-card.gray .card-front {
    border-color: #94a3b8 !important;
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.6),
        0 0 30px rgba(148, 163, 184, 0.4),
        0 0 50px rgba(148, 163, 184, 0.2),
        inset 0 0 15px rgba(148, 163, 184, 0.1) !important;
}

.game-card.beast .card-front {
    border-color: #22c55e !important;
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.6),
        0 0 30px rgba(34, 197, 94, 0.6),
        0 0 50px rgba(34, 197, 94, 0.3),
        inset 0 0 15px rgba(34, 197, 94, 0.2) !important;
}

/* === COMBAT STATE EFFECTS === */
.game-card.selected-attacker {
    animation: attacker-pulse 0.8s ease-in-out infinite !important;
}

.game-card.selected-attacker .card-front {
    border-color: #ef4444 !important;
    box-shadow: 
        0 0 40px rgba(239, 68, 68, 0.8),
        0 0 60px rgba(239, 68, 68, 0.4) !important;
}

@keyframes attacker-pulse {
    0%, 100% { transform: scale(1.05); }
    50% { transform: scale(1.1); }
}

.game-card.valid-target {
    animation: target-glow 1s ease-in-out infinite !important;
}

.game-card.valid-target .card-front {
    border-color: var(--ec-teal) !important;
}

@keyframes target-glow {
    0%, 100% { box-shadow: 0 0 25px rgba(0, 255, 204, 0.4); }
    50% { box-shadow: 0 0 50px rgba(0, 255, 204, 0.8); }
}

.game-card.legal-play {
    animation: playable-hint 2s ease-in-out infinite !important;
}

@keyframes playable-hint {
    0%, 100% { box-shadow: 0 0 15px rgba(212, 175, 55, 0.3); }
    50% { box-shadow: 0 0 30px rgba(212, 175, 55, 0.7); }
}

/* === GUARDIAN BADGE === */
.game-card .guardian-badge {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    border: 2px solid #93c5fd;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
}

/* === HAND BAR - DRAMATIC CARD DISPLAY === */
.ec-hand-bar {
    background: 
        linear-gradient(0deg, rgba(5, 0, 18, 0.98) 0%, rgba(15, 5, 35, 0.95) 100%) !important;
    border-top: 3px solid var(--ec-gold) !important;
    padding: 16px 30px 24px !important;
    position: relative;
    z-index: 50;
    box-shadow: 
        0 -8px 40px rgba(0, 0, 0, 0.6),
        inset 0 2px 0 rgba(212, 175, 55, 0.2) !important;
}

.ec-hand-bar::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 100%;
    background: radial-gradient(ellipse at 50% 0%, rgba(212, 175, 55, 0.1) 0%, transparent 60%);
    pointer-events: none;
}

.ec-hand-cards {
    min-height: 150px !important;
    gap: 0 !important;
    padding: 15px 40px !important;
    perspective: 1500px;
}

/* Hand Cards - Large & Interactive */
.ec-hand-cards .game-card {
    width: 100px !important;
    min-width: 100px !important;
    height: 140px !important;
    margin: 0 -12px !important;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;
    transform-origin: bottom center !important;
}

.ec-hand-cards .game-card:hover {
    transform: translateY(-40px) scale(1.25) rotate(0deg) !important;
    z-index: 150 !important;
    margin: 0 15px !important;
}

.ec-hand-cards .game-card:hover .card-front {
    box-shadow: 
        0 25px 60px rgba(0, 0, 0, 0.8),
        0 0 50px rgba(212, 175, 55, 0.6),
        0 0 80px rgba(139, 92, 246, 0.4) !important;
}

/* Fan effect for hand cards */
.ec-hand-cards .game-card:nth-child(1) { transform: rotate(-8deg); }
.ec-hand-cards .game-card:nth-child(2) { transform: rotate(-4deg); }
.ec-hand-cards .game-card:nth-child(3) { transform: rotate(0deg); }
.ec-hand-cards .game-card:nth-child(4) { transform: rotate(4deg); }
.ec-hand-cards .game-card:nth-child(5) { transform: rotate(8deg); }
.ec-hand-cards .game-card:nth-child(6) { transform: rotate(10deg); }
.ec-hand-cards .game-card:nth-child(7) { transform: rotate(12deg); }

/* === ZONE LABELS - SUBTLE === */
.zone-label {
    font-size: 9px !important;
    color: rgba(255, 255, 255, 0.3) !important;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 6px;
}

/* === FIELD ROW STYLING === */
.ec-field-row {
    display: flex !important;
    flex-direction: column !important;
    gap: 12px !important;
    padding: 10px 0 !important;
}

.ec-zone-body {
    display: flex !important;
    gap: clamp(8px, 1.5vw, 16px) !important;
    justify-content: center !important;
    padding: 8px !important;
}

/* Avatar Row - Main Combat Zone */
.avatar-row {
    display: flex !important;
    gap: clamp(12px, 2vw, 24px) !important;
    justify-content: center !important;
    padding: 15px !important;
    background: radial-gradient(ellipse at center, rgba(239, 68, 68, 0.08) 0%, transparent 70%) !important;
    border-radius: 12px;
    min-height: 180px;
}

/* === ACTIVE DOMAIN ZONE - BATTLEFIELD CENTER === */
.ec-domain-zone {
    text-align: center !important;
    padding: 20px !important;
    margin: 15px 0 !important;
    background: 
        radial-gradient(ellipse at center, rgba(212, 175, 55, 0.15) 0%, transparent 60%),
        linear-gradient(90deg, transparent 0%, rgba(139, 92, 246, 0.1) 50%, transparent 100%) !important;
    border-top: 1px solid rgba(212, 175, 55, 0.3);
    border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    position: relative;
}

.ec-domain-zone::before,
.ec-domain-zone::after {
    content: '‚óÜ';
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    color: rgba(212, 175, 55, 0.4);
    font-size: 24px;
}

.ec-domain-zone::before { left: 20px; }
.ec-domain-zone::after { right: 20px; }

.ec-domain-name {
    font-family: 'Cinzel', serif !important;
    font-size: 28px !important;
    font-weight: 700 !important;
    color: var(--ec-gold) !important;
    text-shadow: 
        0 0 20px rgba(212, 175, 55, 0.6),
        0 0 40px rgba(212, 175, 55, 0.3) !important;
    animation: domain-name-glow 3s ease-in-out infinite;
}

@keyframes domain-name-glow {
    0%, 100% { text-shadow: 0 0 20px rgba(212, 175, 55, 0.4), 0 0 40px rgba(212, 175, 55, 0.2); }
    50% { text-shadow: 0 0 30px rgba(212, 175, 55, 0.7), 0 0 60px rgba(212, 175, 55, 0.4); }
}

/* === ATTACK ANIMATIONS === */
@keyframes card-attack {
    0% { transform: translateX(0) scale(1); }
    30% { transform: translateX(50px) scale(1.1); }
    50% { transform: translateX(80px) scale(1.15); }
    70% { transform: translateX(50px) scale(1.05); }
    100% { transform: translateX(0) scale(1); }
}

.game-card.attacking {
    animation: card-attack 0.6s ease-out forwards !important;
    z-index: 200 !important;
}

@keyframes card-damage {
    0%, 100% { filter: brightness(1); }
    25% { filter: brightness(0.5) saturate(2); transform: translateX(-5px); }
    50% { filter: brightness(1.5) saturate(1.5); transform: translateX(5px); }
    75% { filter: brightness(0.7); transform: translateX(-3px); }
}

.game-card.taking-damage {
    animation: card-damage 0.4s ease-out !important;
}

@keyframes card-destroy {
    0% { opacity: 1; transform: scale(1) rotate(0deg); }
    50% { opacity: 0.8; transform: scale(1.1) rotate(5deg); filter: brightness(2); }
    100% { opacity: 0; transform: scale(0.5) rotate(-15deg) translateY(50px); }
}

.game-card.destroying {
    animation: card-destroy 0.8s ease-out forwards !important;
}

/* === FLOATING LOG TOGGLE (REPLACES CHRONICLE) === */
.log-toggle-btn {
    position: fixed;
    bottom: 200px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: linear-gradient(135deg, rgba(15, 5, 30, 0.95) 0%, rgba(30, 15, 50, 0.95) 100%);
    border: 2px solid var(--ec-gold);
    color: var(--ec-gold);
    font-size: 20px;
    cursor: pointer;
    z-index: 200;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    transition: all 0.3s ease;
}

.log-toggle-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 0 25px rgba(212, 175, 55, 0.5);
}

.log-drawer {
    position: fixed;
    bottom: 200px;
    right: 80px;
    width: 300px;
    max-height: 400px;
    background: rgba(10, 5, 25, 0.98);
    border: 2px solid var(--ec-gold);
    border-radius: 12px;
    overflow: hidden;
    transform: translateX(350px);
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 199;
}

.log-drawer.open {
    transform: translateX(0);
    opacity: 1;
}

/* === COMPACT HUD STYLING === */
.ec-hud {
    padding: 10px 20px !important;
}

.deity-ring {
    width: 70px !important;
    height: 70px !important;
}

.essence-counter {
    width: 50px !important;
    height: 50px !important;
}

.essence-value {
    font-size: 20px !important;
}

/* === DECK & FRACTURE ZONES === */
.ec-deck-fracture-zones {
    position: absolute !important;
    left: 20px !important;
    bottom: 20px !important;
    display: flex !important;
    gap: 15px !important;
}

.deck-zone {
    width: 80px !important;
    height: 112px !important;
}

.deck-card-back {
    border: 3px solid var(--ec-gold) !important;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6) !important;
}

.fracture-zone {
    width: 80px !important;
    height: 112px !important;
}

/* === RESPONSIVE ADJUSTMENTS === */
@media (max-width: 1200px) {
    .ec-hand-cards .game-card {
        width: 85px !important;
        min-width: 85px !important;
        height: 119px !important;
        margin: 0 -10px !important;
    }
    
    .ec-card-slot {
        width: clamp(75px, 7vw, 100px) !important;
        height: clamp(105px, 9.8vw, 140px) !important;
    }
}

@media (max-width: 900px) {
    .ec-side-panels {
        display: none !important;
    }
    
    .ec-hand-cards .game-card {
        width: 70px !important;
        min-width: 70px !important;
        height: 98px !important;
    }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
/* OFFICIAL PLAYMAT LAYOUT - Matching Physical Playmat Design                   */
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

.ec-playmat {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    background: 
        radial-gradient(ellipse at 30% 20%, rgba(30, 58, 95, 0.6) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(45, 30, 80, 0.5) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(25, 35, 55, 0.8) 0%, transparent 70%),
        linear-gradient(180deg, 
            #0d1929 0%, 
            #152238 15%,
            #1a2d4a 30%,
            #1e3654 50%,
            #1a2d4a 70%,
            #152238 85%,
            #0d1929 100%
        );
    overflow: hidden;
    padding: 8px;
    box-sizing: border-box;
}

/* Playmat Halves - Player and Opponent */
.playmat-half {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
    padding: 6px 10px;
}

.playmat-half--opponent {
    transform: rotate(180deg);
}

.playmat-half--opponent .zone-label-plate,
.playmat-half--opponent .slot-label,
.playmat-half--opponent .zone-subtext,
.playmat-half--opponent .rules-text {
    transform: rotate(180deg);
}

/* Playmat Rows */
.playmat-row {
    display: flex;
    gap: 8px;
    justify-content: center;
    align-items: stretch;
}

.playmat-row--status {
    flex: 0 0 auto;
    min-height: 90px;
}

.playmat-row--resource {
    flex: 0 0 auto;
    min-height: 75px;
}

.playmat-row--avatars,
.playmat-row--relics {
    flex: 1;
    min-height: 100px;
}

/* Playmat Zones - Base Styling */
.playmat-zone {
    position: relative;
    background: rgba(20, 35, 60, 0.7);
    border: 2px solid rgba(100, 130, 170, 0.4);
    border-radius: 12px;
    padding: 6px 10px;
    display: flex;
    flex-direction: column;
    transition: all 0.3s ease;
}

.playmat-zone:hover {
    border-color: rgba(140, 170, 210, 0.6);
    background: rgba(25, 45, 75, 0.8);
}

/* Zone Label Plates - Engraved Look */
.zone-label-plate {
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(180deg, rgba(40, 60, 90, 0.95) 0%, rgba(25, 40, 65, 0.95) 100%);
    border: 1px solid rgba(100, 140, 180, 0.5);
    border-radius: 8px;
    padding: 2px 12px;
    font-family: 'Cinzel', serif;
    font-size: 9px;
    font-weight: 600;
    color: rgba(180, 200, 220, 0.9);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    white-space: nowrap;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        0 2px 4px rgba(0, 0, 0, 0.3);
}

.zone-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    margin-top: 8px;
}

.zone-subtext {
    font-family: 'Rajdhani', sans-serif;
    font-size: 8px;
    color: rgba(140, 160, 180, 0.6);
    text-align: center;
    margin-top: 4px;
}

/* Slot Labels inside card slots */
.slot-label {
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Rajdhani', sans-serif;
    font-size: 8px;
    font-weight: 500;
    color: rgba(120, 150, 180, 0.5);
    text-transform: uppercase;
    letter-spacing: 0.3px;
    pointer-events: none;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
/* SPECIFIC ZONE TYPES                                                          */
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

/* Status Zone */
.zone-status {
    flex: 0 0 140px;
    background: rgba(30, 45, 70, 0.6);
    border-color: rgba(80, 120, 160, 0.4);
}

/* Essence Zone */
.zone-essence {
    flex: 1;
    max-width: 200px;
    background: linear-gradient(135deg, rgba(35, 50, 80, 0.7) 0%, rgba(25, 40, 65, 0.7) 100%);
    border-color: rgba(100, 150, 200, 0.5);
}

.essence-display {
    flex-direction: column;
    gap: 2px;
}

.essence-glyph-large {
    font-size: 24px;
    color: rgba(180, 200, 220, 0.8);
    text-shadow: 0 0 10px rgba(100, 150, 200, 0.5);
}

.essence-number {
    font-family: 'Cinzel', serif;
    font-size: 28px;
    font-weight: 700;
    color: #e0e8f0;
    text-shadow: 0 0 15px rgba(100, 150, 200, 0.6);
}

/* Deity Zone */
.zone-deity {
    flex: 0 0 160px;
    background: linear-gradient(135deg, rgba(50, 40, 70, 0.7) 0%, rgba(35, 30, 55, 0.7) 100%);
    border-color: rgba(180, 140, 200, 0.4);
}

.deity-card-slot {
    width: 70px;
    height: 98px;
    background: rgba(60, 45, 85, 0.5);
    border: 2px dashed rgba(180, 140, 200, 0.4);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Void/Exile Zone */
.zone-void {
    flex: 0 0 80px;
    background: rgba(20, 25, 35, 0.8);
    border-color: rgba(60, 70, 90, 0.5);
}

/* Abyss Zone */
.zone-abyss {
    flex: 0 0 80px;
    background: rgba(15, 20, 30, 0.8);
    border-color: rgba(50, 60, 80, 0.5);
}

.pile-slot {
    width: 55px;
    height: 77px;
    background: rgba(30, 35, 50, 0.6);
    border: 2px solid rgba(70, 80, 100, 0.4);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.pile-slot:hover {
    border-color: rgba(100, 120, 150, 0.6);
    box-shadow: 0 0 10px rgba(80, 100, 130, 0.3);
}

/* Domains Zone */
.zone-domains {
    flex: 1;
    background: rgba(25, 40, 60, 0.6);
    border-color: rgba(90, 130, 170, 0.4);
}

.domain-slots {
    display: flex;
    gap: 8px;
    justify-content: center;
}

.domain-slot {
    position: relative;
    width: clamp(55px, 6vw, 75px);
    height: clamp(77px, 8.4vw, 105px);
    background: rgba(35, 55, 85, 0.5);
    border: 2px solid rgba(80, 120, 160, 0.4);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    cursor: pointer;
}

.domain-slot:hover {
    border-color: rgba(120, 160, 200, 0.6);
    background: rgba(45, 70, 105, 0.6);
    box-shadow: 0 0 15px rgba(80, 130, 180, 0.3);
}

/* Deck Zone */
.zone-deck {
    flex: 0 0 90px;
    background: rgba(25, 35, 55, 0.7);
    border-color: rgba(100, 130, 170, 0.4);
}

.deck-pile {
    position: relative;
    width: 55px;
    height: 77px;
    cursor: pointer;
}

.deck-cards-stack {
    position: absolute;
    inset: 0;
    background: 
        linear-gradient(135deg, #2a3a55 0%, #1e2b40 100%);
    border: 2px solid rgba(100, 140, 180, 0.5);
    border-radius: 6px;
    box-shadow: 
        2px 2px 0 rgba(30, 45, 70, 0.8),
        4px 4px 0 rgba(25, 38, 60, 0.6),
        6px 6px 0 rgba(20, 32, 50, 0.4);
}

.deck-count {
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(30, 50, 80, 0.95);
    border: 1px solid rgba(100, 140, 180, 0.5);
    border-radius: 10px;
    padding: 1px 8px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 11px;
    font-weight: 600;
    color: #d0dce8;
    z-index: 5;
}

.deck-stack-card {
    position: absolute;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #3a4a65 0%, #2a3a50 100%);
    border: 1px solid rgba(120, 150, 180, 0.4);
    border-radius: 5px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.deck-pile:hover .deck-cards-stack {
    box-shadow: 
        2px 2px 0 rgba(30, 45, 70, 0.8),
        4px 4px 0 rgba(25, 38, 60, 0.6),
        6px 6px 0 rgba(20, 32, 50, 0.4),
        0 0 20px rgba(100, 150, 200, 0.4);
}

/* Avatar/Relic Zones */
.zone-avatars,
.zone-relics {
    flex: 1;
    background: rgba(25, 40, 65, 0.6);
    border-color: rgba(90, 130, 170, 0.4);
}

.avatar-slots,
.relic-slots {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.avatar-slot,
.relic-slot {
    position: relative;
    width: clamp(65px, 7vw, 90px);
    height: clamp(91px, 9.8vw, 126px);
    background: rgba(35, 55, 85, 0.4);
    border: 2px solid rgba(80, 120, 160, 0.35);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    cursor: pointer;
}

.avatar-slot:hover,
.relic-slot:hover {
    border-color: rgba(120, 170, 220, 0.6);
    background: rgba(45, 70, 105, 0.5);
    box-shadow: 0 0 20px rgba(80, 140, 200, 0.25);
    transform: translateY(-3px);
}

.relic-slot {
    height: clamp(75px, 8vw, 100px);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
/* CENTER BANNER                                                                */
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

.playmat-center-banner {
    flex: 0 0 auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px 20px;
    background: 
        linear-gradient(90deg, 
            transparent 0%, 
            rgba(30, 50, 80, 0.6) 20%, 
            rgba(40, 65, 100, 0.7) 50%, 
            rgba(30, 50, 80, 0.6) 80%, 
            transparent 100%
        );
    border-top: 1px solid rgba(100, 150, 200, 0.3);
    border-bottom: 1px solid rgba(100, 150, 200, 0.3);
}

.banner-title {
    font-family: 'Cinzel', serif;
    font-size: clamp(14px, 2vw, 22px);
    font-weight: 700;
    color: rgba(200, 220, 240, 0.95);
    text-transform: uppercase;
    letter-spacing: 3px;
    text-shadow: 
        0 0 20px rgba(100, 150, 200, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.5);
}

.banner-subtitle {
    font-family: 'Rajdhani', sans-serif;
    font-size: clamp(10px, 1.2vw, 14px);
    color: rgba(150, 180, 210, 0.8);
    letter-spacing: 1px;
    margin-top: 2px;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
/* RULES TEXT                                                                   */
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

.playmat-rules {
    flex: 0 0 auto;
    padding: 4px 15px;
    background: rgba(20, 35, 55, 0.5);
    border-radius: 8px;
    margin: 4px auto;
    max-width: 500px;
}

.rules-text {
    font-family: 'Rajdhani', sans-serif;
    font-size: 9px;
    color: rgba(140, 170, 200, 0.7);
    line-height: 1.4;
    text-align: center;
}

.rules-text strong {
    color: rgba(180, 200, 220, 0.9);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
/* SIDE PANELS - FLOATING OVERLAYS                                              */
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

.ec-side-panels {
    position: fixed !important;
    right: 10px !important;
    top: 50% !important;
    transform: translateY(-50%) !important;
    width: auto !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 8px !important;
    z-index: 200 !important;
    background: transparent !important;
}

.ec-panel--codex {
    display: none !important;
}

.ec-panel--chronicle {
    position: fixed !important;
    bottom: 120px !important;
    right: 70px !important;
    width: 280px !important;
    max-height: 300px !important;
    background: rgba(15, 25, 45, 0.97) !important;
    border: 2px solid rgba(100, 150, 200, 0.5) !important;
    border-radius: 12px !important;
    transform: translateX(350px);
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 180;
    overflow: hidden;
}

.ec-panel--chronicle.open {
    transform: translateX(0);
    opacity: 1;
}

.ec-panel--actions {
    position: fixed !important;
    right: 10px !important;
    top: 50% !important;
    transform: translateY(-50%) !important;
    width: auto !important;
    background: rgba(20, 35, 60, 0.95) !important;
    border: 2px solid rgba(100, 150, 200, 0.5) !important;
    border-radius: 14px !important;
    padding: 10px !important;
    z-index: 190;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
/* RESPONSIVE ADJUSTMENTS FOR PLAYMAT                                           */
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

@media (max-width: 1400px) {
    .playmat-row--status {
        min-height: 75px;
    }
    
    .zone-deity { flex: 0 0 130px; }
    .zone-status { flex: 0 0 120px; }
    .zone-void, .zone-abyss { flex: 0 0 70px; }
    
    .deity-card-slot {
        width: 55px;
        height: 77px;
    }
}

@media (max-width: 1100px) {
    .ec-playmat { padding: 4px; }
    .playmat-half { padding: 4px 6px; gap: 3px; }
    
    .zone-label-plate { font-size: 8px; padding: 2px 8px; }
    .slot-label { font-size: 7px; }
    
    .avatar-slot, .relic-slot {
        width: clamp(55px, 6vw, 75px);
        height: clamp(77px, 8.4vw, 105px);
    }
    
    .domain-slot {
        width: clamp(45px, 5vw, 60px);
        height: clamp(63px, 7vw, 84px);
    }
    
    .banner-title { font-size: 14px; letter-spacing: 2px; }
    .banner-subtitle { font-size: 10px; }
}

@media (max-width: 800px) {
    .playmat-half--opponent {
        transform: none;
    }
    
    .playmat-half--opponent .zone-label-plate,
    .playmat-half--opponent .slot-label,
    .playmat-half--opponent .zone-subtext,
    .playmat-half--opponent .rules-text {
        transform: none;
    }
    
    .playmat-rules { display: none; }
    .zone-subtext { display: none; }
}

    </style>
</head>
<body>
    <div id="game-container">
        <!-- SUN ALTAR ARENA LAYOUT -->
        <div class="ec-frame sun-altar" id="ec-arena-frame" data-domain="second-sun">
            <!-- TOP HUD - Opponent with Floating Deity -->
            <div class="ec-hud ec-hud--top">
                <div class="ec-hud-player">
                    <div class="deity-ring" id="p2-deity-zone">
                        <div class="deity-card-inner" id="p2-deity"></div>
                    </div>
                    <div class="ec-hud-text">
                        <span class="ec-hud-name" id="p2-deity-name">Opponent</span>
                        <span class="ec-hud-title" id="p2-title">Challenger</span>
                    </div>
                </div>
                <div class="essence-hud">
                    <div class="essence-counter">
                        <div class="essence-glyph"></div>
                        <span class="essence-value" id="p2-essence">23</span>
                    </div>
                    <div class="kl-display">
                        <span class="kl-label">Kundalini</span>
                        <div class="kl-pips" id="p2-kl-pips">
                            <div class="kl-pip active"></div>
                            <div class="kl-pip active"></div>
                            <div class="kl-pip active"></div>
                        </div>
                        <span class="kl-text" id="p2-kl">3/3</span>
                    </div>
                    <div class="ec-hud-stats">
                        <div class="ec-pill ec-pill--deck" id="p2-deck">
                            <span class="ec-pill-icon">üìú</span>
                            <span class="ec-pill-value" id="p2-deck-count">0</span>
                            <span class="ec-pill-label">Veiled</span>
                        </div>
                        <div class="ec-pill ec-pill--void" id="p2-graveyard">
                            <span class="ec-pill-icon">üíÄ</span>
                            <span class="ec-pill-value" id="p2-graveyard-count">0</span>
                            <span class="ec-pill-label">Fracture</span>
                        </div>
                    </div>
                </div>
                <div class="ec-phase-display">
                    <div id="phase-badge">
                        <div class="turn-number" id="turn-number">Turn 1</div>
                        <div class="phase-name" id="phase-name">Dawn Phase</div>
                    </div>
                    <div id="phase-tracker">
                        <div class="phase-step active" data-phase="dawn">
                            <div class="phase-icon">‚òÄ</div>
                            <div class="phase-label">Dawn</div>
                        </div>
                        <div class="phase-step" data-phase="draw">
                            <div class="phase-icon">üÉè</div>
                            <div class="phase-label">Draw</div>
                        </div>
                        <div class="phase-step" data-phase="main">
                            <div class="phase-icon">‚öî</div>
                            <div class="phase-label">Main</div>
                        </div>
                        <div class="phase-step" data-phase="clash">
                            <div class="phase-icon">üí•</div>
                            <div class="phase-label">Clash</div>
                        </div>
                        <div class="phase-step" data-phase="twilight">
                            <div class="phase-icon">üåô</div>
                            <div class="phase-label">Twilight</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- MAIN CONTENT GRID - OFFICIAL PLAYMAT LAYOUT -->
            <div class="ec-main">
                <div class="ec-playmat">
                    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                    <!-- OPPONENT SIDE (Player 2) - Mirrored/Upside Down Layout -->
                    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                    <div class="playmat-half playmat-half--opponent">
                        <!-- STATUS ZONE ROW (Top of opponent) -->
                        <div class="playmat-row playmat-row--status">
                            <div class="playmat-zone zone-status" id="p2-status-zone">
                                <span class="zone-label-plate">Status ‚Ä¢ Shards</span>
                                <div class="zone-content">
                                    <div class="status-tokens" id="p2-status-tokens"></div>
                                </div>
                            </div>
                            <div class="playmat-zone zone-essence" id="p2-essence-zone">
                                <span class="zone-label-plate">Essence</span>
                                <div class="zone-content essence-display">
                                    <span class="essence-glyph-large">‚óà</span>
                                    <span class="essence-number" id="p2-essence-display">23</span>
                                </div>
                                <div class="zone-subtext">Your hand is held off-mat below this edge</div>
                            </div>
                            <div class="playmat-zone zone-deity" id="p2-deity-playmat">
                                <span class="zone-label-plate">Deity / Aspect</span>
                                <div class="zone-content">
                                    <div class="deity-card-slot" id="p2-deity-slot"></div>
                                </div>
                                <div class="zone-subtext">Your Identity on New Earth</div>
                            </div>
                        </div>

                        <!-- RESOURCE BAND ROW -->
                        <div class="playmat-row playmat-row--resource">
                            <div class="playmat-zone zone-void" id="p2-void-zone">
                                <span class="zone-label-plate">Void / Exile</span>
                                <div class="zone-content">
                                    <div class="pile-slot" id="p2-void-pile" onclick="Game.showPile('exile', 1)"></div>
                                </div>
                                <div class="zone-subtext">Removed from Cycle</div>
                            </div>
                            <div class="playmat-zone zone-abyss" id="p2-abyss-zone">
                                <span class="zone-label-plate">Abyss</span>
                                <div class="zone-content">
                                    <div class="pile-slot" id="p2-abyss-pile" onclick="Game.showPile('graveyard', 1)"></div>
                                </div>
                            </div>
                            <div class="playmat-zone zone-domains" id="p2-domains-zone">
                                <span class="zone-label-plate">Resource Band ‚Äì Domains ‚Ä¢ Deck ‚Ä¢ Abyss ‚Ä¢ Void</span>
                                <div class="zone-content domain-slots" id="p2-domain-row">
                                    <div class="domain-slot ec-card-slot" data-slot="1" data-zone="domain">
                                        <span class="slot-label">Domain 1</span>
                                    </div>
                                    <div class="domain-slot ec-card-slot" data-slot="2" data-zone="domain">
                                        <span class="slot-label">Domain 2</span>
                                    </div>
                                    <div class="domain-slot ec-card-slot" data-slot="3" data-zone="domain">
                                        <span class="slot-label">Domain 3</span>
                                    </div>
                                    <div class="domain-slot ec-card-slot" data-slot="4" data-zone="domain">
                                        <span class="slot-label">Domain 4</span>
                                    </div>
                                    <div class="domain-slot ec-card-slot" data-slot="5" data-zone="domain">
                                        <span class="slot-label">Domain 5</span>
                                    </div>
                                </div>
                            </div>
                            <div class="playmat-zone zone-deck" id="p2-deck-zone">
                                <span class="zone-label-plate">Deck</span>
                                <div class="zone-content">
                                    <div class="deck-pile" id="p2-deck-pile">
                                        <div class="deck-cards-stack"></div>
                                        <span class="deck-count" id="p2-deck-count-display">60</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- AVATAR LINE ROW -->
                        <div class="playmat-row playmat-row--avatars">
                            <div class="playmat-zone zone-avatars">
                                <span class="zone-label-plate">Avatar Line ‚Äì Frontline on New Earth</span>
                                <div class="zone-content avatar-slots" id="p2-avatar-row">
                                    <div class="avatar-slot ec-card-slot" data-slot="1" data-zone="avatar">
                                        <span class="slot-label">Avatar 1</span>
                                    </div>
                                    <div class="avatar-slot ec-card-slot" data-slot="2" data-zone="avatar">
                                        <span class="slot-label">Avatar 2</span>
                                    </div>
                                    <div class="avatar-slot ec-card-slot" data-slot="3" data-zone="avatar">
                                        <span class="slot-label">Avatar 3</span>
                                    </div>
                                    <div class="avatar-slot ec-card-slot" data-slot="4" data-zone="avatar">
                                        <span class="slot-label">Avatar 4</span>
                                    </div>
                                    <div class="avatar-slot ec-card-slot" data-slot="5" data-zone="avatar">
                                        <span class="slot-label">Avatar 5</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- RELIC ROW (Support Line) -->
                        <div class="playmat-row playmat-row--relics">
                            <div class="playmat-zone zone-relics">
                                <span class="zone-label-plate">Relic Row ‚Äì Relics / Constructs</span>
                                <div class="zone-content relic-slots" id="p2-relic-row">
                                    <div class="relic-slot ec-card-slot" data-slot="1" data-zone="relic">
                                        <span class="slot-label">Relic 1</span>
                                    </div>
                                    <div class="relic-slot ec-card-slot" data-slot="2" data-zone="relic">
                                        <span class="slot-label">Relic 2</span>
                                    </div>
                                    <div class="relic-slot ec-card-slot" data-slot="3" data-zone="relic">
                                        <span class="slot-label">Relic 3</span>
                                    </div>
                                    <div class="relic-slot ec-card-slot" data-slot="4" data-zone="relic">
                                        <span class="slot-label">Relic 4</span>
                                    </div>
                                    <div class="relic-slot ec-card-slot" data-slot="5" data-zone="relic">
                                        <span class="slot-label">Relic 5</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- GAME RULES TEXT (Opponent Side) -->
                        <div class="playmat-rules playmat-rules--opponent">
                            <div class="rules-text">
                                <strong>Turn Flow:</strong> Start ‚Üí Main ‚Üí Combat ‚Üí End<br>
                                1 Domain play per turn (unless a card says otherwise).<br>
                                Ready ‚Üí Draw 1 ‚Üí Play ‚Üí Attack ‚Üí <strong>Draw Deck</strong><br>
                                Unblocked Avatars damage Essence. Essence‚ì™ = Crown Shattered.
                            </div>
                        </div>
                    </div>

                    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                    <!-- CENTER BANNER - TITLE STRIP -->
                    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                    <div class="playmat-center-banner">
                        <div class="banner-title">ESSENCE CROWN: SHARD WARS ‚Äì DUEL FIELD</div>
                        <div class="banner-subtitle">Children of the Shattered Sun ‚Ä¢ <span id="active-domain-name">New Earth</span> Duel Field</div>
                    </div>

                    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                    <!-- PLAYER SIDE (Player 1) - Normal Layout -->
                    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                    <div class="playmat-half playmat-half--player">
                        <!-- RELIC ROW (Support Line) -->
                        <div class="playmat-row playmat-row--relics">
                            <div class="playmat-zone zone-relics">
                                <span class="zone-label-plate">Relic Row ‚Äì Relics / Constructs</span>
                                <div class="zone-content relic-slots" id="p1-relic-row">
                                    <div class="relic-slot ec-card-slot" data-slot="1" data-zone="relic">
                                        <span class="slot-label">Relic 1</span>
                                    </div>
                                    <div class="relic-slot ec-card-slot" data-slot="2" data-zone="relic">
                                        <span class="slot-label">Relic 2</span>
                                    </div>
                                    <div class="relic-slot ec-card-slot" data-slot="3" data-zone="relic">
                                        <span class="slot-label">Relic 3</span>
                                    </div>
                                    <div class="relic-slot ec-card-slot" data-slot="4" data-zone="relic">
                                        <span class="slot-label">Relic 4</span>
                                    </div>
                                    <div class="relic-slot ec-card-slot" data-slot="5" data-zone="relic">
                                        <span class="slot-label">Relic 5</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- AVATAR LINE ROW -->
                        <div class="playmat-row playmat-row--avatars">
                            <div class="playmat-zone zone-avatars">
                                <span class="zone-label-plate">Avatar Line ‚Äì Frontline on New Earth</span>
                                <div class="zone-content avatar-slots" id="p1-avatar-row">
                                    <div class="avatar-slot ec-card-slot" data-slot="1" data-zone="avatar">
                                        <span class="slot-label">Avatar 1</span>
                                    </div>
                                    <div class="avatar-slot ec-card-slot" data-slot="2" data-zone="avatar">
                                        <span class="slot-label">Avatar 2</span>
                                    </div>
                                    <div class="avatar-slot ec-card-slot" data-slot="3" data-zone="avatar">
                                        <span class="slot-label">Avatar 3</span>
                                    </div>
                                    <div class="avatar-slot ec-card-slot" data-slot="4" data-zone="avatar">
                                        <span class="slot-label">Avatar 4</span>
                                    </div>
                                    <div class="avatar-slot ec-card-slot" data-slot="5" data-zone="avatar">
                                        <span class="slot-label">Avatar 5</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- RESOURCE BAND ROW -->
                        <div class="playmat-row playmat-row--resource">
                            <div class="playmat-zone zone-void" id="p1-void-zone">
                                <span class="zone-label-plate">Void / Exile</span>
                                <div class="zone-content">
                                    <div class="pile-slot" id="p1-void-pile" onclick="Game.showPile('exile', 0)"></div>
                                </div>
                                <div class="zone-subtext">Removed from Cycle</div>
                            </div>
                            <div class="playmat-zone zone-abyss" id="p1-abyss-zone">
                                <span class="zone-label-plate">Abyss</span>
                                <div class="zone-content">
                                    <div class="pile-slot" id="p1-abyss-pile" onclick="Game.showPile('graveyard', 0)"></div>
                                </div>
                            </div>
                            <div class="playmat-zone zone-domains" id="p1-domains-zone">
                                <span class="zone-label-plate">Resource Band ‚Äì Domains ‚Ä¢ Deck ‚Ä¢ Abyss ‚Ä¢ Void</span>
                                <div class="zone-content domain-slots" id="p1-domain-row">
                                    <div class="domain-slot ec-card-slot" data-slot="1" data-zone="domain">
                                        <span class="slot-label">Domain 1</span>
                                    </div>
                                    <div class="domain-slot ec-card-slot" data-slot="2" data-zone="domain">
                                        <span class="slot-label">Domain 2</span>
                                    </div>
                                    <div class="domain-slot ec-card-slot" data-slot="3" data-zone="domain">
                                        <span class="slot-label">Domain 3</span>
                                    </div>
                                    <div class="domain-slot ec-card-slot" data-slot="4" data-zone="domain">
                                        <span class="slot-label">Domain 4</span>
                                    </div>
                                    <div class="domain-slot ec-card-slot" data-slot="5" data-zone="domain">
                                        <span class="slot-label">Domain 5</span>
                                    </div>
                                </div>
                            </div>
                            <div class="playmat-zone zone-deck" id="p1-deck-zone">
                                <span class="zone-label-plate">Deck</span>
                                <div class="zone-content">
                                    <div class="deck-pile" id="p1-deck-pile">
                                        <div class="deck-cards-stack"></div>
                                        <span class="deck-count" id="p1-deck-count-display">60</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- GAME RULES TEXT (Player Side) -->
                        <div class="playmat-rules playmat-rules--player">
                            <div class="rules-text">
                                <strong>Turn Flow:</strong> Start ‚Üí Main ‚Üí Combat ‚Üí End<br>
                                1 Domain play per turn (unless a card says otherwise).<br>
                                Ready ‚Üí Draw 1 ‚Üí Play ‚Üí Attack ‚Üí <strong>Draw Deck</strong><br>
                                Unblocked Avatars damage Essence. Essence‚ì™ = Crown Shattered.
                            </div>
                        </div>

                        <!-- STATUS ZONE ROW (Bottom of player) -->
                        <div class="playmat-row playmat-row--status">
                            <div class="playmat-zone zone-deity" id="p1-deity-playmat">
                                <span class="zone-label-plate">Deity / Aspect</span>
                                <div class="zone-content">
                                    <div class="deity-card-slot" id="p1-deity-slot"></div>
                                </div>
                                <div class="zone-subtext">Your Identity on New Earth</div>
                            </div>
                            <div class="playmat-zone zone-essence" id="p1-essence-zone">
                                <span class="zone-label-plate">Essence</span>
                                <div class="zone-content essence-display">
                                    <span class="essence-glyph-large">‚óà</span>
                                    <span class="essence-number" id="p1-essence-display">23</span>
                                </div>
                                <div class="zone-subtext">Your hand is held off-mat below this edge</div>
                            </div>
                            <div class="playmat-zone zone-status" id="p1-status-zone">
                                <span class="zone-label-plate">Status ‚Ä¢ Shards</span>
                                <div class="zone-content">
                                    <div class="status-tokens" id="p1-status-tokens"></div>
                                </div>
                                <div class="zone-subtext">Tokens ‚Ä¢ Conditions ‚Ä¢ Campaign</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- RIGHT: SIDE PANELS -->
                <div class="ec-side-panels">
                    <!-- Codex View Panel -->
                    <div class="ec-panel ec-panel--codex">
                        <div class="ec-panel-header">
                            <span class="ec-panel-title">Codex View</span>
                            <span class="ec-panel-tag">Card Detail</span>
                        </div>
                        <div class="ec-codex-card" id="codex-card">
                            <div class="ec-codex-name" id="codex-name">Hover a card...</div>
                            <div class="ec-codex-meta" id="codex-meta"></div>
                            <div class="ec-codex-body" id="codex-body">Select or hover over any card to view its details here.</div>
                            <div class="ec-codex-flavor" id="codex-flavor"></div>
                        </div>
                    </div>

                    <!-- Battle Chronicle Panel -->
                    <div class="ec-panel ec-panel--chronicle">
                        <div class="ec-panel-header">
                            <span class="ec-panel-title">Battle Chronicle</span>
                            <span class="ec-panel-tag">Turn Log</span>
                        </div>
                        <div class="ec-chronicle-body" id="log-content">
                            <div class="ec-chronicle-entry">Match begins...</div>
                        </div>
                    </div>

                    <!-- Quick Actions -->
                    <div class="ec-panel ec-panel--actions">
                        <div id="turn-controls">
                            <button class="turn-btn" id="btn-next-phase">Next Phase</button>
                            <button class="turn-btn" id="btn-end-turn">End Turn</button>
                        </div>
                        <div id="side-panel">
                            <button class="panel-btn" id="btn-codex" title="Codex">?</button>
                            <button class="panel-btn auto-btn" id="btn-rules-helper" title="Rules Helper">Auto</button>
                            <button class="panel-btn" id="btn-log" title="Game Log">üìú</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- BOTTOM HUD - Player with Floating Deity -->
            <div class="ec-hud ec-hud--bottom">
                <div class="ec-hud-player">
                    <div class="deity-ring" id="p1-deity-zone">
                        <div class="deity-card-inner" id="p1-deity"></div>
                    </div>
                    <div class="ec-hud-text">
                        <span class="ec-hud-name" id="p1-deity-name">You</span>
                        <span class="ec-hud-title" id="p1-title">Shardkeeper</span>
                    </div>
                </div>
                <div class="essence-hud">
                    <div class="essence-counter">
                        <div class="essence-glyph"></div>
                        <span class="essence-value" id="p1-essence">23</span>
                    </div>
                    <div class="kl-display">
                        <span class="kl-label">Kundalini</span>
                        <div class="kl-pips" id="p1-kl-pips">
                            <div class="kl-pip active"></div>
                            <div class="kl-pip active"></div>
                            <div class="kl-pip active"></div>
                        </div>
                        <span class="kl-text" id="p1-kl">3/3</span>
                    </div>
                    <div class="ec-hud-stats">
                        <div class="ec-pill ec-pill--deck" id="p1-deck">
                            <span class="ec-pill-icon">üìú</span>
                            <span class="ec-pill-value" id="p1-deck-count">0</span>
                            <span class="ec-pill-label">Veiled</span>
                        </div>
                        <div class="ec-pill ec-pill--void" id="p1-graveyard">
                            <span class="ec-pill-icon">üíÄ</span>
                            <span class="ec-pill-value" id="p1-graveyard-count">0</span>
                            <span class="ec-pill-label">Fracture</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Shattered Sun Chronicle Panel (Campaign Mode) -->
            <div class="chronicle-panel hidden" id="chronicle-panel">
                <div class="chronicle-header">
                    <span class="chronicle-title">Shattered Sun Chronicle</span>
                    <button class="chronicle-toggle" onclick="ChroniclePanel.toggle()">‚àí</button>
                </div>
                <div class="chronicle-content" id="chronicle-content">
                    <div class="chronicle-act" id="chronicle-act">Act I</div>
                    <div class="chronicle-chapter" id="chronicle-chapter">Chapter 1: The Awakening</div>
                    <div class="chronicle-story" id="chronicle-story">
                        Your journey begins at the Second Sun temple...
                    </div>
                    <div class="chronicle-objectives">
                        <div class="objective-title">Objectives</div>
                        <div class="objective-item" id="obj-win">
                            <span class="objective-icon">‚öî</span>
                            <span>Defeat the opponent</span>
                        </div>
                    </div>
                    <div class="chronicle-progress" id="chronicle-progress">
                        <div class="progress-node complete">1</div>
                        <div class="progress-node current">2</div>
                        <div class="progress-node">3</div>
                        <div class="progress-node">4</div>
                        <div class="progress-node">5</div>
                    </div>
                </div>
            </div>

            <!-- COMMAND HAND BAR -->
            <div class="ec-hand-bar" id="hand-zone">
                <div class="ec-hand-header">
                    <span class="ec-hand-title">Command Hand</span>
                    <span class="ec-hand-info" id="hand-info">0 cards</span>
                </div>
                <div class="ec-hand-content">
                    <div class="ec-deck-pile" id="deck-pile" onclick="Game.drawCardManual()">
                        <div class="ec-deck-stack">
                            <div class="ec-deck-card"></div>
                            <div class="ec-deck-card"></div>
                            <div class="ec-deck-card"></div>
                        </div>
                        <div class="ec-deck-count" id="deck-pile-count">0</div>
                        <div class="ec-deck-label">DECK</div>
                    </div>
                    <div class="ec-hand-cards" id="player-hand"></div>
                    <div class="ec-graveyard-pile" id="graveyard-pile" onclick="Game.showPile('graveyard', 0)">
                        <div class="ec-graveyard-icon">üíÄ</div>
                        <div class="ec-graveyard-count" id="graveyard-pile-count">0</div>
                        <div class="ec-graveyard-label">VOID</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Legacy IDs for JS compatibility -->
        <div id="p1-life-badge" class="hidden-badge" data-player="0"></div>
        <div id="p2-life-badge" class="hidden-badge" data-player="1"></div>
        <div id="p1-banished" class="hidden-badge"><span id="p1-banished-count">0</span></div>
        <div id="p2-banished" class="hidden-badge"><span id="p2-banished-count">0</span></div>

        <!-- Reaction Bar -->
        <div class="ec-reaction-bar" id="ec-reaction-bar">
            <span class="ec-reaction-prompt">You may respond</span>
            <div class="ec-reaction-cards"></div>
            <div class="ec-reaction-actions">
                <button class="ec-reaction-btn ec-reaction-btn--respond" onclick="ReactionBar.respond()">Respond</button>
                <button class="ec-reaction-btn ec-reaction-btn--pass" onclick="ReactionBar.pass()">Pass</button>
            </div>
            <div class="ec-reaction-autopass">
                <input type="checkbox" id="ec-autopass-toggle" onchange="ReactionBar.toggleAutoPass()">
                <label for="ec-autopass-toggle">Auto-pass</label>
            </div>
        </div>

        <!-- Crown Victory/Defeat Overlay -->
        <div class="ec-crown-overlay" id="ec-crown-overlay">
            <div class="ec-crown-title" id="ec-crown-title">CROWN CLAIMED</div>
        </div>

        <!-- Turn Indicator -->
        <div id="turn-indicator" class="turn-indicator p1">Player 1's Turn</div>

        <!-- Action Prompt -->
        <div id="action-prompt">
            <div class="action-prompt-message" id="action-prompt-message"></div>
            <button class="ec-dialog-close" id="draw-phase-warning-close">
                OK
            </button>
        </div>

        <!-- Battle Overlay -->
        <div id="battle-overlay"></div>
        
        <!-- Draw Animation Overlay -->
        <div id="draw-animation"></div>
        
        <!-- Pile/Graveyard Overlay -->
        <div id="pile-overlay"></div>
        
        <!-- AI Play Overlay -->
        <div id="ai-play-overlay"></div>
        
        <!-- Card Preview -->
        <div id="card-preview"></div>

        <!-- Shard Chain Panel -->
        <div id="shard-chain-panel">
            <div class="shard-chain-header">
                <span class="chain-title">SHARD CHAIN</span>
                <span class="chain-count">0 Links</span>
            </div>
            <div class="shard-chain-links"></div>
            <div class="shard-chain-controls">
                <button class="chain-btn pass-btn" onclick="Game.passShardChainPriority()">PASS</button>
            </div>
        </div>
        <!-- Damage Numbers Container -->
        <div id="damage-numbers"></div>

        <!-- Particle Canvas -->
        <canvas id="particle-canvas"></canvas>
        
        <!-- Persistent Game Controls -->
        <div class="ec-game-controls" id="game-controls">
            <button class="ec-ctrl-btn" onclick="GameControls.toggleFullscreen()" title="Toggle Fullscreen">
                <span class="ctrl-icon">‚õ∂</span>
            </button>
            <button class="ec-ctrl-btn" onclick="GameControls.showPause()" title="Pause Menu">
                <span class="ctrl-icon">‚è∏</span>
            </button>
            <button class="ec-ctrl-btn" onclick="GameControls.goHome()" title="Return to Menu">
                <span class="ctrl-icon">üè†</span>
            </button>
        </div>
        
        <!-- Pause Menu Overlay -->
        <div class="ec-pause-overlay hidden" id="pause-overlay">
            <div class="ec-pause-menu">
                <h2 class="pause-title">GAME PAUSED</h2>
                <div class="pause-options">
                    <button class="pause-btn" onclick="GameControls.resume()">Resume Game</button>
                    <button class="pause-btn" onclick="GameControls.toggleFullscreen()">Toggle Fullscreen</button>
                    <button class="pause-btn pause-btn--danger" onclick="GameControls.surrender()">Surrender Match</button>
                    <button class="pause-btn pause-btn--danger" onclick="GameControls.goHome()">Quit to Menu</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Enhanced Profile Modal -->
    <div id="profile-modal" class="modal hidden">
        <div class="modal-overlay" onclick="PlayerProfile.closeModal()"></div>
        <div class="modal-content profile-modal-enhanced">
            <div class="modal-header">
                <h2>‚öîÔ∏è Shardkeeper Profile</h2>
                <button class="modal-close" onclick="PlayerProfile.closeModal()">‚úï</button>
            </div>
            
            <div class="profile-tabs">
                <button class="profile-tab active" data-tab="identity" onclick="PlayerProfile.switchTab('identity')">Identity</button>
                <button class="profile-tab" data-tab="cosmetics" onclick="PlayerProfile.switchTab('cosmetics')">Cosmetics</button>
                <button class="profile-tab" data-tab="stats" onclick="PlayerProfile.switchTab('stats')">Stats</button>
            </div>
            
            <!-- Identity Tab -->
            <div class="profile-tab-content active" id="tab-identity">
                <div class="form-group">
                    <label>Shardkeeper Name</label>
                    <input type="text" id="profile-name-input" placeholder="Enter your legendary name" maxlength="20">
                </div>
                
                <div class="form-group">
                    <label>Avatar Emblem</label>
                    <div class="avatar-options enhanced">
                        <div class="avatar-option" data-avatar="cosmic" onclick="PlayerProfile.selectAvatar('cosmic')">
                            <span class="avatar-icon">üåå</span>
                            <span class="avatar-label">Cosmic</span>
                        </div>
                        <div class="avatar-option" data-avatar="void" onclick="PlayerProfile.selectAvatar('void')">
                            <span class="avatar-icon">üåë</span>
                            <span class="avatar-label">Void</span>
                        </div>
                        <div class="avatar-option" data-avatar="essence" onclick="PlayerProfile.selectAvatar('essence')">
                            <span class="avatar-icon">‚ú®</span>
                            <span class="avatar-label">Essence</span>
                        </div>
                        <div class="avatar-option" data-avatar="divine" onclick="PlayerProfile.selectAvatar('divine')">
                            <span class="avatar-icon">üëë</span>
                            <span class="avatar-label">Divine</span>
                        </div>
                        <div class="avatar-option" data-avatar="inferno" onclick="PlayerProfile.selectAvatar('inferno')">
                            <span class="avatar-icon">üî•</span>
                            <span class="avatar-label">Inferno</span>
                        </div>
                        <div class="avatar-option" data-avatar="storm" onclick="PlayerProfile.selectAvatar('storm')">
                            <span class="avatar-icon">‚ö°</span>
                            <span class="avatar-label">Storm</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Title</label>
                    <div class="title-options">
                        <div class="title-option" data-title="Initiate" onclick="PlayerProfile.selectTitle('Initiate')">Initiate</div>
                        <div class="title-option" data-title="Shardkeeper" onclick="PlayerProfile.selectTitle('Shardkeeper')">Shardkeeper</div>
                        <div class="title-option" data-title="Essence Weaver" onclick="PlayerProfile.selectTitle('Essence Weaver')">Essence Weaver</div>
                        <div class="title-option" data-title="Void Walker" onclick="PlayerProfile.selectTitle('Void Walker')">Void Walker</div>
                        <div class="title-option locked" data-title="Champion" onclick="PlayerProfile.selectTitle('Champion')">Champion üîí</div>
                        <div class="title-option locked" data-title="Deity Slayer" onclick="PlayerProfile.selectTitle('Deity Slayer')">Deity Slayer üîí</div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Battle Motto</label>
                    <input type="text" id="profile-motto-input" placeholder="Your legendary battle cry..." maxlength="50">
                </div>
            </div>
            
            <!-- Cosmetics Tab -->
            <div class="profile-tab-content" id="tab-cosmetics">
                <div class="form-group">
                    <label>Card Back</label>
                    <div class="cardback-options">
                        <div class="cardback-option selected" data-cardback="default" onclick="PlayerProfile.selectCardBack('default')">
                            <div class="cardback-preview default"></div>
                            <span>Classic</span>
                        </div>
                        <div class="cardback-option" data-cardback="cosmic" onclick="PlayerProfile.selectCardBack('cosmic')">
                            <div class="cardback-preview cosmic"></div>
                            <span>Cosmic</span>
                        </div>
                        <div class="cardback-option" data-cardback="void" onclick="PlayerProfile.selectCardBack('void')">
                            <div class="cardback-preview void"></div>
                            <span>Void</span>
                        </div>
                        <div class="cardback-option" data-cardback="golden" onclick="PlayerProfile.selectCardBack('golden')">
                            <div class="cardback-preview golden"></div>
                            <span>Golden</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Profile Border</label>
                    <div class="border-options">
                        <div class="border-option selected" data-border="bronze" onclick="PlayerProfile.selectBorder('bronze')">
                            <div class="border-preview bronze"></div>
                            <span>Bronze</span>
                        </div>
                        <div class="border-option" data-border="silver" onclick="PlayerProfile.selectBorder('silver')">
                            <div class="border-preview silver"></div>
                            <span>Silver</span>
                        </div>
                        <div class="border-option" data-border="gold" onclick="PlayerProfile.selectBorder('gold')">
                            <div class="border-preview gold"></div>
                            <span>Gold</span>
                        </div>
                        <div class="border-option locked" data-border="divine" onclick="PlayerProfile.selectBorder('divine')">
                            <div class="border-preview divine"></div>
                            <span>Divine üîí</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Favorite Deity</label>
                    <select id="profile-deity-select" onchange="PlayerProfile.selectFavoriteDeity(this.value)">
                        <option value="">Select your patron deity...</option>
                    </select>
                </div>
            </div>
            
            <!-- Stats Tab -->
            <div class="profile-tab-content" id="tab-stats">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-matches">0</div>
                        <div class="stat-label">Total Matches</div>
                    </div>
                    <div class="stat-card wins">
                        <div class="stat-value" id="stat-wins">0</div>
                        <div class="stat-label">Victories</div>
                    </div>
                    <div class="stat-card losses">
                        <div class="stat-value" id="stat-losses">0</div>
                        <div class="stat-label">Defeats</div>
                    </div>
                    <div class="stat-card winrate">
                        <div class="stat-value" id="stat-winrate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-streak">0</div>
                        <div class="stat-label">Best Streak</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-campaign">0/10</div>
                        <div class="stat-label">Campaign</div>
                    </div>
                </div>
                
                <div class="recent-matches">
                    <h3>Recent Battles</h3>
                    <div class="match-history" id="match-history-list">
                        <div class="no-matches">No battles yet. Begin your legend!</div>
                    </div>
                </div>
            </div>
            
            <div class="profile-actions">
                <button class="btn-secondary" onclick="PlayerProfile.closeModal()">Cancel</button>
                <button class="btn-primary" onclick="PlayerProfile.saveProfile()">Save Profile</button>
            </div>
        </div>
    </div>
    
    <!-- Match Intro Cinematic -->
    <div id="match-intro" class="match-intro hidden">
        <div class="intro-bg"></div>
        <div class="intro-content">
            <div class="duelist duelist-left">
                <div class="duelist-avatar" id="intro-p1-avatar"></div>
                <div class="duelist-name" id="intro-p1-name"></div>
                <div class="duelist-title" id="intro-p1-title"></div>
                <div class="duelist-deity" id="intro-p1-deity"></div>
            </div>
            <div class="vs-emblem">
                <span class="vs-text">VS</span>
                <div class="vs-glow"></div>
            </div>
            <div class="duelist duelist-right">
                <div class="duelist-avatar" id="intro-p2-avatar"></div>
                <div class="duelist-name" id="intro-p2-name"></div>
                <div class="duelist-title" id="intro-p2-title"></div>
                <div class="duelist-deity" id="intro-p2-deity"></div>
            </div>
        </div>
        <div class="intro-bottom">
            <div class="battle-quote" id="intro-quote"></div>
            <div class="intro-progress"></div>
        </div>
    </div>

    <!-- Main Menu Screen -->
    <div id="main-menu" class="main-menu-screen">
        <div class="menu-background">
            <div class="menu-particles"></div>
        </div>
        
        <div class="menu-header">
            <div class="menu-logo">
                <h1>ESSENCE CROWN</h1>
                <h2>SHARD WARS</h2>
            </div>
            <div class="menu-controls">
                <button class="audio-btn" id="btn-music" onclick="AudioManager.toggleMusic()" title="Toggle Music">üéµ</button>
                <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="40" 
                       onchange="AudioManager.setVolume(this.value / 100)" title="Music Volume">
                <button class="fullscreen-btn" id="btn-fullscreen" onclick="FullscreenToggle.toggle()" title="Toggle Fullscreen">‚õ∂</button>
            </div>
            <div class="menu-profile" onclick="PlayerProfile.showModal()">
                <div class="profile-avatar" id="menu-avatar">üëë</div>
                <div class="profile-info">
                    <span class="profile-name" id="menu-player-name">Create Profile</span>
                    <span class="profile-rank" id="menu-player-rank">Click to setup</span>
                </div>
                <div class="profile-currency">
                    <span class="currency-shards" id="menu-shards">0</span>
                </div>
            </div>
        </div>
        
        <div class="menu-content">
            <div class="menu-modes">
                <div class="mode-card profile-setup" onclick="PlayerProfile.showModal()">
                    <div class="mode-icon">üë§</div>
                    <div class="mode-info">
                        <h3>CREATE PROFILE</h3>
                        <p>Customize your name & avatar</p>
                    </div>
                    <div class="mode-badge">Start Here</div>
                </div>
                
                <div class="mode-card solo" onclick="MainMenu.selectMode('solo')">
                    <div class="mode-icon">‚öî</div>
                    <div class="mode-info">
                        <h3>SOLO BATTLE</h3>
                        <p>Fight against AI opponents</p>
                    </div>
                    <div class="mode-badge">Practice</div>
                </div>
                
                <div class="mode-card campaign" onclick="MainMenu.selectMode('campaign')">
                    <div class="mode-icon">üëë</div>
                    <div class="mode-info">
                        <h3>CAMPAIGN</h3>
                        <p>Challenge the Deity Bosses</p>
                    </div>
                    <div class="mode-badge new">Story</div>
                </div>
                
                <div class="mode-card multiplayer" onclick="MainMenu.selectMode('multiplayer')">
                    <div class="mode-icon">üåê</div>
                    <div class="mode-info">
                        <h3>MULTIPLAYER</h3>
                        <p>Ranked & Casual matches</p>
                    </div>
                    <div class="mode-badge hot">Online</div>
                </div>
                
                <div class="mode-card deckbuilder" onclick="MainMenu.selectMode('deckbuilder')">
                    <div class="mode-icon">üìö</div>
                    <div class="mode-info">
                        <h3>DECK BUILDER</h3>
                        <p>Build your perfect deck</p>
                    </div>
                </div>
                
                <div class="mode-card collection" onclick="MainMenu.selectMode('collection')">
                    <div class="mode-icon">‚ú®</div>
                    <div class="mode-info">
                        <h3>COLLECTION</h3>
                        <p>View cards & cosmetics</p>
                    </div>
                </div>
                
                <div class="mode-card shop" onclick="MainMenu.selectMode('shop')">
                    <div class="mode-icon">üíé</div>
                    <div class="mode-info">
                        <h3>SHARD SHOP</h3>
                        <p>Buy cosmetics with Shards</p>
                    </div>
                    <div class="mode-badge hot">Shop</div>
                </div>
                
            </div>

            <div class="menu-news">
                <div class="news-banner">
                    <span class="news-label">NEWS</span>
                    <span class="news-text">Season 1 is live! Climb the ranks and earn exclusive rewards.</span>
                </div>
            </div>
        </div>
        
        <div class="menu-footer">
            <button class="menu-footer-btn" onclick="MainMenu.showCredits()">Credits</button>
            <span class="menu-version">v1.0.0</span>
        </div>
    </div>
    
    <!-- Solo Mode Selection -->
    <div id="solo-overlay" class="overlay hidden">
        <div class="solo-container">
            <h1>SOLO BATTLE</h1>
            <p>Choose your challenge level</p>
            
            <div class="difficulty-grid">
                <div class="difficulty-card" onclick="AIManager.startMatch('easy')">
                    <div class="diff-icon">üå±</div>
                    <h3>EASY</h3>
                    <p>Learn the basics against a forgiving opponent</p>
                    <div class="diff-rewards">Rewards: 232 Shards</div>
                </div>
                
                <div class="difficulty-card" onclick="AIManager.startMatch('medium')">
                    <div class="diff-icon">‚öî</div>
                    <h3>MEDIUM</h3>
                    <p>A balanced challenge for growing skills</p>
                    <div class="diff-rewards">Rewards: 247 Shards</div>
                </div>
                
                <div class="difficulty-card" onclick="AIManager.startMatch('hard')">
                    <div class="diff-icon">üíÄ</div>
                    <h3>HARD</h3>
                    <p>Face a cunning opponent with advanced tactics</p>
                    <div class="diff-rewards">Rewards: 272 Shards</div>
                </div>
                
                <div class="difficulty-card boss" onclick="AIManager.startMatch('boss')">
                    <div class="diff-icon">üëπ</div>
                    <h3>BOSS RUSH</h3>
                    <p>Challenge random boss deities</p>
                    <div class="diff-rewards">Rewards: 322 Shards</div>
                </div>
            </div>
            
            <button class="back-btn" onclick="MainMenu.back()">Back to Menu</button>
        </div>
    </div>
    
    <!-- Campaign Mode -->
    <div id="campaign-overlay" class="overlay hidden">
        <div class="campaign-container">
            <h1>CAMPAIGN: CROWN WARS</h1>
            <p>Defeat the Deity Bosses and claim your crown</p>
            
            <div class="campaign-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="campaign-progress-bar"></div>
                </div>
                <span id="campaign-progress-text">0 / 10 Bosses Defeated</span>
            </div>
            
            <div class="chapter-grid" id="campaign-chapters">
                <!-- Generated by CampaignManager -->
            </div>
            
            <button class="back-btn" onclick="MainMenu.back()">Back to Menu</button>
        </div>
    </div>
    
    <!-- Deck Builder -->
    <div id="deckbuilder-overlay" class="overlay hidden">
        <div class="ec-deckbuilder">
            <div class="ec-deckbuilder-header">
                <div class="ec-db-title">
                    <span class="ec-db-icon">üìú</span>
                    <h1>DECK FORGE</h1>
                </div>
                <div class="ec-db-deck-meta">
                    <input type="text" id="deck-name" class="ec-db-name-input" placeholder="Deck Name" value="New Deck">
                    <div class="ec-db-card-counter">
                        <span class="ec-db-count" id="deck-card-count">0</span>
                        <span class="ec-db-count-max">/60</span>
                    </div>
                </div>
                <div class="ec-db-actions">
                    <button class="ec-db-btn save" onclick="DeckBuilder.saveDeck()">
                        <span class="btn-icon">üíæ</span> Save
                    </button>
                    <button class="ec-db-btn clear" onclick="DeckBuilder.clearDeck()">
                        <span class="btn-icon">üóë</span> Clear
                    </button>
                    <button class="ec-db-btn play" onclick="DeckBuilder.playWithDeck()">
                        <span class="btn-icon">‚öî</span> Battle
                    </button>
                </div>
            </div>
            
            <div class="ec-deckbuilder-grid">
                <div class="ec-db-pool card-pool">
                    <div class="ec-db-filter-bar pool-filters">
                        <div class="ec-filter-search">
                            <span class="search-icon">üîç</span>
                            <input type="text" id="deck-search" placeholder="Search cards...">
                        </div>
                        <div class="ec-filter-chips">
                            <select id="deck-filter-type" class="ec-filter-select">
                                <option value="">All Types</option>
                                <option value="Avatar">Avatars</option>
                                <option value="Spell">Spells</option>
                                <option value="Domain">Domains</option>
                                <option value="Relic">Relics</option>
                            </select>
                            <select id="deck-filter-aspect" class="ec-filter-select">
                                <option value="">All Aspects</option>
                                <option value="Glow">Glow</option>
                                <option value="Void">Void</option>
                                <option value="Gray">Gray</option>
                            </select>
                        </div>
                    </div>
                    <div class="ec-db-pool-cards pool-cards" id="deck-card-pool"></div>
                </div>
                
                <div class="ec-db-stats">
                    <div class="ec-stats-panel">
                        <h3 class="ec-stats-title">Deck Analytics</h3>
                        
                        <div class="ec-stat-section">
                            <h4>KL Curve</h4>
                            <div class="ec-kl-curve" id="deck-kl-curve">
                                <div class="ec-kl-bar" data-cost="0"><div class="bar-fill"></div><span>0</span></div>
                                <div class="ec-kl-bar" data-cost="1"><div class="bar-fill"></div><span>1</span></div>
                                <div class="ec-kl-bar" data-cost="2"><div class="bar-fill"></div><span>2</span></div>
                                <div class="ec-kl-bar" data-cost="3"><div class="bar-fill"></div><span>3</span></div>
                                <div class="ec-kl-bar" data-cost="4"><div class="bar-fill"></div><span>4</span></div>
                                <div class="ec-kl-bar" data-cost="5"><div class="bar-fill"></div><span>5</span></div>
                                <div class="ec-kl-bar" data-cost="6"><div class="bar-fill"></div><span>6+</span></div>
                            </div>
                        </div>
                        
                        <div class="ec-stat-section">
                            <h4>Card Types</h4>
                            <div class="ec-type-bars" id="deck-type-breakdown">
                                <div class="ec-type-row">
                                    <span class="type-label">Avatar</span>
                                    <div class="type-bar"><div class="type-fill avatar" id="type-avatar-bar"></div></div>
                                    <span class="type-count" id="type-avatar-count">0</span>
                                </div>
                                <div class="ec-type-row">
                                    <span class="type-label">Spell</span>
                                    <div class="type-bar"><div class="type-fill spell" id="type-spell-bar"></div></div>
                                    <span class="type-count" id="type-spell-count">0</span>
                                </div>
                                <div class="ec-type-row">
                                    <span class="type-label">Domain</span>
                                    <div class="type-bar"><div class="type-fill domain" id="type-domain-bar"></div></div>
                                    <span class="type-count" id="type-domain-count">0</span>
                                </div>
                                <div class="ec-type-row">
                                    <span class="type-label">Relic</span>
                                    <div class="type-bar"><div class="type-fill relic" id="type-relic-bar"></div></div>
                                    <span class="type-count" id="type-relic-count">0</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="ec-stat-section">
                            <h4>Aspects</h4>
                            <div class="ec-aspect-rings" id="deck-aspect-dist">
                                <div class="ec-aspect-badge glow">
                                    <span class="aspect-icon">‚òÄ</span>
                                    <span class="aspect-count" id="aspect-glow-count">0</span>
                                </div>
                                <div class="ec-aspect-badge void">
                                    <span class="aspect-icon">üåë</span>
                                    <span class="aspect-count" id="aspect-void-count">0</span>
                                </div>
                                <div class="ec-aspect-badge gray">
                                    <span class="aspect-icon">‚öñ</span>
                                    <span class="aspect-count" id="aspect-gray-count">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="ec-saved-panel">
                        <h3 class="ec-stats-title">Saved Decks</h3>
                        <div class="ec-saved-decks" id="saved-decks-list"></div>
                    </div>
                </div>
                
                <div class="ec-db-decklist current-deck">
                    <div class="ec-decklist-header">
                        <span class="ec-decklist-title">Current Deck</span>
                        <div class="ec-deck-validity" id="deck-validity">
                            <span class="validity-icon">‚ö†</span>
                            <span class="validity-text">Need 60 cards</span>
                        </div>
                    </div>
                    <div class="ec-deck-cards deck-cards" id="deck-current-cards"></div>
                </div>
            </div>
            
            <button class="ec-db-back back-btn" onclick="MainMenu.back()">‚Üê Back to Menu</button>
        </div>
    </div>
    
    <!-- Card Detail Modal -->
    <div id="card-detail-modal" class="card-detail-modal hidden">
        <div class="card-detail-content">
            <button class="card-detail-close" onclick="DeckBuilder.closeCardDetail()">√ó</button>
            <div class="card-detail-image">
                <img id="card-detail-img" src="" alt="Card">
            </div>
            <div class="card-detail-info">
                <h2 id="card-detail-name">Card Name</h2>
                <div class="card-detail-meta">
                    <span id="card-detail-type" class="meta-badge">Type</span>
                    <span id="card-detail-cost" class="meta-badge cost">Cost</span>
                </div>
                <p id="card-detail-aspects" class="aspects"></p>
                <div id="card-detail-stats" class="stats"></div>
                <p id="card-detail-effect" class="effect-text"></p>
                <button class="card-detail-btn" onclick="DeckBuilder.quickAddCard()">Add to Deck</button>
            </div>
        </div>
    </div>
    
    <!-- Collection/Codex -->
    <div id="collection-overlay" class="overlay hidden">
        <div class="collection-container">
            <h1>COLLECTION</h1>
            <div class="collection-tabs">
                <button class="coll-tab active" onclick="Collection.showTab('cards')">Cards</button>
                <button class="coll-tab" onclick="Collection.showTab('deities')">Deities</button>
                <button class="coll-tab" onclick="Collection.showTab('cosmetics')">Cosmetics</button>
            </div>
            
            <div class="collection-grid" id="collection-grid"></div>
            
            <button class="back-btn" onclick="MainMenu.back()">Back to Menu</button>
        </div>
    </div>
    
    <!-- Queue Selection Overlay -->
    <div id="queue-overlay" class="overlay hidden">
        <div class="queue-container">
            <button class="back-btn" onclick="MainMenu.back()">‚Üê Back to Menu</button>
            <h1>CHOOSE YOUR BATTLE MODE</h1>
            <div class="player-profile clickable" onclick="Game.openProfileViewer()">
                <div class="rank-badge clickable-indicator">
                    <div id="player-rank-display">Bronze III (1000 MMR)</div>
                    <div id="player-stats-display">W: 0 / L: 0</div>
                    <div class="click-hint">Click to view profile</div>
                </div>
            </div>
            <div class="queue-buttons">
                <button class="queue-btn casual" onclick="Game.joinQueue('casual')">
                    <span class="queue-title">CASUAL</span>
                    <span class="queue-desc">Play for fun, no MMR</span>
                </button>
                <button class="queue-btn ranked" onclick="Game.joinQueue('ranked')">
                    <span class="queue-title">RANKED</span>
                    <span class="queue-desc">Climb the ranks, gain MMR</span>
                </button>
            </div>
            <div class="queue-extras">
                <button class="queue-extra-btn" onclick="Game.showTournaments()">
                    <span class="extra-icon">üèÜ</span>
                    <span class="extra-title">Tournaments</span>
                </button>
                <button class="queue-extra-btn" onclick="Game.showEvents()">
                    <span class="extra-icon">üé≠</span>
                    <span class="extra-title">Special Events</span>
                </button>
                <button class="queue-extra-btn" onclick="Game.showLimited()">
                    <span class="extra-icon">üì¶</span>
                    <span class="extra-title">Limited</span>
                </button>
            </div>
            <div class="queue-extras secondary">
                <button class="queue-extra-btn cosmetic" onclick="Game.showCosmetics()">
                    <span class="extra-icon">‚ú®</span>
                    <span class="extra-title">Cosmetics</span>
                </button>
                <button class="queue-extra-btn shardpath" onclick="Game.showShardPath()">
                    <span class="extra-icon">üõ§Ô∏è</span>
                    <span class="extra-title">Shard Path</span>
                </button>
            </div>
            <div class="queue-extras tertiary">
                <button class="queue-extra-btn sandbox" onclick="Game.showSandbox()">
                    <span class="extra-icon">üß™</span>
                    <span class="extra-title">Sandbox</span>
                </button>
                <button class="queue-extra-btn custom" onclick="Game.showCustomLobby()">
                    <span class="extra-icon">üîß</span>
                    <span class="extra-title">Custom Lobby</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Friends & Direct Challenge Overlay -->
    <div id="friends-overlay" class="overlay hidden">
        <div class="friends-container">
            <div class="friends-header">
                <h1>Friends & Challenges</h1>
                <button class="friends-close" onclick="Game.proceedToQueue()">‚Üí Queue</button>
            </div>
            <div class="friends-sections">
                <div class="section">
                    <h2>Friends</h2>
                    <button class="add-friend-btn" onclick="Game.addNewFriend()">+ Add Friend</button>
                    <div id="friends-list" class="friends-list"></div>
                </div>
                <div class="section">
                    <h2>Friend Requests</h2>
                    <div id="friend-requests-list" class="requests-list"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Replay Browser Overlay -->
    <div id="replay-browser-overlay" class="overlay hidden">
        <div class="replay-browser-container">
            <div class="replay-browser-header">
                <h1>Match Replays</h1>
                <button class="close-btn" onclick="Game.hideReplayBrowser()">√ó</button>
            </div>
            <div id="replay-list" class="replay-list"></div>
            <div class="replay-browser-footer">
                <button class="secondary-btn" onclick="Game.showAnalytics()">View Analytics</button>
                <button class="secondary-btn" onclick="Game.hideReplayBrowser()">Back</button>
            </div>
        </div>
    </div>
    
    <!-- Replay Viewer Controls -->
    <div id="replay-overlay" class="replay-controls hidden">
        <div class="replay-bar">
            <div id="replay-info" class="replay-info"></div>
            <div class="replay-controls-row">
                <button id="btn-replay-backward" class="replay-btn" onclick="ReplayViewer.stepBackward()">‚èÆ</button>
                <button id="btn-replay-play" class="replay-btn" onclick="ReplayViewer.play()">‚ñ∂</button>
                <button id="btn-replay-forward" class="replay-btn" onclick="ReplayViewer.stepForward()">‚è≠</button>
                <input type="range" id="replay-progress" class="replay-slider" min="0" max="100" value="0" onchange="ReplayViewer.seekTo(this.value)">
                <span id="replay-turn" class="replay-turn">Turn 1</span>
                <span id="replay-action" class="replay-action">0/0</span>
                <button class="replay-btn close" onclick="ReplayViewer.close()">‚úï</button>
            </div>
        </div>
    </div>
    
    <!-- Spectator Overlay -->
    <div id="spectator-overlay" class="spectator-controls hidden">
        <div class="spectator-bar">
            <div id="spectator-info" class="spectator-info"></div>
            <span id="spectator-turn" class="spectator-turn">Turn 1</span>
            <button class="spectator-btn" onclick="SpectatorMode.stopSpectating()">Stop Spectating</button>
        </div>
    </div>
    
    <!-- Live Matches Browser -->
    <div id="spectate-browser-overlay" class="overlay hidden">
        <div class="spectate-browser-container">
            <div class="spectate-browser-header">
                <h1>Live Matches</h1>
                <button class="close-btn" onclick="Game.hideSpectateBrowser()">√ó</button>
            </div>
            <div id="live-matches-list" class="live-matches-list">
                <p class="no-matches">No live matches available</p>
            </div>
        </div>
    </div>
    
    <!-- Analytics Panel -->
    <div id="analytics-overlay" class="overlay hidden">
        <div class="analytics-container">
            <div class="analytics-header">
                <h1>Card Analytics</h1>
                <button class="close-btn" onclick="Game.hideAnalytics()">√ó</button>
            </div>
            <div class="analytics-tabs">
                <button class="analytics-tab active" data-tab="cards" onclick="Game.switchAnalyticsTab('cards')">Top Cards</button>
                <button class="analytics-tab" data-tab="archetypes" onclick="Game.switchAnalyticsTab('archetypes')">Archetypes</button>
                <button class="analytics-tab" data-tab="history" onclick="Game.switchAnalyticsTab('history')">History</button>
            </div>
            <div id="analytics-content" class="analytics-content"></div>
            <div class="analytics-footer">
                <button class="secondary-btn" onclick="Game.exportAnalytics()">Export Data</button>
            </div>
        </div>
    </div>
    
    <!-- Tournament Browser Overlay -->
    <div id="tournament-overlay" class="overlay hidden">
        <div class="tournament-container">
            <div class="tournament-header">
                <h1>TOURNAMENTS</h1>
                <button class="close-btn" onclick="Game.hideTournaments()">√ó</button>
            </div>
            <div class="tournament-tabs">
                <button class="tournament-tab active" data-tab="open" onclick="Game.switchTournamentTab('open')">Open</button>
                <button class="tournament-tab" data-tab="active" onclick="Game.switchTournamentTab('active')">Active</button>
                <button class="tournament-tab" data-tab="completed" onclick="Game.switchTournamentTab('completed')">Completed</button>
                <button class="tournament-tab" data-tab="create" onclick="Game.switchTournamentTab('create')">+ Create</button>
            </div>
            <div id="tournament-content" class="tournament-content"></div>
        </div>
    </div>
    
    <!-- Tournament Detail View -->
    <div id="tournament-detail-overlay" class="overlay hidden">
        <div class="tournament-detail-container">
            <div class="tournament-detail-header">
                <button class="back-btn" onclick="Game.backToTournaments()">‚Üê Back</button>
                <h1 id="tournament-detail-name">Tournament Name</h1>
                <span id="tournament-detail-status" class="tournament-status">Registration</span>
            </div>
            <div class="tournament-detail-info">
                <div class="info-row">
                    <span class="info-label">Format:</span>
                    <span id="tournament-detail-format">Swiss</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Players:</span>
                    <span id="tournament-detail-players">0/8</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Round:</span>
                    <span id="tournament-detail-round">0/3</span>
                </div>
                <div class="info-row" id="tournament-event-row">
                    <span class="info-label">Event:</span>
                    <span id="tournament-detail-event">Standard</span>
                </div>
            </div>
            <div class="tournament-detail-actions" id="tournament-actions"></div>
            <div class="tournament-detail-tabs">
                <button class="detail-tab active" data-tab="matches" onclick="Game.switchTournamentDetailTab('matches')">Matches</button>
                <button class="detail-tab" data-tab="standings" onclick="Game.switchTournamentDetailTab('standings')">Standings</button>
                <button class="detail-tab" data-tab="bracket" onclick="Game.switchTournamentDetailTab('bracket')">Bracket</button>
            </div>
            <div id="tournament-detail-content" class="tournament-detail-content"></div>
        </div>
    </div>
    
    <!-- Events Browser Overlay -->
    <div id="events-overlay" class="overlay hidden">
        <div class="events-container">
            <div class="events-header">
                <h1>SPECIAL EVENTS</h1>
                <button class="close-btn" onclick="Game.hideEvents()">√ó</button>
            </div>
            <div class="events-description">
                <p>Queue into special formats with unique rules and restrictions</p>
            </div>
            <div id="events-list" class="events-list"></div>
        </div>
    </div>
    
    <!-- Event Queue Confirmation -->
    <div id="event-queue-overlay" class="overlay hidden">
        <div class="event-queue-container">
            <div id="event-queue-header" class="event-queue-header">
                <span class="event-icon">üéÆ</span>
                <h2 id="event-queue-name">Event Name</h2>
            </div>
            <div id="event-queue-rules" class="event-queue-rules"></div>
            <div class="event-queue-actions">
                <button class="queue-btn event-queue" onclick="Game.joinEventQueue()">
                    <span class="queue-title">JOIN EVENT QUEUE</span>
                </button>
                <button class="secondary-btn" onclick="Game.hideEventQueue()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Limited Mode Overlay -->
    <div id="limited-overlay" class="overlay hidden">
        <div class="limited-container">
            <div class="limited-header">
                <h1>LIMITED MODE</h1>
                <button class="close-btn" onclick="Game.hideLimited()">√ó</button>
            </div>
            <div class="limited-modes">
                <div class="limited-mode-card" onclick="Game.startSealed()">
                    <div class="mode-icon">üì¶</div>
                    <h2>SEALED</h2>
                    <p>Open a pool of 45 cards and build a 30-40 card deck</p>
                    <ul>
                        <li>1 Guaranteed Mythic</li>
                        <li>2 Guaranteed Arcane</li>
                        <li>5 Guaranteed Master</li>
                    </ul>
                </div>
                <div class="limited-mode-card coming-soon">
                    <div class="mode-icon">üîÑ</div>
                    <h2>DRAFT</h2>
                    <p>Pick cards from rotating packs to build your deck</p>
                    <span class="coming-soon-badge">Coming Soon</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Sealed Deckbuilder Overlay -->
    <div id="sealed-deckbuilder-overlay" class="overlay hidden">
        <div class="sealed-container">
            <div class="sealed-header">
                <h1>SEALED DECKBUILDER</h1>
                <div class="sealed-stats">
                    <span id="sealed-deck-count">Deck: 0/30-40</span>
                    <span id="sealed-pool-count">Pool: 45</span>
                </div>
                <button class="close-btn" onclick="Game.exitSealed()">√ó</button>
            </div>
            <div class="sealed-content">
                <div class="sealed-pool-section">
                    <h2>CARD POOL</h2>
                    <div id="sealed-pool" class="sealed-card-grid"></div>
                </div>
                <div class="sealed-deck-section">
                    <h2>YOUR DECK</h2>
                    <div id="sealed-deck" class="sealed-card-grid"></div>
                </div>
            </div>
            <div class="sealed-actions">
                <button class="secondary-btn" onclick="Game.exitSealed()">Abandon</button>
                <button class="queue-btn sealed-play" id="sealed-play-btn" onclick="Game.playSealedDeck()" disabled>
                    Play with Deck
                </button>
            </div>
        </div>
    </div>
    
    <!-- Cosmetics Shop Overlay -->
    <div id="cosmetics-overlay" class="overlay hidden">
        <div class="cosmetics-container">
            <button class="back-btn" onclick="MainMenu.hideShop()">‚Üê Back to Menu</button>
            <div class="cosmetics-header">
                <h1>COSMETICS</h1>
                <div class="currency-display">
                    <span class="shard-icon">üíé</span>
                    <span id="cosmetics-currency">0</span> Shards
                </div>
                <button class="close-btn" onclick="Game.hideCosmetics()">√ó</button>
            </div>
            <div class="cosmetics-tabs">
                <button class="cosmetic-tab active" data-type="cardBack" onclick="Game.showCosmeticType('cardBack')">Card Backs</button>
                <button class="cosmetic-tab" data-type="boardSkin" onclick="Game.showCosmeticType('boardSkin')">Boards</button>
                <button class="cosmetic-tab" data-type="cardFrame" onclick="Game.showCosmeticType('cardFrame')">Frames</button>
                <button class="cosmetic-tab" data-type="effectVariant" onclick="Game.showCosmeticType('effectVariant')">Effects</button>
                <button class="cosmetic-tab" data-type="deitySkin" onclick="Game.showCosmeticType('deitySkin')">Deities</button>
            </div>
            <div id="cosmetics-grid" class="cosmetics-grid"></div>
        </div>
    </div>
    
    <!-- Shard Path (Battle Pass) Overlay -->
    <div id="shard-path-overlay" class="overlay hidden">
        <div class="shard-path-container">
            <button class="back-btn" onclick="Game.hideShardPath()">‚Üê Back to Menu</button>
            <div class="shard-path-header">
                <div class="season-info">
                    <h1 id="shard-path-season">SEASON OF THE CROWN</h1>
                    <span id="shard-path-timer">90 days remaining</span>
                </div>
                <div class="path-stats">
                    <div class="xp-display">
                        <span id="shard-path-level">Level 1</span>
                        <div class="xp-bar">
                            <div id="shard-path-xp-fill" class="xp-fill" style="width: 0%"></div>
                        </div>
                        <span id="shard-path-xp">0 / 1000 XP</span>
                    </div>
                    <div class="currency-display">
                        <span class="shard-icon">üíé</span>
                        <span id="shard-path-currency">0</span> Shards
                    </div>
                </div>
                <button class="close-btn" onclick="Game.hideShardPath()">√ó</button>
            </div>
            <div class="shard-path-tabs">
                <button class="path-tab active" data-tab="rewards" onclick="Game.showShardPathTab('rewards')">Rewards</button>
                <button class="path-tab" data-tab="quests" onclick="Game.showShardPathTab('quests')">Quests</button>
            </div>
            <div id="shard-path-content" class="shard-path-content">
                <div class="reward-tracks">
                    <div class="track free-track">
                        <h3>FREE TRACK</h3>
                        <div id="free-track-rewards" class="track-rewards"></div>
                    </div>
                    <div class="track premium-track">
                        <h3>PREMIUM TRACK <span id="premium-status" class="locked">üîí</span></h3>
                        <div id="premium-track-rewards" class="track-rewards"></div>
                    </div>
                </div>
            </div>
            <div id="shard-path-quests" class="shard-path-quests hidden">
                <div class="quest-section">
                    <h3>DAILY QUESTS</h3>
                    <div id="daily-quests" class="quest-list"></div>
                </div>
                <div class="quest-section">
                    <h3>WEEKLY QUESTS</h3>
                    <div id="weekly-quests" class="quest-list"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Deity Selection Overlay -->
    <div id="deity-select-overlay" class="overlay hidden">
        <div class="deity-select-content">
            <button class="back-btn deity-back-btn" onclick="Game.cancelDeitySelection()">‚Üê Cancel</button>
            <h1 id="deity-select-title">SELECT PLAYER 1 DEITY</h1>
            <p>Choose the Sovereign who will lead your forces</p>
            <div id="deity-grid" class="deity-grid"></div>
        </div>
    </div>
    
    <!-- Game Log Panel -->
    <div id="log-panel">
        <h3>Game Log</h3>
        <div id="log-content"></div>
    </div>
    
    <!-- Sandbox Mode Overlay -->
    <div id="sandbox-overlay" class="overlay hidden">
        <div class="sandbox-container">
            <h1>SANDBOX MODE</h1>
            <p>Set up custom board states for testing and content creation</p>
            
            <div class="sandbox-controls">
                <div class="sandbox-section">
                    <h3>Player Settings</h3>
                    <div class="sandbox-player-row">
                        <div class="sandbox-player">
                            <h4>Player 1</h4>
                            <div class="sandbox-stat">
                                <label>Essence:</label>
                                <input type="number" id="sandbox-p1-essence" value="23" min="0" max="99">
                            </div>
                            <div class="sandbox-stat">
                                <label>KL:</label>
                                <input type="number" id="sandbox-p1-kl" value="3" min="0" max="20">
                                <span>/</span>
                                <input type="number" id="sandbox-p1-kl-max" value="3" min="1" max="20">
                            </div>
                            <button class="sandbox-btn" onclick="Game.sandboxApplyPlayer(0)">Apply</button>
                            <button class="sandbox-btn danger" onclick="SandboxMode.clearBoard(0)">Clear Board</button>
                        </div>
                        <div class="sandbox-player">
                            <h4>Player 2</h4>
                            <div class="sandbox-stat">
                                <label>Essence:</label>
                                <input type="number" id="sandbox-p2-essence" value="23" min="0" max="99">
                            </div>
                            <div class="sandbox-stat">
                                <label>KL:</label>
                                <input type="number" id="sandbox-p2-kl" value="3" min="0" max="20">
                                <span>/</span>
                                <input type="number" id="sandbox-p2-kl-max" value="3" min="1" max="20">
                            </div>
                            <button class="sandbox-btn" onclick="Game.sandboxApplyPlayer(1)">Apply</button>
                            <button class="sandbox-btn danger" onclick="SandboxMode.clearBoard(1)">Clear Board</button>
                        </div>
                    </div>
                </div>
                
                <div class="sandbox-section">
                    <h3>Add Cards</h3>
                    <div class="sandbox-add-card">
                        <select id="sandbox-player-select">
                            <option value="0">Player 1</option>
                            <option value="1">Player 2</option>
                        </select>
                        <select id="sandbox-zone-select">
                            <option value="hand">Hand</option>
                            <option value="avatar">Avatar Row</option>
                            <option value="domain">Domain Row</option>
                            <option value="relic">Relic Row</option>
                            <option value="graveyard">Graveyard</option>
                        </select>
                        <input type="text" id="sandbox-card-search" placeholder="Search cards...">
                    </div>
                    <div id="sandbox-card-results" class="sandbox-card-grid"></div>
                </div>
                
                <div class="sandbox-section">
                    <h3>Saved States</h3>
                    <div class="sandbox-save-row">
                        <input type="text" id="sandbox-state-name" placeholder="State name...">
                        <button class="sandbox-btn" onclick="Game.sandboxSaveState()">Save State</button>
                    </div>
                    <div id="sandbox-saved-states" class="sandbox-states-list"></div>
                </div>
            </div>
            
            <div class="sandbox-actions">
                <button class="queue-btn" onclick="Game.sandboxStartGame()">START GAME</button>
                <button class="queue-btn secondary" onclick="Game.hideSandbox()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Lobby Overlay -->
    <div id="custom-lobby-overlay" class="overlay hidden">
        <div class="lobby-container">
            <h1>CUSTOM RULES LOBBY</h1>
            
            <div class="lobby-tabs">
                <button class="lobby-tab active" onclick="Game.showLobbyTab('create')">Create Lobby</button>
                <button class="lobby-tab" onclick="Game.showLobbyTab('browse')">Browse Lobbies</button>
            </div>
            
            <div id="lobby-create-tab" class="lobby-tab-content">
                <div class="lobby-settings">
                    <div class="lobby-preset-row">
                        <label>Preset:</label>
                        <select id="lobby-preset" onchange="Game.applyLobbyPreset()">
                            <option value="">Custom</option>
                            <option value="standard">Standard</option>
                            <option value="highLife">High Life (40 Essence)</option>
                            <option value="turbo">Turbo (15 Essence, 6 KL)</option>
                            <option value="sudden">Sudden Death (10 Essence)</option>
                            <option value="avatarsOnly">Avatars Only</option>
                            <option value="spellsUnleashed">Spells Unleashed</option>
                            <option value="voidWar">Void War (Void Only)</option>
                            <option value="glowCrusade">Glow Crusade (Glow Only)</option>
                            <option value="domination">Domination (Avatar Kills)</option>
                        </select>
                    </div>
                    
                    <div class="lobby-setting-row">
                        <label>Lobby Name:</label>
                        <input type="text" id="lobby-name" placeholder="My Custom Match" maxlength="30">
                    </div>
                    
                    <div class="lobby-setting-row">
                        <label>Starting Essence:</label>
                        <input type="number" id="lobby-essence" value="23" min="5" max="99">
                    </div>
                    
                    <div class="lobby-setting-row">
                        <label>Starting KL:</label>
                        <input type="number" id="lobby-kl" value="3" min="1" max="13">
                    </div>
                    
                    <div class="lobby-setting-row">
                        <label>Victory Condition:</label>
                        <select id="lobby-victory">
                            <option value="essence">Reduce Essence to 0</option>
                            <option value="avatars">Destroy X Avatars</option>
                        </select>
                    </div>
                    
                    <div class="lobby-setting-row" id="lobby-avatar-count-row" style="display:none;">
                        <label>Avatars to Destroy:</label>
                        <input type="number" id="lobby-avatar-count" value="5" min="3" max="15">
                    </div>
                    
                    <div class="lobby-setting-row">
                        <label>Allowed Aspects:</label>
                        <div class="lobby-checkboxes">
                            <label><input type="checkbox" id="lobby-aspect-glow" checked> Glow</label>
                            <label><input type="checkbox" id="lobby-aspect-void" checked> Void</label>
                            <label><input type="checkbox" id="lobby-aspect-gray" checked> Gray</label>
                        </div>
                    </div>
                    
                    <div class="lobby-setting-row">
                        <label>Allowed Types:</label>
                        <div class="lobby-checkboxes">
                            <label><input type="checkbox" id="lobby-type-avatar" checked> Avatar</label>
                            <label><input type="checkbox" id="lobby-type-spell" checked> Spell</label>
                            <label><input type="checkbox" id="lobby-type-domain" checked> Domain</label>
                            <label><input type="checkbox" id="lobby-type-relic" checked> Relic</label>
                        </div>
                    </div>
                </div>
                
                <button class="queue-btn" onclick="Game.createCustomLobby()">CREATE LOBBY</button>
            </div>
            
            <div id="lobby-browse-tab" class="lobby-tab-content hidden">
                <div id="lobby-list" class="lobby-list">
                    <p class="lobby-empty">No open lobbies available. Create one!</p>
                </div>
                <button class="queue-btn secondary" onclick="Game.refreshLobbies()">Refresh</button>
            </div>
            
            <button class="close-overlay-btn" onclick="Game.hideCustomLobby()">Back</button>
        </div>
    </div>
    
    <!-- Active Lobby Waiting Room -->
    <div id="lobby-waiting-overlay" class="overlay hidden">
        <div class="lobby-waiting-container">
            <h1 id="lobby-waiting-name">Custom Match</h1>
            <div class="lobby-waiting-info">
                <div class="lobby-rules-summary" id="lobby-rules-summary"></div>
                <div class="lobby-players">
                    <h3>Players</h3>
                    <div id="lobby-player-list"></div>
                </div>
            </div>
            <div class="lobby-waiting-actions">
                <button class="queue-btn" id="lobby-start-btn" onclick="Game.startCustomLobby()" disabled>Waiting for opponent...</button>
                <button class="queue-btn secondary" onclick="Game.leaveCustomLobby()">Leave Lobby</button>
            </div>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-option" data-action="play">Play Card</div>
        <div class="context-option" data-action="tap">Tap / Untap</div>
        <div class="context-option" data-action="flip">Flip</div>
        <div class="context-option" data-action="to-hand">To Hand</div>
        <div class="context-option" data-action="to-discard">To Graveyard</div>
        <div class="context-option" data-action="to-exile">To Exile</div>
    </div>

    <!-- Card Zoom Panel -->
    <div id="card-zoom-panel" class="hidden">
        <div class="zoom-close" onclick="Game.hideCardZoom()">&times;</div>
        <div class="zoom-content">
            <div class="zoom-image-container">
                <img id="zoom-card-image" src="" alt="Card">
            </div>
            <div class="zoom-details">
                <h2 id="zoom-card-name"></h2>
                <div class="zoom-stats">
                    <span id="zoom-card-type" class="zoom-type"></span>
                    <span id="zoom-card-aspect" class="zoom-aspect"></span>
                    <span id="zoom-card-cost" class="zoom-cost"></span>
                </div>
                <div id="zoom-card-stats-row" class="zoom-stats-row"></div>
                <div id="zoom-card-effect" class="zoom-effect"></div>
                <div id="zoom-card-rarity" class="zoom-rarity"></div>
            </div>
        </div>
    </div>

    <!-- Codex / Glossary Overlay -->
    <div id="codex-overlay" class="overlay hidden">
        <div class="codex-container">
            <div class="codex-header">
                <h1>ESSENCE CROWN CODEX</h1>
                <button class="codex-close" onclick="Game.toggleCodex()">&times;</button>
            </div>
            <div class="codex-tabs">
                <button class="codex-tab active" data-tab="basics">Basics</button>
                <button class="codex-tab" data-tab="cards">Card Types</button>
                <button class="codex-tab" data-tab="phases">Phases</button>
                <button class="codex-tab" data-tab="combat">Combat</button>
                <button class="codex-tab" data-tab="advanced">Advanced</button>
            </div>
            <div class="codex-content">
                <div class="codex-section active" id="codex-basics">
                    <h2>ESSENCE</h2>
                    <p>Your life total. Start with 20-25 based on your Deity. Reach 0 and you lose!</p>
                    
                    <h2>KUNDALINI (KL)</h2>
                    <p>Energy used to play cards. Starts at 3, grows each turn (max 13). Refills at Dawn phase.</p>
                    
                    <h2>ASPECTS</h2>
                    <p>The three cosmic forces that power all cards:</p>
                    <ul>
                        <li><span class="aspect-glow">GLOW</span> - Light and healing. When a Glow card enters, gain +1 Essence.</li>
                        <li><span class="aspect-void">VOID</span> - Darkness and destruction. When a Void card enters, opponent loses 1 Essence.</li>
                        <li><span class="aspect-gray">GRAY</span> - Balance and wisdom. When a Gray card enters, draw 1 card.</li>
                    </ul>
                    
                    <h2>DEITIES</h2>
                    <p>Your Sovereign - a powerful being with a Passive ability (always active) and a God Code (ultimate ability requiring 2 Overflow charges).</p>
                </div>
                
                <div class="codex-section" id="codex-cards">
                    <h2>AVATARS</h2>
                    <p>Creatures that fight for you. Have Attack/Health stats. Summoned to the Avatar Row (New Earth).</p>
                    <ul>
                        <li><strong>Guardian</strong> - Must be attacked first before other Avatars or your Deity.</li>
                        <li><strong>Beast</strong> - Synergizes with other Beast-type cards.</li>
                    </ul>
                    
                    <h2>DOMAINS</h2>
                    <p>Permanent locations that provide ongoing effects. Placed in the Domain slot.</p>
                    
                    <h2>SPELLS</h2>
                    <p>One-time effects that go to the Graveyard after use.</p>
                    <ul>
                        <li><strong>Normal Spell</strong> - Play during your Main phase.</li>
                        <li><strong>Quick Spell</strong> - Can respond to actions (adds to Shard Chain).</li>
                    </ul>
                    
                    <h2>RITUALS</h2>
                    <p>Powerful spells with additional costs (sacrifice, discard, etc.).</p>
                    
                    <h2>RELICS & CROWNS</h2>
                    <p>Equipment cards. Relics provide effects; Crowns are legendary artifacts with powerful abilities.</p>
                </div>
                
                <div class="codex-section" id="codex-phases">
                    <h2>DAWN PHASE</h2>
                    <p>Start of your turn. Your KL refills to max, KL max increases by 1 (up to 13). Start-of-turn triggers activate.</p>
                    
                    <h2>DRAW PHASE</h2>
                    <p>Draw 1 card from your deck. (First player skips draw on turn 1.)</p>
                    
                    <h2>MAIN PHASE</h2>
                    <p>Play cards, activate abilities, set up your board. Use KL to summon Avatars, cast Spells, play Domains.</p>
                    
                    <h2>CLASH PHASE</h2>
                    <p>Combat! Declare attacks with your Avatars. Target enemy Avatars or the enemy Deity (if no Guardians block).</p>
                    
                    <h2>TWILIGHT PHASE</h2>
                    <p>End of turn. End-of-turn effects trigger, then pass to opponent.</p>
                </div>
                
                <div class="codex-section" id="codex-combat">
                    <h2>DECLARING ATTACKS</h2>
                    <p>During Clash phase, tap your Avatars to attack. Newly summoned Avatars have "summoning sickness" and cannot attack.</p>
                    
                    <h2>GUARDIANS</h2>
                    <p>If your opponent has a Guardian, you MUST attack it first before targeting other Avatars or their Deity.</p>
                    
                    <h2>DAMAGE RESOLUTION</h2>
                    <p>Both the attacker and defender deal damage simultaneously. An Avatar with 0 or less Health is destroyed.</p>
                    
                    <h2>ATTACKING THE DEITY</h2>
                    <p>If no enemy Avatars remain (or Guardians are cleared), you can attack the enemy Deity directly, reducing their Essence!</p>
                </div>
                
                <div class="codex-section" id="codex-advanced">
                    <h2>SHARD CHAIN</h2>
                    <p>The stack/priority system. When you play a Quick Spell or ability, it goes on the Chain. Players alternate priority to respond. Resolves last-in, first-out (LIFO).</p>
                    
                    <h2>OVERFLOW</h2>
                    <p>When your KL exceeds 13, the excess becomes Overflow points. At 2 Overflow, you can use your Deity's God Code.</p>
                    
                    <h2>GOD CODE</h2>
                    <p>Your Deity's ultimate ability. Costs 2 Overflow charges. Extremely powerful, game-changing effects!</p>
                    
                    <h2>GRAVEYARD & BANISHED</h2>
                    <p>Destroyed cards go to Graveyard. Some effects "banish" cards (remove from game entirely).</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Viewer Modal -->
    <div id="profile-viewer-overlay" class="overlay hidden">
        <div class="profile-modal">
            <button class="close-btn" onclick="Game.closeProfileViewer()">√ó</button>
            <div class="profile-header">
                <div class="profile-avatar-section">
                    <div class="profile-avatar" id="profile-avatar">üëë</div>
                    <div class="profile-info">
                        <h1 id="profile-name">Player Name</h1>
                        <div class="profile-tier">
                            <span id="profile-tier">Bronze III</span>
                            <span id="profile-mmr">1000 MMR</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="profile-tabs">
                <button class="profile-tab active" onclick="Game.showProfileTab('stats')">Stats</button>
                <button class="profile-tab" onclick="Game.showProfileTab('cosmetics')">Cosmetics</button>
            </div>
            <div id="profile-stats-tab" class="profile-tab-content active">
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Wins</div>
                        <div class="stat-value" id="profile-wins">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Losses</div>
                        <div class="stat-value" id="profile-losses">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Win Rate</div>
                        <div class="stat-value" id="profile-winrate">0%</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Highest Tier</div>
                        <div class="stat-value" id="profile-highest">Bronze III</div>
                    </div>
                </div>
                <div class="matches-history">
                    <h3>Recent Matches</h3>
                    <div id="profile-match-history"></div>
                </div>
            </div>
            <div id="profile-cosmetics-tab" class="profile-tab-content">
                <div class="owned-cosmetics-grid" id="profile-cosmetics-grid"></div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Prompt -->
    <div id="fullscreen-prompt" class="overlay hidden">
        <div class="fullscreen-content">
            <h1>Enter Fullscreen</h1>
            <p>For the best experience, play in fullscreen mode</p>
            <div class="fullscreen-buttons">
                <button class="fullscreen-btn" onclick="Game.requestFullscreen()">Enter Fullscreen</button>
                <button class="fullscreen-btn secondary" onclick="document.getElementById('fullscreen-prompt').classList.add('hidden'); Game.state.matchMode = 'casual'; Game.showDeitySelection(0);">Skip</button>
            </div>
        </div>
    </div>

    <!-- Mobile Navigation Tabs -->
    <div id="mobile-tabs" class="mobile-tabs">
        <button class="mobile-tab active" data-panel="hand">Hand</button>
        <button class="mobile-tab" data-panel="chain">Chain</button>
        <button class="mobile-tab" data-panel="log">Log</button>
    </div>
    
    <script>
console.log("Essence Crown ‚Äì IONOS standalone loaded.");
// Essence Crown: Shard Wars - Card Database
// Generated from official card data
// Total: 109 playable cards + 11 deities
// Last updated: 2025-12-02

// === CARD DATA START ===
const CARD_BACK_IMAGE = 'https://cdn1.sharemyimage.com/2025/12/02/Back.png';

const CARD_DATABASE = [
    {
        id: 'EC-003',
        name: 'Second Sun Vanguard',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 2,
        power: 3,
        toughness: 2,
        domain: 'Second Sun',
        effect: 'When Second Sun Vanguard attacks for the first time each turn, it deals +1 Essence damage to the defending Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/3.png'
    },
    {
        id: 'EC-004',
        name: 'Shardstorm Lancer',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 3,
        power: 4,
        toughness: 2,
        domain: 'New Earth',
        effect: 'On Play: Deal 1 Essence damage to target Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/4.png'
    },
    {
        id: 'EC-005',
        name: 'Gray Threshold Adept',
        type: 'Avatar',
        rarity: 'Shard',
        aspects: ['Gray'],
        cost: 1,
        power: 1,
        toughness: 2,
        domain: 'Threshold',
        effect: 'On Play: You gain +1 KL this turn. (KL gained this way can exceed your current KL but not your KL maximum.)',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/5.png'
    },
    {
        id: 'EC-006',
        name: 'Abyssal Crownfeeder',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Null Abyss',
        effect: 'Whenever Abyssal Crownfeeder deals Essence damage to a Deity, you gain 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/6.png'
    },
    {
        id: 'EC-007',
        name: 'New Earth Guardian',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 2,
        power: 2,
        toughness: 3,
        domain: 'New Earth',
        effect: 'Guardian (While this Avatar is on New Earth, your opponent must target it with their first attack each turn if able).',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/7.png'
    },
    {
        id: 'EC-008',
        name: 'Solar Street Saint',
        type: 'Avatar',
        rarity: 'Shard',
        aspects: ['Glow'],
        cost: 1,
        power: 2,
        toughness: 1,
        domain: 'Second Sun',
        effect: 'On Play: If you have attacked this game, gain 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/8.png'
    },
    {
        id: 'EC-009',
        name: 'Crownline Courier',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 2,
        power: 2,
        toughness: 2,
        domain: 'Crownline',
        effect: 'On Play: Look at the top 2 cards of your deck. Put 1 into your hand and the other on the bottom of your deck.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/9.png'
    },
    {
        id: 'EC-010',
        name: 'Radiant Shard Titan',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Glow'],
        cost: 5,
        power: 6,
        toughness: 5,
        domain: 'Second Sun',
        effect: 'On Play: Your other Glow Avatars gain +1 Power until end of turn. When Radiant Shard Titan attacks, it deals 1 Essence damage to the defending Deity before combat damage.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/10.png'
    },
    {
        id: 'EC-011',
        name: 'Shard Medics of Solara',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 2,
        power: 1,
        toughness: 3,
        domain: 'Solara',
        effect: 'On Play: Restore 2 Essence to your Deity. When Shard Medics of Solara leaves New Earth, restore 1 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/11.png'
    },
    {
        id: 'EC-012',
        name: 'Solar Flare Surge',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 2,
        domain: 'Second Sun',
        effect: 'Deal 3 Essence damage to target Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/12.png'
    },
    {
        id: 'EC-013',
        name: 'Crown Equilibrium',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 2,
        domain: 'Crown',
        effect: 'Both Deities gain 2 Essence. Draw a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/13.png'
    },
    {
        id: 'EC-014',
        name: 'Essence Rally',
        type: 'Spell',
        rarity: 'Shard',
        aspects: ['Glow'],
        cost: 1,
        domain: 'New Earth',
        effect: 'Up to two Glow Avatars you control get +1 Power until end of turn. If you attacked this turn, gain 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/14.png'
    },
    {
        id: 'EC-015',
        name: 'Second Sun Blessing',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 2,
        domain: 'Second Sun',
        effect: 'Restore 3 Essence to your Deity. If you control 3 or more Glow Avatars, instead restore 4 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/15.png'
    },
    {
        id: 'EC-016',
        name: 'Shardline Charge',
        type: 'Spell',
        rarity: 'Shard',
        aspects: ['Glow'],
        cost: 1,
        domain: 'New Earth',
        effect: 'Target Avatar gains +2 Power and "When this Avatar deals Essence damage to a Deity this turn, draw a card."',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/16.png'
    },
    {
        id: 'EC-017',
        name: 'New Earth Resync',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 2,
        domain: 'New Earth',
        effect: 'Choose one: ‚Ä¢ Restore 2 Essence to your Deity, then you gain +1 KL this turn. ‚Ä¢ Restore 1 Essence to each Deity and draw a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/17.png'
    },
    {
        id: 'EC-018',
        name: 'KL Ignition',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 1,
        domain: 'Crownline',
        effect: 'You gain +2 KL this turn. At end of turn, lose 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/18.png'
    },
    {
        id: 'EC-019',
        name: 'Crown‚Äôs Protection Protocol',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 2,
        domain: 'Crown',
        effect: 'Choose up to two Avatars you control. They gain ‚ÄúThis Avatar cannot be destroyed by Spells this turn.‚Äù',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/19.png'
    },
    {
        id: 'EC-020',
        name: 'Solar Rewrite',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 3,
        domain: 'Second Sun / Nullgrid',
        effect: 'Look at the top 4 cards of your deck. You may reveal up to 2 Glow or Gray cards from among them and put them into your hand. Put the rest on the bottom of your deck in any order.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/20.png'
    },
    {
        id: 'EC-021',
        name: 'Nullblade Stalker',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 2,
        power: 2,
        toughness: 3,
        domain: 'Nullgrid',
        effect: 'Whenever Nullblade Stalker deals Essence damage to a Deity, that Deity‚Äôs controller loses 1 KL.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/21.png'
    },
    {
        id: 'EC-022',
        name: 'Grid Siphon Scribe',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 2,
        power: 1,
        toughness: 3,
        domain: 'Nullgrid',
        effect: 'On Play: Target opponent loses 1 KL. Whenever an opponent loses KL, Grid Siphon Scribe gets +1 Power until end of turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/22.png'
    },
    {
        id: 'EC-023',
        name: 'Shard Jailer of the Null',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 3,
        power: 2,
        toughness: 4,
        domain: 'Null Abyss',
        effect: 'On Play: Choose an Avatar an opponent controls with cost 2 or less. That Avatar cannot attack while Shard Jailer of the Null remains on New Earth.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/23.png'
    },
    {
        id: 'EC-024',
        name: 'Voidline Saboteur',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 2,
        power: 2,
        toughness: 2,
        domain: 'Nullgrid',
        effect: 'On Play: Look at the top card of target opponent‚Äôs deck. You may place it on the bottom of their deck.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/24.png'
    },
    {
        id: 'EC-025',
        name: 'Crown Auditor',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 2,
        power: 2,
        toughness: 2,
        domain: 'Crownline',
        effect: 'On Play: Look at the top 2 cards of your deck. You may reveal a Spell from among them and put it into your hand. Put the rest back in any order.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/25.png'
    },
    {
        id: 'EC-026',
        name: 'Obsidian Shard Colossus',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Void'],
        cost: 5,
        power: 5,
        toughness: 6,
        domain: 'Null Abyss',
        effect: 'On Play: Each opponent loses 2 Essence. Whenever Obsidian Shard Colossus attacks, you may drain 1 KL from the defending player.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/26.png'
    },
    {
        id: 'EC-027',
        name: 'Nullgrid Warden',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 2,
        power: 1,
        toughness: 4,
        domain: 'Nullgrid',
        effect: 'Guardian. Whenever Nullgrid Warden is dealt damage, its controller gains 1 KL.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/27.png'
    },
    {
        id: 'EC-028',
        name: 'Void Collapse',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 3,
        domain: 'Null Abyss',
        effect: 'Target opponent loses 2 Essence and 1 KL. If that opponent has 10 or less Essence, they lose an additional 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/28.png'
    },
    {
        id: 'EC-029',
        name: 'Grid Snuff',
        type: 'Spell',
        rarity: 'Shard',
        aspects: ['Void'],
        cost: 1,
        domain: 'Nullgrid',
        effect: 'Destroy target Avatar with cost 1 or less. If that Avatar was Glow, its controller loses 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/29.png'
    },
    {
        id: 'EC-030',
        name: 'Essence Leak',
        type: 'Spell',
        rarity: 'Shard',
        aspects: ['Void'],
        cost: 1,
        domain: 'Null Abyss',
        effect: 'Target opponent loses 2 Essence. You lose 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/30.png'
    },
    {
        id: 'EC-031',
        name: 'Null Directive',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 2,
        domain: 'Nullgrid',
        effect: 'Choose one: ‚Ä¢ Destroy target Avatar with cost 3 or less. ‚Ä¢ Target opponent discards a card at random.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/31.png'
    },
    {
        id: 'EC-032',
        name: 'Shard Confiscation',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 2,
        domain: 'Crownline / Nullgrid',
        effect: 'Look at target opponent‚Äôs hand. Choose a card with cost 3 or less. That player discards that card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/32.png'
    },
    {
        id: 'EC-033',
        name: 'KL Blackout',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 2,
        domain: 'Null Abyss',
        effect: 'Until your next turn, target opponent‚Äôs KL maximum is reduced by 2 (to a minimum of 1). Draw a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/33.png'
    },
    {
        id: 'EC-034',
        name: 'Grayscale Arbitration',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 3,
        domain: 'Gray Court',
        effect: 'Destroy target Avatar with cost 4 or more. Each Deity loses 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/34.png'
    },
    {
        id: 'EC-035',
        name: 'Crown Audit',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 1,
        domain: 'Crownline',
        effect: 'Look at the top 3 cards of your deck. Reveal a Void or Gray card from among them and put it into your hand. Put the rest on the bottom of your deck in any order.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/35.png'
    },
    {
        id: 'EC-042',
        name: 'Shardline Sprinter',
        type: 'Avatar',
        rarity: 'Shard',
        aspects: ['Glow'],
        cost: 1,
        power: 1,
        toughness: 2,
        domain: 'New Earth',
        effect: 'Shardline Sprinter gets +1 Power while you control another attacking Avatar.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/42.png'
    },
    {
        id: 'EC-043',
        name: 'Second Sun Skyspear',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Second Sun',
        effect: 'On Play: You may deal 1 damage to target Avatar. If that Avatar is destroyed this way, gain 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/43.png'
    },
    {
        id: 'EC-044',
        name: 'Crown Halo Escort',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow', 'Gray'],
        cost: 2,
        power: 2,
        toughness: 2,
        domain: 'Crownline',
        effect: 'Guardian. When Crown Halo Escort enters New Earth, restore 1 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/44.png'
    },
    {
        id: 'EC-045',
        name: 'Solar Courier Knight',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 2,
        power: 3,
        toughness: 1,
        domain: 'Crownline / Logistics',
        effect: 'On Play: You may draw a card, then discard a card. Whenever Solar Courier Knight deals Essence damage to a Deity, you may scry 1 (look at the top card of your deck; you may put it on the bottom).',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/45.png'
    },
    {
        id: 'EC-046',
        name: 'Beacon of New Earth',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Glow'],
        cost: 4,
        power: 3,
        toughness: 5,
        domain: 'New Earth',
        effect: 'On Play: Restore 3 Essence to your Deity. While Beacon of New Earth is on New Earth, your other Avatars get +0/+1.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/46.png'
    },
    {
        id: 'EC-047',
        name: 'Twin-Sun Duelist',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Second Sun',
        effect: 'When Twin-Sun Duelist attacks, if you played a Spell this turn, it gains +1 Power until end of turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/47.png'
    },
    {
        id: 'EC-048',
        name: 'Streetlight Herald',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow', 'Gray'],
        cost: 2,
        power: 2,
        toughness: 2,
        domain: 'Second Sun / Gray Court',
        effect: 'On Play: If you have fewer cards in hand than an opponent, draw a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/48.png'
    },
    {
        id: 'EC-049',
        name: 'Radiant Crown Beast',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Glow', 'Beast'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Pet Sanctuary',
        effect: 'On Play: If you control another Beast, restore 2 Essence to your Deity. Whenever Radiant Crown Beast attacks, you may give another attacking Beast +1 Power until end of turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/49.png'
    },
    {
        id: 'EC-050',
        name: 'Solara Gatekeeper',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Glow', 'Gray'],
        cost: 4,
        power: 4,
        toughness: 4,
        domain: 'Solara',
        effect: 'Guardian. On Play: You may destroy target Avatar with cost 2 or less.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/50.png'
    },
    {
        id: 'EC-051',
        name: 'Nullgrid Tracker',
        type: 'Avatar',
        rarity: 'Shard',
        aspects: ['Void'],
        cost: 1,
        power: 1,
        toughness: 2,
        domain: 'Nullgrid',
        effect: 'On Play: Look at the top card of your deck. You may put it on the bottom of your deck.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/51.png'
    },
    {
        id: 'EC-052',
        name: 'Shard Interrogator',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 3,
        power: 3,
        toughness: 2,
        domain: 'Null Abyss',
        effect: 'On Play: Target opponent reveals their hand. Choose a non-Avatar card from it. That player discards that card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/52.png'
    },
    {
        id: 'EC-053',
        name: 'Abyssal Archivist',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void', 'Gray'],
        cost: 3,
        power: 2,
        toughness: 3,
        domain: 'Null Abyss / Gray Court',
        effect: 'On Play: You may return a Spell card from your discard pile to your hand.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/53.png'
    },
    {
        id: 'EC-054',
        name: 'Crown Grid Warden',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 4,
        power: 3,
        toughness: 5,
        domain: 'Nullgrid / Crownline',
        effect: 'Guardian. Whenever an opponent draws their second card in a single turn, they lose 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/54.png'
    },
    {
        id: 'EC-055',
        name: 'Shardbreaker Inquisitor',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 3,
        power: 4,
        toughness: 2,
        domain: 'Null Abyss',
        effect: 'Whenever Shardbreaker Inquisitor destroys an Avatar, that Avatar‚Äôs controller loses 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/55.png'
    },
    {
        id: 'EC-056',
        name: 'Void Courier Shade',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 2,
        power: 1,
        toughness: 3,
        domain: 'Logistics / Nullgrid',
        effect: 'On Play: You may move 1 Essence from your Deity to target opponent‚Äôs Deity. Whenever you lose Essence outside of combat, Void Courier Shade gets +1 Power until end of turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/56.png'
    },
    {
        id: 'EC-057',
        name: 'Null Rift Hound',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void', 'Beast'],
        cost: 2,
        power: 3,
        toughness: 1,
        domain: 'Sanctuary Void',
        effect: 'When Null Rift Hound enters New Earth, target opponent loses 1 Essence. When Null Rift Hound dies, you may drain 1 KL from target opponent.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/57.png'
    },
    {
        id: 'EC-058',
        name: 'Shardline Reaper',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 4,
        power: 4,
        toughness: 3,
        domain: 'Null Abyss',
        effect: 'On Play: Destroy target Avatar with cost 2 or less. Whenever Shardline Reaper attacks, each player loses 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/58.png'
    },
    {
        id: 'EC-059',
        name: 'Gridlock Titan',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Void', 'Gray'],
        cost: 6,
        power: 6,
        toughness: 7,
        domain: 'Nullgrid / Gray Court',
        effect: 'On Play: Until your next turn, opponents cannot gain KL above their starting KL. Whenever an opponent spends KL, they lose 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/59.png'
    },
    {
        id: 'EC-060',
        name: 'Crown Ledger Keeper',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 2,
        power: 1,
        toughness: 3,
        domain: 'Crownline',
        effect: 'On Play: Draw a card, then discard a card. Whenever you discard a card, you may gain 1 KL this turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/60.png'
    },
    {
        id: 'EC-061',
        name: 'Gray Court Mediator',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 3,
        power: 2,
        toughness: 4,
        domain: 'Gray Court',
        effect: 'On Play: Each player restores 1 Essence. Whenever a Spell is played, you may have each Deity lose 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/61.png'
    },
    {
        id: 'EC-062',
        name: 'Shard Statistician',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 2,
        power: 2,
        toughness: 2,
        domain: 'Crownline',
        effect: 'On Play: Look at the top 3 cards of your deck. You may reveal an Avatar from among them and put it into your hand. Put the rest back on top in any order.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/62.png'
    },
    {
        id: 'EC-063',
        name: 'Pet Sanctuary Caretaker',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Gray', 'Beast'],
        cost: 2,
        power: 1,
        toughness: 3,
        domain: 'Pet Sanctuary',
        effect: 'On Play: Restore 1 Essence to each Deity. Whenever a Beast you control dies, you may restore 1 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/63.png'
    },
    {
        id: 'EC-064',
        name: 'Grayline Arbiter',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 4,
        power: 3,
        toughness: 4,
        domain: 'Gray Court',
        effect: 'On Play: Choose an Avatar. Its Power becomes 2 and its Toughness becomes 2 until Grayline Arbiter leaves New Earth.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/64.png'
    },
    {
        id: 'EC-065',
        name: 'Crown Data Analyst',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 3,
        power: 1,
        toughness: 4,
        domain: 'Crownline',
        effect: 'On Play: Look at the top 5 cards of your deck. You may reveal up to 2 non-Avatar cards from among them and put them into your hand. Put the rest on the bottom of your deck in any order.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/65.png'
    },
    {
        id: 'EC-066',
        name: 'Logistics Coordinator',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 2,
        power: 2,
        toughness: 2,
        domain: 'Logistics',
        effect: 'On Play: You may move 1 Essence from one Deity to another (you choose the source and recipient).',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/66.png'
    },
    {
        id: 'EC-067',
        name: 'Gray Shard Sentinel',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Gray Court',
        effect: 'Guardian. Whenever Gray Shard Sentinel blocks, you may draw a card, then discard a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/67.png'
    },
    {
        id: 'EC-068',
        name: 'Crown Equilibrium Adept',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 3,
        power: 2,
        toughness: 3,
        domain: 'Crownline',
        effect: 'On Play: If your Deity has more Essence than an opponent‚Äôs Deity, you lose 2 Essence and draw 2 cards. Otherwise, restore 2 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/68.png'
    },
    {
        id: 'EC-072',
        name: 'Kaixu‚Äôs Shardborne Avatar',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Glow', 'Void'],
        cost: 4,
        power: 4,
        toughness: 4,
        domain: 'Shattered Sun',
        effect: 'On Play: If your Deity is Demon Lord Kaixu, Crownshatter Sovereign, you may play this card for 3 KL instead. Whenever you play your second card in a turn, Kaixu‚Äôs Shardborne Avatar gets +2 Power until end of turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/72.png'
    },
    {
        id: 'EC-073',
        name: 'Parallel Self of Kaixu',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Glow', 'Void', 'Gray'],
        cost: 5,
        power: 3,
        toughness: 5,
        domain: 'Shattered Sun',
        effect: 'On Play: Copy the Passive ability of your Deity until end of turn. (It triggers as though this Avatar were your Deity.) Whenever you activate a God Code, Parallel Self of Kaixu gains +3 Power and cannot be destroyed this turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/73.png'
    },
    {
        id: 'EC-074',
        name: 'Crownshatter Executioner',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Crownline / Null Abyss',
        effect: 'Whenever you choose one or more modes or choices for a card‚Äôs effect, an opponent loses 1 Essence. On Play: If your Deity is Demon Lord Kaixu, Crownshatter Sovereign, destroy target Avatar with cost 3 or less.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/74.png'
    },
    {
        id: 'EC-075',
        name: 'Kaixu‚Äôs Edict: Board Reset',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Gray', 'Void'],
        cost: 5,
        domain: 'Shattered Sun',
        effect: 'Destroy all Avatars. Each Deity loses 3 Essence. If your Deity is Demon Lord Kaixu, Crownshatter Sovereign, instead each opponent loses 5 Essence and you may keep one Avatar you control.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/75.png'
    },
    {
        id: 'EC-076',
        name: 'Shattered Sun Cataclysm',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Glow', 'Void', 'Gray'],
        cost: 6,
        domain: 'Shattered Sun',
        effect: 'Each opponent sacrifices two Avatars, then loses 3 KL. Your Avatars gain +2 Power until end of turn. If your Deity is Demon Lord Kaixu, Crownshatter Sovereign, draw 2 cards.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/76.png'
    },
    {
        id: 'EC-077',
        name: 'Estifar‚Äôs Voidwing Alpha',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Void', 'Beast'],
        cost: 4,
        power: 4,
        toughness: 3,
        domain: 'Sanctuary Void',
        effect: 'On Play: Create a 2/2 Void Beast Avatar token. Beasts you control have ‚ÄúWhen this Avatar dies, target opponent loses 1 Essence.‚Äù If your Deity is Estifar, Voidwing Regent, your first Beast each turn costs 1 less KL to play.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/77.png'
    },
    {
        id: 'EC-078',
        name: 'Moonpack Howler',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void', 'Beast'],
        cost: 2,
        power: 2,
        toughness: 2,
        domain: 'Sanctuary Void',
        effect: 'Whenever another Beast enters New Earth under your control, Moonpack Howler gets +1 Power until end of turn. If your Deity is Estifar, Voidwing Regent, it also restores 1 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/78.png'
    },
    {
        id: 'EC-079',
        name: 'Sanctuary Packmother',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Void', 'Gray', 'Beast'],
        cost: 5,
        power: 3,
        toughness: 5,
        domain: 'Sanctuary Void',
        effect: 'On Play: Create two 2/2 Void Beast Avatar tokens. At the beginning of your end step, if three or more Beasts died this turn, restore 3 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/79.png'
    },
    {
        id: 'EC-080',
        name: 'Estifar‚Äôs Call: Pack Ascension',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Void', 'Gray'],
        cost: 4,
        domain: 'Sanctuary Void',
        effect: 'Create two 3/3 Void Beast Avatar tokens with Guardian. If your Deity is Estifar, Voidwing Regent, your Beasts get +1 Power and ‚ÄúWhen this Avatar dies, draw a card‚Äù until end of turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/80.png'
    },
    {
        id: 'EC-081',
        name: 'Voidwing Stampede',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 3,
        domain: 'Sanctuary Void',
        effect: 'Beasts you control get +2 Power until end of turn. Each Beast that deals Essence damage to a Deity this turn causes that Deity‚Äôs controller to lose 1 KL.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/1-1.png'
    },
    {
        id: 'EC-082',
        name: 'Lokaya‚Äôs Stillpoint Avatar',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Gray', 'Glow'],
        cost: 4,
        power: 2,
        toughness: 5,
        domain: 'Gray Court / New Earth',
        effect: 'On Play: Tap up to two Avatars you don‚Äôt control. They do not untap during their controller‚Äôs next untap step. At the end of your turn, if no Avatar you control attacked this turn, restore 1 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/2-1.png'
    },
    {
        id: 'EC-083',
        name: 'Silent Crown Arbiter',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Gray'],
        cost: 5,
        power: 3,
        toughness: 6,
        domain: 'Gray Court',
        effect: 'On Play: Choose up to two Spells. They cannot be played until your next turn. As long as Silent Crown Arbiter is on New Earth, players can play only one Spell per turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/3-1.png'
    },
    {
        id: 'EC-084',
        name: 'New Earth Monk of Stillness',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Glow', 'Gray'],
        cost: 2,
        power: 1,
        toughness: 4,
        domain: 'New Earth',
        effect: 'Guardian. At the end of your turn, if no Avatar you control attacked this turn, you may draw a card, then discard a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/4-1.png'
    },
    {
        id: 'EC-085',
        name: 'Lokaya‚Äôs Edict: Be Still',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Gray'],
        cost: 3,
        domain: 'Gray Court',
        effect: 'Tap up to three Avatars you don‚Äôt control. Those Avatars cannot attack during their controller‚Äôs next turn. If your Deity is Lokaya, Crown of Stillness, restore 3 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/5-1.png'
    },
    {
        id: 'EC-086',
        name: 'Crown of Quiet Worlds',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Gray', 'Glow'],
        cost: 4,
        domain: 'Gray Court / New Earth',
        effect: 'Until your next turn, players cannot declare more than one attack per turn. If no Avatar you control attacks this turn, at the beginning of your next turn draw 2 cards and restore 2 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/6-1.png'
    },
    {
        id: 'EC-087',
        name: 'Second Sun Street Brawler',
        type: 'Avatar',
        rarity: 'Shard',
        aspects: ['Glow'],
        cost: 2,
        power: 3,
        toughness: 1,
        domain: 'Second Sun',
        effect: 'Whenever Second Sun Street Brawler deals Essence damage to a Deity, you gain +1 KL this turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/7-1.png'
    },
    {
        id: 'EC-088',
        name: 'New Earth Rally Captain',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Glow'],
        cost: 3,
        power: 2,
        toughness: 4,
        domain: 'New Earth',
        effect: 'On Play: Until end of turn, Avatars you control get +1 Power. Whenever three or more Avatars you control attack in the same turn, restore 2 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/8-1.png'
    },
    {
        id: 'EC-089',
        name: 'Solara Crown Paladin',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Glow', 'Gray'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Solara / Crownline',
        effect: 'Guardian. While Solara Crown Paladin is on New Earth, damage that would reduce your Deity‚Äôs Essence to 0 reduces it to 1 instead (once per game).',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/9-1.png'
    },
    {
        id: 'EC-090',
        name: 'Sanctuary Sunpride',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Glow', 'Beast'],
        cost: 4,
        power: 4,
        toughness: 4,
        domain: 'Pet Sanctuary',
        effect: 'On Play: Restore 2 Essence to your Deity. Beasts you control get +1 Power while attacking Deities.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/10-1.png'
    },
    {
        id: 'EC-091',
        name: 'Second Sun Charge Line',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Glow'],
        cost: 2,
        domain: 'Second Sun',
        effect: 'Up to two target Avatars you control get +2 Power until end of turn. If both attack this turn, draw a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/11-1.png'
    },
    {
        id: 'EC-092',
        name: 'Essence Crown Strike',
        type: 'Spell',
        rarity: 'Shard',
        aspects: ['Glow'],
        cost: 1,
        domain: 'Crownline / Second Sun',
        effect: 'Deal 2 Essence damage to target Deity or Avatar. If you target a Deity, you lose 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/12-1.png'
    },
    {
        id: 'EC-093',
        name: 'New Earth Reprieve',
        type: 'Spell',
        rarity: 'Shard',
        aspects: ['Glow', 'Gray'],
        cost: 1,
        domain: 'New Earth / Gray Court',
        effect: 'Restore 2 Essence to your Deity. If an opponent has more Essence than you, restore 3 Essence instead.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/13-1.png'
    },
    {
        id: 'EC-094',
        name: 'Solar Uprising',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Glow'],
        cost: 4,
        domain: 'Second Sun / New Earth',
        effect: 'Until end of turn, Avatars you control get +1 Power and ‚ÄúWhenever this Avatar deals Essence damage to a Deity this turn, that Deity loses 1 additional Essence.‚Äù',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/14-1.png'
    },
    {
        id: 'EC-095',
        name: 'Null Alley Cutthroat',
        type: 'Avatar',
        rarity: 'Shard',
        aspects: ['Void'],
        cost: 2,
        power: 2,
        toughness: 1,
        domain: 'Nullgrid',
        effect: 'Whenever Null Alley Cutthroat attacks and isn‚Äôt blocked, target opponent loses 1 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/15-1.png'
    },
    {
        id: 'EC-096',
        name: 'Abyss Courier Hunter',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Null Abyss / Logistics',
        effect: 'On Play: Target opponent discards a card. If they cannot, they lose 2 Essence instead.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/16-1.png'
    },
    {
        id: 'EC-097',
        name: 'Shard Debt Collector',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void', 'Gray'],
        cost: 4,
        power: 3,
        toughness: 4,
        domain: 'Nullgrid / Crownline',
        effect: 'On Play: Target opponent loses 1 Essence for each card in your discard pile, up to 3. Whenever an opponent discards a card, restore 1 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/17-1.png'
    },
    {
        id: 'EC-098',
        name: 'Abyssal Faultline Mage',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 4,
        power: 3,
        toughness: 4,
        domain: 'Null Abyss',
        effect: 'On Play: Choose one ‚Äî ‚Ä¢ Destroy target Avatar with cost 3 or less. ‚Ä¢ Each opponent discards a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/18-1.png'
    },
    {
        id: 'EC-099',
        name: 'Void Ledger Wipe',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Void', 'Gray'],
        cost: 3,
        domain: 'Null Abyss / Gray Court',
        effect: 'Each player discards two cards. Then you may return a Void or Gray card from your discard pile to your hand.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/19-1.png'
    },
    {
        id: 'EC-100',
        name: 'Essence Ransom',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Void'],
        cost: 2,
        domain: 'Nullgrid',
        effect: 'Target opponent chooses one ‚Äî ‚Ä¢ They lose 3 Essence. ‚Ä¢ They lose 1 KL and you draw 2 cards.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/20-1.png'
    },
    {
        id: 'EC-101',
        name: 'Nullgrid Surge',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 1,
        domain: 'Nullgrid',
        effect: 'Target opponent loses 1 Essence and 1 KL. If they have 10 or less Essence, they lose 1 additional Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/21-1.png'
    },
    {
        id: 'EC-102',
        name: 'Abyssal Echoes',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Void'],
        cost: 2,
        domain: 'Null Abyss',
        effect: 'Return up to one Void Avatar and up to one Void Spell from your discard pile to your hand. Then lose 2 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/22-1.png'
    },
    {
        id: 'EC-103',
        name: 'Equity Scribe of Crownline',
        type: 'Avatar',
        rarity: 'Shard',
        aspects: ['Gray'],
        cost: 2,
        power: 1,
        toughness: 3,
        domain: 'Crownline',
        effect: 'On Play: If you have fewer cards in hand than an opponent, draw a card. Otherwise, discard a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/23-1.png'
    },
    {
        id: 'EC-104',
        name: 'Balancebreaker Advocate',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 3,
        power: 2,
        toughness: 3,
        domain: 'Gray Court',
        effect: 'On Play: The player with the highest Essence loses 2 Essence and the player with the lowest Essence gains 2 Essence. (You choose in ties.)',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/24-1.png'
    },
    {
        id: 'EC-105',
        name: 'Crownline Negotiator',
        type: 'Avatar',
        rarity: 'Adept',
        aspects: ['Gray'],
        cost: 3,
        power: 2,
        toughness: 4,
        domain: 'Crownline',
        effect: 'Whenever an opponent loses Essence during your turn, you may gain 1 KL this turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/25-1.png'
    },
    {
        id: 'EC-106',
        name: 'Gray Court Archivist',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 4,
        power: 2,
        toughness: 5,
        domain: 'Gray Court',
        effect: 'On Play: Look at the top 4 cards of your deck. You may reveal up to 2 Gray cards from among them and put them into your hand. Put the rest on the bottom of your deck in any order.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/26-1.png'
    },
    {
        id: 'EC-107',
        name: 'Gray Court Injunction',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Gray'],
        cost: 2,
        domain: 'Gray Court',
        effect: 'Choose Avatar or Spell. Until your next turn, each player can play only one card of the chosen type each turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/27-1.png'
    },
    {
        id: 'EC-108',
        name: 'Scales of New Earth',
        type: 'Spell',
        rarity: 'Adept',
        aspects: ['Gray', 'Glow'],
        cost: 3,
        domain: 'New Earth / Gray Court',
        effect: 'Each player may restore up to 3 Essence to their Deity. For each opponent who does, draw a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/28-1.png'
    },
    {
        id: 'EC-109',
        name: 'Crownline Reallocator',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Gray', 'Void'],
        cost: 2,
        domain: 'Crownline / Nullgrid',
        effect: 'Move up to 3 Essence among Deities as you choose.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/29-1.png'
    },
    {
        id: 'EC-110',
        name: 'Shard of Probabilities',
        type: 'Spell',
        rarity: 'Shard',
        aspects: ['Gray'],
        cost: 1,
        domain: 'Gray Court',
        effect: 'Look at the top 2 cards of your deck. Put one into your hand and the other on the bottom of your deck.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/30-1.png'
    },
    {
        id: 'EC-111',
        name: 'Shard War Envoy',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Glow', 'Void'],
        cost: 3,
        power: 3,
        toughness: 3,
        domain: 'Shattered Sun',
        effect: 'On Play: Each player loses 1 Essence. Whenever you play both a Glow card and a Void card in the same turn, Shard War Envoy gets +2 Power until end of turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/31-1.png'
    },
    {
        id: 'EC-112',
        name: 'Null-Crown Diplomat',
        type: 'Avatar',
        rarity: 'Master',
        aspects: ['Void', 'Gray'],
        cost: 3,
        power: 2,
        toughness: 4,
        domain: 'Nullgrid / Crownline',
        effect: 'On Play: Target opponent discards a card unless they choose to restore 2 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/32-1.png'
    },
    {
        id: 'EC-113',
        name: 'Radiant Equilibrium Sage',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Glow', 'Gray'],
        cost: 4,
        power: 3,
        toughness: 4,
        domain: 'Second Sun / Gray Court',
        effect: 'On Play: Set each Deity‚Äôs Essence to the average (rounded down) of all Deities‚Äô Essence values. Whenever your Deity gains Essence, you may draw a card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/33-1.png'
    },
    {
        id: 'EC-114',
        name: 'Shattered Triune Avatar',
        type: 'Avatar',
        rarity: 'Mythic',
        aspects: ['Glow', 'Void', 'Gray'],
        cost: 5,
        power: 4,
        toughness: 4,
        domain: 'Shattered Sun',
        effect: 'On Play: Choose one ‚Äî ‚Ä¢ Draw 2 cards. ‚Ä¢ Target opponent discards 2 cards. ‚Ä¢ Restore 4 Essence to your Deity. Whenever you play your third card in a turn, you may choose one of these modes that hasn‚Äôt been chosen this game.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/34-1.png'
    },
    {
        id: 'EC-115',
        name: 'God Code Catalyst',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Glow', 'Void', 'Gray'],
        cost: 3,
        domain: 'Crownline / Shattered Sun',
        effect: 'Until end of turn, whenever you gain KL, you gain that much +1 instead. If your KL would go above 13 this turn and you have not activated your Deity‚Äôs God Code yet, you may activate it as though its condition were met.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/35-1.png'
    },
    {
        id: 'EC-116',
        name: 'Crown Synchrony Protocol',
        type: 'Spell',
        rarity: 'Master',
        aspects: ['Glow', 'Gray'],
        cost: 2,
        domain: 'Crownline / New Earth',
        effect: 'Choose up to two Avatars you control. Until end of turn, whenever one of them deals Essence damage to a Deity, restore 1 Essence to your Deity and that Avatar gets +1 Power.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/36-1.png'
    },
    {
        id: 'EC-117',
        name: 'Relic of the Second Sun',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Glow'],
        cost: 3,
        domain: 'Second Sun',
        effect: 'Until end of turn, whenever you play a Glow card, draw a card, then discard a card. If your Deity is Demon Lord Kaixu, Crownshatter Sovereign or Shattered Sun Chronicler, Glow Avatars you control also get +1 Power this turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/37-1.png'
    },
    {
        id: 'EC-118',
        name: 'Relic of the Voidwing',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Void'],
        cost: 3,
        domain: 'Sanctuary Void / Null Abyss',
        effect: 'Until end of turn, whenever a Beast you control dies, target opponent loses 1 Essence and you gain +1 KL this turn.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/38-1.png'
    },
    {
        id: 'EC-119',
        name: 'Relic of Still Waters',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Gray'],
        cost: 3,
        domain: 'Gray Court / New Earth',
        effect: 'Until your next turn, whenever an opponent declares an attack with exactly one Avatar, tap that Avatar and it does not attack. Restore 1 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/39-1.png'
    },
    {
        id: 'EC-120',
        name: 'Crown of Shard Unity',
        type: 'Spell',
        rarity: 'Mythic',
        aspects: ['Glow', 'Void', 'Gray'],
        cost: 4,
        domain: 'Crownline / Shattered Sun',
        effect: 'Choose up to three Avatars you control. They become Glow, Void, and Gray in addition to their other aspects until end of turn and get +1 Power. Draw a card for each different aspect among Avatars you control (maximum 3).',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/40-1.png'
    },
];

// Shardstorm expansion placeholder block (keeps engine object shape)
const SHARDSTORM_EXPANSION = [];

// Append expansion cards to the main database
CARD_DATABASE.push(...SHARDSTORM_EXPANSION);

const DEITY_DATABASE = [
    {
        id: 'EC-001',
        name: 'Second Sun Herald',
        type: 'Deity',
        rarity: 'Mythic',
        aspects: ['Glow', 'Gray'],
        essence: 23,
        startingKL: 3,
        domain: 'Second Sun',
        effect: 'Passive ‚Äì Solar Flow: At the start of your turn, if you control at least one Glow Avatar, gain +1 KL this turn. God Code ‚Äì Crown of the Second Sun (once per game): When your KL would go above 13, instead set it to 13 and your Avatars gain +2 Power until end of turn. Target opponent loses 4 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/1.png'
    },
    {
        id: 'EC-002',
        name: 'Null Regent',
        type: 'Deity',
        rarity: 'Mythic',
        aspects: ['Void', 'Gray'],
        essence: 23,
        startingKL: 3,
        domain: 'Nullgrid',
        effect: 'Passive ‚Äì Grid Drain: Whenever an enemy Avatar is destroyed, you may drain 1 KL from that Avatar‚Äôs controller. God Code ‚Äì Crown of Absolute Zero (once per game): When your KL would go above 13, instead set it to 13 and target opponent loses 3 KL and 3 Essence. Then you may destroy up to one Avatar they control with cost 3 or less.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/2.png'
    },
    {
        id: 'EC-036',
        name: 'Crown Arbiter of Gray',
        type: 'Deity',
        rarity: 'Mythic',
        aspects: ['Gray'],
        essence: 24,
        startingKL: 3,
        domain: 'Gray Court',
        effect: 'Passive ‚Äì Perfect Balance: At the end of each turn, if both Deities have the same Essence, you may draw a card. God Code ‚Äì Final Arbitration (once per game): When your KL would go above 13, instead set it to 13 and activate this. Set each Deity‚Äôs Essence to the lower of the two values, then you gain 3 Essence.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/36.png'
    },
    {
        id: 'EC-037',
        name: 'Solar Beast Warden',
        type: 'Deity',
        rarity: 'Mythic',
        aspects: ['Glow', 'Beast'],
        essence: 22,
        startingKL: 3,
        domain: 'Pet Sanctuary / New Earth',
        effect: 'Passive ‚Äì Packbond: Whenever a Beast Avatar enters New Earth under your control, restore 1 Essence to your Deity. God Code ‚Äì Call of the Crown Pride (once per game): Create up to three 2/2 Glow Beast Avatars with Guardian on New Earth. Restore 3 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/37.png'
    },
    {
        id: 'EC-038',
        name: 'Zero Gear Conductor',
        type: 'Deity',
        rarity: 'Mythic',
        aspects: ['Gray', 'Void'],
        essence: 23,
        startingKL: 3,
        domain: 'Zero Gear / Logistics',
        effect: 'Passive ‚Äì Calibrated Flow: Whenever you spend exactly all of your remaining KL to play a card, draw a card. God Code ‚Äì Absolute Schedule Lock (once per game): Target opponent‚Äôs next turn, they cannot gain KL above their starting KL that turn and cannot draw more than 1 card.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/38.png'
    },
    {
        id: 'EC-039',
        name: 'Executive Aura Regent',
        type: 'Deity',
        rarity: 'Mythic',
        aspects: ['Glow', 'Gray'],
        essence: 21,
        startingKL: 4,
        domain: 'Executive Crown',
        effect: 'Passive ‚Äì Presence of Wealth: Once per turn, when you play a Spell, you may gain 1 Essence. God Code ‚Äì Golden Aura Cascade (once per game): Your Avatars gain +1 Power and ‚ÄúWhen this Avatar deals Essence damage to a Deity this turn, restore 1 Essence to your Deity.‚Äù',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/39.png'
    },
    {
        id: 'EC-040',
        name: 'Shattered Sun Chronicler',
        type: 'Deity',
        rarity: 'Mythic',
        aspects: ['Glow', 'Void', 'Gray'],
        essence: 20,
        startingKL: 3,
        domain: 'Shattered Sun',
        effect: 'Passive ‚Äì Story of the Shards: Once per turn, when you play your second card that turn, draw a card. God Code ‚Äì Canon Rewrite (once per game): Exile your hand. Draw 5 cards. Until end of turn, your Spells cost 1 less KL (minimum 0).',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/40.png'
    },
    {
        id: 'EC-041',
        name: 'Crown of the Pet Void',
        type: 'Deity',
        rarity: 'Mythic',
        aspects: ['Void', 'Beast'],
        essence: 22,
        startingKL: 3,
        domain: 'Sanctuary Void',
        effect: 'Passive ‚Äì Dark Bond: Whenever a Beast Avatar you control dies, target opponent loses 1 Essence. God Code ‚Äì Sanctuary Eclipse (once per game): Destroy up to two non-Beast Avatars. For each Avatar destroyed this way, you may create a 3/3 Void Beast Avatar.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/41.png'
    },
    {
        id: 'EC-069',
        name: 'Demon Lord Kaixu, Crownshatter Sovereign',
        type: 'Deity',
        rarity: 'Arcane',
        aspects: ['Glow', 'Void', 'Gray'],
        essence: 22,
        startingKL: 3,
        domain: 'Shattered Sun / Crownline',
        effect: 'Passive ‚Äì Shard War Architect: Once per turn, when you play your second card that turn, choose two: ‚Ä¢ Each opponent loses 1 Essence. ‚Ä¢ You gain +1 KL this turn. ‚Ä¢ Draw a card. ‚Ä¢ Target Avatar you control gets +2 Power until end of turn. God Code ‚Äì Final Shardstorm (once per game): When your KL would go above 13, instead set it to 13 and activate this. Each opponent sacrifices two Avatars if able. Each opponent loses 4 Essence. Until end of turn, your Avatars get +2 Power and ‚ÄúWhen this Avatar deals Essence damage to a Deity, that Deity loses that much Essence again.‚Äù',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/69.png'
    },
    {
        id: 'EC-070',
        name: 'Estifar, Voidwing Regent',
        type: 'Deity',
        rarity: 'Arcane',
        aspects: ['Void', 'Beast', 'Gray'],
        essence: 23,
        startingKL: 3,
        domain: 'Sanctuary Void / Null Abyss',
        effect: 'Passive ‚Äì Familiar Swarm: The first time each turn that a Beast or a card with cost 2 or less enters New Earth under your control, you may have each opponent lose 1 Essence and you gain +1 KL this turn. God Code ‚Äì Pack of the Shattered Moon (once per game): When your KL would go above 13, instead set it to 13 and activate this effect. Create four 2/2 Void Beast Avatars with ‚ÄúWhen this Avatar dies, target opponent loses 1 Essence.‚Äù Your Beasts gain +1 Power and Guardian until end of turn. Restore 3 Essence to your Deity.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/70.png'
    },
    {
        id: 'EC-071',
        name: 'Lokaya, Crown of Stillness',
        type: 'Deity',
        rarity: 'Arcane',
        aspects: ['Gray', 'Glow'],
        essence: 25,
        startingKL: 3,
        domain: 'Gray Court / New Earth',
        effect: 'Passive ‚Äì Quiet Orbit: At the end of your turn, if no Avatar you control attacked this turn, you may restore 2 Essence to your Deity, then you may draw a card and discard a card. God Code ‚Äì Stillpoint Rewrite (once per game): When your KL would go above 13, instead set it to 13 and activate this effect. Tap all Avatars you don‚Äôt control. Those Avatars cannot attack during their controller‚Äôs next turn. You restore 5 Essence and draw 3 cards.',
        image: 'https://cdn1.sharemyimage.com/2025/12/02/71.png'
    },
];

// Create combined ALL_CARDS array with normalized properties
// Cards use power/toughness but game engine expects attack/health
const ALL_CARDS = [...CARD_DATABASE, ...DEITY_DATABASE].map(card => ({
    ...card,
    // Normalize Avatar stats: power -> attack, toughness -> health
    attack: card.attack ?? card.power ?? 0,
    health: card.health ?? card.toughness ?? card.essence ?? 0
}));

// === CARD DATA END ===

// Helper function to get all deities
function getDeities() {
    return DEITY_DATABASE;
}

// Helper function to get all non-deity cards
function getPlayableCards() {
    return CARD_DATABASE;
}

// Helper function to find a card by ID
function getCardById(id) {
    return ALL_CARDS.find(c => c.id === id);
}

// Export for use in game
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { CARD_DATABASE, DEITY_DATABASE, CARD_BACK_IMAGE, ALL_CARDS, getDeities, getPlayableCards, getCardById };
}

// === CARD DATA END ===


// Settings screen removal kept for IONOS build.
document.addEventListener('DOMContentLoaded', () => {
    const explicitSettingsContainer = document.getElementById('settings-screen');
    if (explicitSettingsContainer) {
        explicitSettingsContainer.remove();
        console.warn('Removed explicit settings screen container.');
        return;
    }

    const settingsHeading = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
        .find(el => (el.textContent || '').trim().toUpperCase() === 'SETTINGS');

    if (settingsHeading) {
        const settingsContainer = settingsHeading.closest('section, div, main, article');
        if (settingsContainer) {
            settingsContainer.remove();
            console.warn('Removed inferred settings screen container.');
        }
    }
});
    </script>
    <script>
/**
 * ============================================================
 * ESSENCE CROWN: SHARD WARS - DIGITAL TCG TABLETOP
 * ============================================================
 * 
 * ARCHITECTURE OVERVIEW:
 * 
 * 1. GAME STATE (Game.state object ~line 6300):
 *    - players[0] / players[1]: Player data (essence, kl, deck, hand, avatarRow, etc.)
 *    - currentPlayer: 0 = human player, 1 = AI/opponent
 *    - currentPhase: dawn, draw, main, clash, twilight
 *    - turnNumber: Current turn counter
 *    - combat: Combat state (declaredAttackers, declaredBlockers, tempDamage)
 *    - gameOver: Boolean flag for game end
 * 
 * 2. TURN/PHASE ENGINE:
 *    - Game.setPhase(phase): Sets current phase, triggers phase effects
 *    - Game.nextPhase(): Advances to next phase
 *    - Game.endTurn(): Ends turn, switches players
 *    - Phases: dawn -> draw -> main -> clash -> twilight -> (end turn)
 * 
 * 3. COMBAT ENGINE:
 *    - Game.declareAttacker(): Player selects attacking Avatar
 *    - Game.declareBlocker(): Opponent assigns blockers
 *    - Game.resolveCombat(): Power vs Guard damage resolution
 *    - tempDamage tracking for simultaneous damage
 * 
 * 4. WIN CONDITIONS (Game.triggerGameEnd):
 *    - essence: Player essence <= 0
 *    - deck_out: Cannot draw from empty deck (mandatory draw)
 *    - concede: Player surrenders
 *    - timeout: Turn timer expired
 * 
 * 5. SCREEN NAVIGATION:
 *    - MainMenu.selectMode(mode): Switch between menu overlays
 *    - MainMenu.back(): Return to main menu
 *    - Game.showDeitySelection(): Deity picker before match
 *    - Game.returnToMenu(): Exit match to menu
 *    - Game.showVictoryScreen(): Display win/loss results
 * 
 * 6. KEY MANAGERS:
 *    - AIManager: AI opponent logic
 *    - CampaignManager: Story mode progression
 *    - DeckBuilder: Deck construction interface
 *    - RewardsSystem: Shard currency and rank rewards
 *    - PlayerProfile: Player customization and stats
 * 
 * Last Updated: December 2025
 * ============================================================
 */

// ===== GAME SETTINGS CONFIG =====
const GAME_SETTINGS = {
    enableAnimations: true,
    autoPassReactions: false,
    showReactionBar: true,
    animationSpeed: 1.0,
    musicEnabled: true,
    sfxEnabled: true,
    musicVolume: 0.4,
    sfxVolume: 0.6
};

// ===== ESSENCE CROWN BATTLE ENGINE: HELPER FUNCTIONS =====
/**
 * Check if a card has the Guardian keyword (must be attacked first)
 * @param {Object} card - The card to check
 * @returns {boolean} True if card has Guardian ability
 */
function hasGuardian(card) {
    if (!card) return false;
    
    // Check for Guardian keyword in effect text
    if (card.effect) {
        const effect = card.effect.toLowerCase();
        if (effect.includes('guardian') || effect.includes('must be attacked first')) {
            return true;
        }
    }
    
    // Check for Guardian in keywords array
    if (card.keywords && Array.isArray(card.keywords)) {
        return card.keywords.some(k => k.toLowerCase() === 'guardian');
    }
    
    // Check for guard flag
    if (card.guard === true || card.isGuardian === true) {
        return true;
    }
    
    return false;
}

/**
 * Check if a card has the Haste/Swift keyword (can attack immediately)
 * @param {Object} card - The card to check
 * @returns {boolean} True if card has Haste ability
 */
function hasHaste(card) {
    if (!card) return false;
    
    if (card.effect) {
        const effect = card.effect.toLowerCase();
        if (effect.includes('haste') || effect.includes('swift') || effect.includes('rush')) {
            return true;
        }
    }
    
    if (card.keywords && Array.isArray(card.keywords)) {
        return card.keywords.some(k => 
            ['haste', 'swift', 'rush'].includes(k.toLowerCase())
        );
    }
    
    return card.haste === true;
}

function isBeastCard(card) {
    if (!card) return false;

    const aspects = card.aspects || card.template?.aspects || [];
    let isFromAspects = false;

    if (Array.isArray(aspects)) {
        isFromAspects = aspects.some(a => typeof a === 'string' && a.toLowerCase() === 'beast');
    }

    const typeField = (card.type || card.cardType || '').toLowerCase();
    const isFromType = typeField === 'beast';

    return isFromAspects || isFromType;
}

// ===== SUN ALTAR VISUAL HELPERS =====
const SunAltarUI = {
    domainMap: {
        'Second Sun': 'second-sun',
        'Nullgrid': 'nullgrid',
        'New Earth': 'new-earth',
        'Crownline': 'crownline',
        'Gray Court': 'gray-court',
        'Shattered Sun': 'shattered-sun',
        'Sanctuary Void': 'sanctuary-void',
        'Solara': 'solara'
    },
    
    setActiveDomain(domainName) {
        const arena = document.getElementById('ec-arena-frame');
        if (!arena) return;
        const domainKey = this.domainMap[domainName] || 'new-earth';
        arena.setAttribute('data-domain', domainKey);
        const nameEl = document.getElementById('active-domain-name');
        if (nameEl) nameEl.textContent = domainName || 'New Earth';
    },
    
    updateKLPips(playerIndex, current, max) {
        const pipsContainer = document.getElementById(`p${playerIndex + 1}-kl-pips`);
        if (!pipsContainer) return;
        
        let html = '';
        for (let i = 0; i < max; i++) {
            const state = i < current ? 'active' : 'spent';
            html += `<div class="kl-pip ${state}"></div>`;
        }
        pipsContainer.innerHTML = html;
    },
    
    triggerDeityAbility(playerIndex) {
        const ring = document.querySelector(`#p${playerIndex + 1}-deity-zone`);
        if (ring) {
            ring.classList.add('ability-active');
            setTimeout(() => ring.classList.remove('ability-active'), 800);
        }
    },
    
    playDamageBurst(element, damage) {
        if (!element || !GAME_SETTINGS.enableAnimations) return;
        const burst = document.createElement('div');
        burst.className = 'damage-burst';
        burst.innerHTML = `<span style="color:#ef4444;font-weight:bold;font-size:24px;">-${damage}</span>`;
        const rect = element.getBoundingClientRect();
        burst.style.left = `${rect.left + rect.width / 2 - 30}px`;
        burst.style.top = `${rect.top + rect.height / 2 - 30}px`;
        burst.style.position = 'fixed';
        burst.style.zIndex = '9999';
        document.body.appendChild(burst);
        setTimeout(() => burst.remove(), 600);
    },
    
    playEssenceFlare(element) {
        if (!element || !GAME_SETTINGS.enableAnimations) return;
        const flare = document.createElement('div');
        flare.className = 'essence-flare';
        const rect = element.getBoundingClientRect();
        flare.style.left = `${rect.left + rect.width / 2 - 40}px`;
        flare.style.top = `${rect.top + rect.height / 2 - 40}px`;
        flare.style.position = 'fixed';
        flare.style.zIndex = '9998';
        document.body.appendChild(flare);
        setTimeout(() => flare.remove(), 700);
    },
    
    showSigil(element, sigil) {
        if (!element || !GAME_SETTINGS.enableAnimations) return;
        const sigilEl = document.createElement('div');
        sigilEl.className = 'sigil-overlay';
        sigilEl.textContent = sigil;
        const rect = element.getBoundingClientRect();
        sigilEl.style.left = `${rect.left + rect.width / 2 - 20}px`;
        sigilEl.style.top = `${rect.top + rect.height / 2 - 20}px`;
        sigilEl.style.position = 'fixed';
        sigilEl.style.zIndex = '9999';
        document.body.appendChild(sigilEl);
        setTimeout(() => sigilEl.remove(), 700);
    }
};

// ===== SHATTERED SUN CHRONICLE PANEL =====
const ChroniclePanel = {
    isVisible: false,
    currentChapter: null,
    
    show(chapterData) {
        const panel = document.getElementById('chronicle-panel');
        if (!panel) return;
        
        panel.classList.remove('hidden');
        this.isVisible = true;
        this.currentChapter = chapterData;
        
        if (chapterData) {
            this.update(chapterData);
        }
    },
    
    hide() {
        const panel = document.getElementById('chronicle-panel');
        if (panel) {
            panel.classList.add('hidden');
        }
        this.isVisible = false;
    },
    
    toggle() {
        const content = document.getElementById('chronicle-content');
        const btn = document.querySelector('.chronicle-toggle');
        if (content && btn) {
            content.classList.toggle('collapsed');
            btn.textContent = content.classList.contains('collapsed') ? '+' : '‚àí';
        }
    },
    
    update(chapterData) {
        const actEl = document.getElementById('chronicle-act');
        const chapterEl = document.getElementById('chronicle-chapter');
        const storyEl = document.getElementById('chronicle-story');
        const progressEl = document.getElementById('chronicle-progress');
        
        if (actEl && chapterData.act) {
            actEl.textContent = `Act ${chapterData.act}`;
        }
        if (chapterEl && chapterData.title) {
            chapterEl.textContent = chapterData.title;
        }
        if (storyEl && chapterData.story) {
            storyEl.textContent = chapterData.story;
        }
        if (progressEl && chapterData.chapterId) {
            this.updateProgress(chapterData.chapterId);
        }
    },
    
    updateProgress(currentChapterId) {
        const progressEl = document.getElementById('chronicle-progress');
        if (!progressEl) return;
        
        let html = '';
        for (let i = 1; i <= 10; i++) {
            let state = '';
            if (i < currentChapterId) state = 'complete';
            else if (i === currentChapterId) state = 'current';
            html += `<div class="progress-node ${state}">${i}</div>`;
        }
        progressEl.innerHTML = html;
    }
};

// ===== AUDIO MANAGER =====
const AudioManager = {
    currentTrack: null,
    audioElement: null,
    sfxPool: {},
    fadeInterval: null,
    
    tracks: {
        menu: 'https://cdn.pixabay.com/audio/2024/02/14/audio_72a5c37df7.mp3',
        battle: 'https://cdn.pixabay.com/audio/2024/11/13/audio_28e22e43c8.mp3',
        battle_intense: 'https://cdn.pixabay.com/audio/2024/03/25/audio_4c0b0f6f8c.mp3',
        victory: 'https://cdn.pixabay.com/audio/2022/03/15/audio_942e22b3fa.mp3',
        defeat: 'https://cdn.pixabay.com/audio/2024/04/04/audio_ea55c73e79.mp3',
        campaign: 'https://cdn.pixabay.com/audio/2024/09/10/audio_6e5d7d1912.mp3',
        boss: 'https://cdn.pixabay.com/audio/2023/10/17/audio_c8e4dd4a32.mp3'
    },
    
    init() {
        this.audioElement = document.createElement('audio');
        this.audioElement.id = 'ec-background-music';
        this.audioElement.loop = true;
        this.audioElement.volume = GAME_SETTINGS.musicVolume;
        document.body.appendChild(this.audioElement);
        
        const savedVolume = localStorage.getItem('ec-music-volume');
        const savedEnabled = localStorage.getItem('ec-music-enabled');
        if (savedVolume !== null) GAME_SETTINGS.musicVolume = parseFloat(savedVolume);
        if (savedEnabled !== null) GAME_SETTINGS.musicEnabled = savedEnabled === 'true';
        
        this.audioElement.volume = GAME_SETTINGS.musicVolume;
        
        document.addEventListener('click', () => {
            if (GAME_SETTINGS.musicEnabled && !this.currentTrack) {
                this.play('menu');
            }
        }, { once: true });
    },
    
    play(trackName, fadeIn = true) {
        if (!GAME_SETTINGS.musicEnabled) return;
        if (this.currentTrack === trackName) return;
        
        const track = this.tracks[trackName];
        if (!track) return;
        
        if (fadeIn && this.audioElement.src) {
            this.fadeOut(() => {
                this.loadAndPlay(track, trackName);
            });
        } else {
            this.loadAndPlay(track, trackName);
        }
    },
    
    loadAndPlay(src, trackName) {
        this.audioElement.src = src;
        this.audioElement.volume = 0;
        this.currentTrack = trackName;
        
        const playPromise = this.audioElement.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                this.fadeIn();
            }).catch(e => {
                console.log('Audio autoplay blocked, waiting for user interaction');
            });
        }
    },
    
    fadeIn(duration = 1000) {
        const targetVolume = GAME_SETTINGS.musicVolume;
        const steps = 20;
        const stepTime = duration / steps;
        const volumeStep = targetVolume / steps;
        let currentStep = 0;
        
        if (this.fadeInterval) clearInterval(this.fadeInterval);
        
        this.fadeInterval = setInterval(() => {
            currentStep++;
            this.audioElement.volume = Math.min(volumeStep * currentStep, targetVolume);
            if (currentStep >= steps) {
                clearInterval(this.fadeInterval);
                this.fadeInterval = null;
            }
        }, stepTime);
    },
    
    fadeOut(callback, duration = 500) {
        const startVolume = this.audioElement.volume;
        const steps = 10;
        const stepTime = duration / steps;
        const volumeStep = startVolume / steps;
        let currentStep = 0;
        
        if (this.fadeInterval) clearInterval(this.fadeInterval);
        
        this.fadeInterval = setInterval(() => {
            currentStep++;
            this.audioElement.volume = Math.max(startVolume - (volumeStep * currentStep), 0);
            if (currentStep >= steps) {
                clearInterval(this.fadeInterval);
                this.fadeInterval = null;
                this.audioElement.pause();
                if (callback) callback();
            }
        }, stepTime);
    },
    
    stop() {
        this.fadeOut(() => {
            this.currentTrack = null;
        });
    },
    
    pause() {
        if (this.audioElement) {
            this.audioElement.pause();
        }
    },
    
    resume() {
        if (this.audioElement && GAME_SETTINGS.musicEnabled) {
            this.audioElement.play().catch(() => {});
        }
    },
    
    setVolume(volume) {
        GAME_SETTINGS.musicVolume = volume;
        if (this.audioElement) {
            this.audioElement.volume = volume;
        }
        localStorage.setItem('ec-music-volume', volume);
    },
    
    toggleMusic() {
        GAME_SETTINGS.musicEnabled = !GAME_SETTINGS.musicEnabled;
        localStorage.setItem('ec-music-enabled', GAME_SETTINGS.musicEnabled);
        
        if (GAME_SETTINGS.musicEnabled) {
            this.play('menu');
        } else {
            this.stop();
        }
        return GAME_SETTINGS.musicEnabled;
    },
    
    playSFX(name) {
        if (!GAME_SETTINGS.sfxEnabled) return;
        
        const sfxUrls = {
            card_play: 'https://cdn.pixabay.com/audio/2022/03/10/audio_c8b8abb5b4.mp3',
            attack: 'https://cdn.pixabay.com/audio/2022/03/15/audio_8c90e8fb6e.mp3',
            damage: 'https://cdn.pixabay.com/audio/2021/08/04/audio_c507296979.mp3',
            draw: 'https://cdn.pixabay.com/audio/2022/10/30/audio_f96fc71f30.mp3',
            click: 'https://cdn.pixabay.com/audio/2022/03/10/audio_6c483c1c0a.mp3'
        };
        
        const url = sfxUrls[name];
        if (!url) return;
        
        const sfx = new Audio(url);
        sfx.volume = GAME_SETTINGS.sfxVolume;
        sfx.play().catch(() => {});
    }
};

// ===== ANIMATION HELPERS =====
const AnimationHelper = {
    play(type, element, options = {}) {
        if (!GAME_SETTINGS.enableAnimations) return Promise.resolve();
        
        return new Promise(resolve => {
            const duration = (options.duration || 400) / GAME_SETTINGS.animationSpeed;
            
            switch(type) {
                case 'manifest':
                    this.manifestAnimation(element, duration, resolve);
                    break;
                case 'aspect-impact':
                    this.aspectImpact(element, duration, resolve);
                    break;
                case 'essence-damage':
                    this.essenceDamage(element, options.amount, options.isHeal, resolve);
                    break;
                case 'shard-claim':
                    this.shardClaim(element, resolve);
                    break;
                case 'stat-pulse':
                    this.statPulse(element, options.color, resolve);
                    break;
                case 'crown':
                    this.crownOverlay(options.isVictory, resolve);
                    break;
                default:
                    resolve();
            }
        });
    },
    
    manifestAnimation(slot, duration, callback) {
        if (!slot) return callback?.();
        slot.classList.add('ec-anim-manifest');
        const card = slot.querySelector('.game-card');
        if (card) {
            card.classList.add('ec-anim-manifest-card');
        }
        setTimeout(() => {
            slot.classList.remove('ec-anim-manifest');
            slot.classList.add('ec-anim-manifest-complete');
            if (card) card.classList.remove('ec-anim-manifest-card');
            setTimeout(() => slot.classList.remove('ec-anim-manifest-complete'), 300);
            callback?.();
        }, duration);
    },
    
    aspectImpact(element, duration, callback) {
        if (!element) return callback?.();
        element.classList.add('ec-anim-aspect-impact');
        setTimeout(() => {
            element.classList.remove('ec-anim-aspect-impact');
            callback?.();
        }, duration);
    },
    
    essenceDamage(targetElement, amount, isHeal = false, callback) {
        if (!targetElement) return callback?.();
        const rect = targetElement.getBoundingClientRect();
        const floater = document.createElement('div');
        floater.className = `ec-damage-floater ${isHeal ? 'heal' : 'damage'}`;
        floater.textContent = `${isHeal ? '+' : '-'}${Math.abs(amount)} Essence`;
        floater.style.left = `${rect.left + rect.width / 2}px`;
        floater.style.top = `${rect.top}px`;
        document.body.appendChild(floater);
        
        requestAnimationFrame(() => floater.classList.add('animate'));
        setTimeout(() => {
            floater.remove();
            callback?.();
        }, 1200);
    },
    
    shardClaim(shardElement, callback) {
        if (!shardElement) return callback?.();
        shardElement.classList.add('ec-anim-shard-claim');
        setTimeout(() => {
            shardElement.classList.remove('ec-anim-shard-claim');
            shardElement.classList.add('ec-shard--claimed');
            callback?.();
        }, 600);
    },
    
    statPulse(element, color = 'gold', callback) {
        if (!element) return callback?.();
        element.classList.add(`ec-pulse-${color}`);
        setTimeout(() => {
            element.classList.remove(`ec-pulse-${color}`);
            callback?.();
        }, 400);
    },
    
    crownOverlay(isVictory, callback) {
        const overlay = document.getElementById('ec-crown-overlay');
        const title = document.getElementById('ec-crown-title');
        if (!overlay || !title) return callback?.();
        
        overlay.classList.remove('victory', 'defeat');
        overlay.classList.add(isVictory ? 'victory' : 'defeat');
        title.textContent = isVictory ? 'CROWN CLAIMED' : 'ESSENCE SHATTERED';
        overlay.classList.add('visible');
        
        setTimeout(() => {
            overlay.classList.remove('visible');
            callback?.();
        }, 3000);
    }
};

// ===== REACTION BAR SYSTEM =====
const ReactionBar = {
    visible: false,
    currentOptions: [],
    onRespond: null,
    onPass: null,
    
    show(options = {}) {
        if (!GAME_SETTINGS.showReactionBar) return;
        if (GAME_SETTINGS.autoPassReactions && (!options.cards || options.cards.length === 0)) {
            options.onPass?.();
            return;
        }
        
        this.visible = true;
        this.currentOptions = options.cards || [];
        this.onRespond = options.onRespond;
        this.onPass = options.onPass;
        
        const bar = document.getElementById('ec-reaction-bar');
        if (!bar) return;
        
        const prompt = bar.querySelector('.ec-reaction-prompt');
        const cardsContainer = bar.querySelector('.ec-reaction-cards');
        
        if (prompt) prompt.textContent = options.prompt || 'You may respond';
        
        if (cardsContainer) {
            cardsContainer.innerHTML = '';
            this.currentOptions.slice(0, 3).forEach(card => {
                const btn = document.createElement('button');
                btn.className = 'ec-reaction-card-btn';
                btn.textContent = card.name;
                btn.onclick = () => this.selectCard(card);
                cardsContainer.appendChild(btn);
            });
        }
        
        bar.classList.add('visible');
    },
    
    hide() {
        this.visible = false;
        const bar = document.getElementById('ec-reaction-bar');
        if (bar) bar.classList.remove('visible');
    },
    
    selectCard(card) {
        this.hide();
        this.onRespond?.(card);
    },
    
    pass() {
        this.hide();
        this.onPass?.();
    },
    
    respond() {
        if (this.currentOptions.length === 1) {
            this.selectCard(this.currentOptions[0]);
        } else if (this.currentOptions.length > 1) {
            this.currentOptions.forEach(c => {
                const cardEl = document.querySelector(`[data-card-id="${c.instanceId}"]`);
                if (cardEl) cardEl.classList.add('ec-reaction-candidate');
            });
        }
    },
    
    toggleAutoPass() {
        GAME_SETTINGS.autoPassReactions = !GAME_SETTINGS.autoPassReactions;
        const toggle = document.getElementById('ec-autopass-toggle');
        if (toggle) toggle.checked = GAME_SETTINGS.autoPassReactions;
        localStorage.setItem('ec_autopass', GAME_SETTINGS.autoPassReactions);
    },
    
    init() {
        GAME_SETTINGS.autoPassReactions = localStorage.getItem('ec_autopass') === 'true';
        const toggle = document.getElementById('ec-autopass-toggle');
        if (toggle) toggle.checked = GAME_SETTINGS.autoPassReactions;
    }
};

// ===== TARGETING VISUAL SYSTEM =====
const TargetingVisuals = {
    activeLine: null,
    
    showTargetable(elements) {
        elements.forEach(el => el.classList.add('ec-targetable'));
    },
    
    clearTargetable() {
        document.querySelectorAll('.ec-targetable').forEach(el => el.classList.remove('ec-targetable'));
        document.querySelectorAll('.ec-targeted').forEach(el => el.classList.remove('ec-targeted'));
        this.clearLine();
    },
    
    setTargeted(element) {
        document.querySelectorAll('.ec-targeted').forEach(el => el.classList.remove('ec-targeted'));
        if (element) element.classList.add('ec-targeted');
    },
    
    drawLine(sourceElement, targetElement) {
        if (!sourceElement || !targetElement) return;
        this.clearLine();
        
        const sourceRect = sourceElement.getBoundingClientRect();
        const targetRect = targetElement.getBoundingClientRect();
        
        const sx = sourceRect.left + sourceRect.width / 2;
        const sy = sourceRect.top + sourceRect.height / 2;
        const tx = targetRect.left + targetRect.width / 2;
        const ty = targetRect.top + targetRect.height / 2;
        
        const angle = Math.atan2(ty - sy, tx - sx) * 180 / Math.PI;
        const distance = Math.sqrt((tx - sx) ** 2 + (ty - sy) ** 2);
        
        const line = document.createElement('div');
        line.className = 'ec-target-line';
        line.style.left = `${sx}px`;
        line.style.top = `${sy}px`;
        line.style.width = `${distance}px`;
        line.style.transform = `rotate(${angle}deg)`;
        
        document.body.appendChild(line);
        this.activeLine = line;
        
        requestAnimationFrame(() => line.classList.add('visible'));
    },
    
    clearLine() {
        if (this.activeLine) {
            this.activeLine.remove();
            this.activeLine = null;
        }
    }
};

// ===== ENHANCED PLAYER PROFILE SYSTEM =====
const FullscreenToggle = {
    toggle() {
        const elem = document.documentElement;
        const btn = document.getElementById('btn-fullscreen');
        
        if (!document.fullscreenElement) {
            elem.requestFullscreen?.() || 
            elem.webkitRequestFullscreen?.() || 
            elem.mozRequestFullScreen?.() || 
            elem.msRequestFullscreen?.();
            
            btn?.classList.add('active');
        } else {
            document.exitFullscreen?.() || 
            document.webkitExitFullscreen?.() || 
            document.mozCancelFullScreen?.() || 
            document.msExitFullscreen?.();
            
            btn?.classList.remove('active');
        }
    }
};

document.addEventListener('fullscreenchange', () => {
    const btn = document.getElementById('btn-fullscreen');
    if (document.fullscreenElement) {
        btn?.classList.add('active');
    } else {
        btn?.classList.remove('active');
    }
});

const GameControls = {
    toggleFullscreen() {
        FullscreenToggle.toggle();
    },
    
    showPause() {
        document.getElementById('pause-overlay').classList.remove('hidden');
    },
    
    resume() {
        document.getElementById('pause-overlay').classList.add('hidden');
    },
    
    goHome() {
        this.resume();
        if (typeof Game !== 'undefined' && Game.state && !Game.state.gameOver) {
            if (confirm('Are you sure you want to quit? Your match progress will be lost.')) {
                Game.returnToMenu();
            }
        } else {
            Game.returnToMenu();
        }
    },
    
    surrender() {
        this.resume();
        if (typeof Game !== 'undefined' && Game.state && !Game.state.gameOver) {
            if (confirm('Are you sure you want to surrender?')) {
                Game.state.gameOver = true;
                Game.endGame(false);
            }
        }
    }
};

const PlayerProfile = {
    data: {
        name: 'Sovereign',
        avatar: 'üëë',
        title: 'Initiate',
        motto: '',
        cardBack: 'default',
        border: 'bronze',
        favoriteDeity: '',
        matches: 0,
        wins: 0,
        losses: 0,
        shards: 0,
        bestStreak: 0,
        currentStreak: 0,
        matchHistory: []
    },
    
    avatarMap: {
        cosmic: 'üåå', void: 'üåë', essence: '‚ú®', divine: 'üëë', inferno: 'üî•', storm: '‚ö°'
    },
    
    init() {
        this.loadProfile();
        this.updateDisplay();
        this.populateDeitySelect();
    },
    
    loadProfile() {
        const saved = localStorage.getItem('ec-player-profile');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data = { ...this.data, ...parsed };
        }
    },
    
    saveProfile() {
        const nameInput = document.getElementById('profile-name-input');
        const mottoInput = document.getElementById('profile-motto-input');
        
        if (nameInput && nameInput.value.trim()) {
            this.data.name = nameInput.value.trim();
        }
        if (mottoInput) {
            this.data.motto = mottoInput.value.trim();
        }
        
        localStorage.setItem('ec-player-profile', JSON.stringify(this.data));
        this.updateDisplay();
        this.closeModal();
        
        BattleEffects.screenFlash('#d4af3744', 300);
    },
    
    selectAvatar(avatar) {
        this.data.avatar = this.avatarMap[avatar] || 'üëë';
        document.querySelectorAll('.avatar-option').forEach(el => el.classList.remove('selected'));
        document.querySelector(`[data-avatar="${avatar}"]`)?.classList.add('selected');
    },
    
    selectTitle(title) {
        const el = document.querySelector(`[data-title="${title}"]`);
        if (el && el.classList.contains('locked')) return;
        
        this.data.title = title;
        document.querySelectorAll('.title-option').forEach(el => el.classList.remove('selected'));
        document.querySelector(`[data-title="${title}"]`)?.classList.add('selected');
    },
    
    selectCardBack(cardBack) {
        this.data.cardBack = cardBack;
        document.querySelectorAll('.cardback-option').forEach(el => el.classList.remove('selected'));
        document.querySelector(`[data-cardback="${cardBack}"]`)?.classList.add('selected');
    },
    
    selectBorder(border) {
        const el = document.querySelector(`[data-border="${border}"]`);
        if (el && el.classList.contains('locked')) return;
        
        this.data.border = border;
        document.querySelectorAll('.border-option').forEach(el => el.classList.remove('selected'));
        document.querySelector(`[data-border="${border}"]`)?.classList.add('selected');
    },
    
    selectFavoriteDeity(deityName) {
        this.data.favoriteDeity = deityName;
    },
    
    populateDeitySelect() {
        const select = document.getElementById('profile-deity-select');
        if (!select || typeof getDeities !== 'function') return;
        
        const deities = getDeities();
        deities.forEach(deity => {
            const option = document.createElement('option');
            option.value = deity.name;
            option.textContent = deity.name;
            select.appendChild(option);
        });
    },
    
    switchTab(tabName) {
        document.querySelectorAll('.profile-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.tab === tabName);
        });
        document.querySelectorAll('.profile-tab-content').forEach(content => {
            content.classList.toggle('active', content.id === `tab-${tabName}`);
        });
        
        if (tabName === 'stats') {
            this.updateStatsDisplay();
        }
    },
    
    updateStatsDisplay() {
        const winRate = this.data.matches > 0 ? Math.round((this.data.wins / this.data.matches) * 100) : 0;
        
        document.getElementById('stat-matches').textContent = this.data.matches;
        document.getElementById('stat-wins').textContent = this.data.wins;
        document.getElementById('stat-losses').textContent = this.data.losses;
        document.getElementById('stat-winrate').textContent = `${winRate}%`;
        document.getElementById('stat-streak').textContent = this.data.bestStreak;
        
        const campaign = JSON.parse(localStorage.getItem('ec-campaign-progress') || '{}');
        const completed = Object.values(campaign).filter(v => v === true).length;
        document.getElementById('stat-campaign').textContent = `${completed}/10`;
        
        this.renderMatchHistory();
    },
    
    renderMatchHistory() {
        const container = document.getElementById('match-history-list');
        if (!container) return;
        
        if (this.data.matchHistory.length === 0) {
            container.innerHTML = '<div class="no-matches">No battles yet. Begin your legend!</div>';
            return;
        }
        
        container.innerHTML = this.data.matchHistory.slice(-10).reverse().map(match => `
            <div class="match-entry ${match.won ? 'win' : 'loss'}">
                <span class="match-result">${match.won ? '‚úì' : '‚úó'}</span>
                <span class="match-opponent">${match.opponent || 'Unknown'}</span>
                <span class="match-mode">${match.mode || 'Battle'}</span>
            </div>
        `).join('');
    },
    
    showModal() {
        const modal = document.getElementById('profile-modal');
        modal.classList.remove('hidden');
        
        document.getElementById('profile-name-input').value = this.data.name;
        document.getElementById('profile-motto-input').value = this.data.motto || '';
        
        const reverseAvatarMap = Object.fromEntries(
            Object.entries(this.avatarMap).map(([k, v]) => [v, k])
        );
        const currentAvatar = reverseAvatarMap[this.data.avatar];
        document.querySelectorAll('.avatar-option').forEach(el => {
            el.classList.toggle('selected', el.dataset.avatar === currentAvatar);
        });
        
        document.querySelectorAll('.title-option').forEach(el => {
            el.classList.toggle('selected', el.dataset.title === this.data.title);
        });
        
        document.querySelectorAll('.cardback-option').forEach(el => {
            el.classList.toggle('selected', el.dataset.cardback === this.data.cardBack);
        });
        
        document.querySelectorAll('.border-option').forEach(el => {
            el.classList.toggle('selected', el.dataset.border === this.data.border);
        });
        
        const deitySelect = document.getElementById('profile-deity-select');
        if (deitySelect) deitySelect.value = this.data.favoriteDeity;
        
        this.switchTab('identity');
    },
    
    closeModal() {
        document.getElementById('profile-modal').classList.add('hidden');
    },
    
    updateDisplay() {
        const menuName = document.getElementById('menu-player-name');
        const menuAvatar = document.getElementById('menu-avatar');
        const menuRank = document.getElementById('menu-player-rank');
        const menuShards = document.getElementById('menu-shards');
        
        if (menuName) menuName.textContent = this.data.name;
        if (menuAvatar) menuAvatar.textContent = this.data.avatar;
        if (menuRank) {
            const winRate = this.data.matches > 0 ? Math.round((this.data.wins / this.data.matches) * 100) : 0;
            menuRank.textContent = `${this.data.title} ‚Ä¢ ${winRate}% WR`;
        }
        if (menuShards) menuShards.textContent = this.data.shards;
    },
    
    recordMatch(won, opponentName = 'AI', mode = 'Battle') {
        this.data.matches++;
        if (won) {
            this.data.wins++;
            this.data.currentStreak++;
            if (this.data.currentStreak > this.data.bestStreak) {
                this.data.bestStreak = this.data.currentStreak;
            }
        } else {
            this.data.losses++;
            this.data.currentStreak = 0;
        }
        
        this.data.matchHistory.push({
            won,
            opponent: opponentName,
            mode,
            timestamp: Date.now()
        });
        
        if (this.data.matchHistory.length > 50) {
            this.data.matchHistory = this.data.matchHistory.slice(-50);
        }
        
        this.unlockTitles();
        
        localStorage.setItem('ec-player-profile', JSON.stringify(this.data));
        this.updateDisplay();
    },
    
    unlockTitles() {
        if (this.data.wins >= 10) {
            document.querySelector('[data-title="Champion"]')?.classList.remove('locked');
        }
        if (this.data.wins >= 25) {
            document.querySelector('[data-title="Deity Slayer"]')?.classList.remove('locked');
        }
    },
    
    addShards(amount) {
        this.data.shards += amount;
        localStorage.setItem('ec-player-profile', JSON.stringify(this.data));
        this.updateDisplay();
    },
    
    unlockedTitles: JSON.parse(localStorage.getItem('ec-unlocked-titles') || '["Initiate"]'),
    
    unlockTitle(title) {
        if (!this.unlockedTitles.includes(title)) {
            this.unlockedTitles.push(title);
            localStorage.setItem('ec-unlocked-titles', JSON.stringify(this.unlockedTitles));
        }
    },
    
    isTitleUnlocked(title) {
        return this.unlockedTitles.includes(title);
    }
};

// ===== MATCH INTRO CINEMATIC =====
const MatchIntro = {
    battleQuotes: [
        "The Essence flows... destiny awaits!",
        "Only one shall claim the Crown!",
        "Let the Shards decide your fate!",
        "The void hungers for essence!",
        "Ancient powers awaken!",
        "Steel your soul, Shardkeeper!",
        "The deities watch with interest...",
        "May your essence burn eternal!"
    ],
    
    show(player1, player2, p1Deity, p2Deity) {
        return new Promise((resolve) => {
            const intro = document.getElementById('match-intro');
            if (!intro) { resolve(); return; }
            
            document.getElementById('intro-p1-avatar').textContent = PlayerProfile.data.avatar;
            document.getElementById('intro-p1-name').textContent = PlayerProfile.data.name;
            document.getElementById('intro-p1-title').textContent = PlayerProfile.data.title;
            document.getElementById('intro-p1-deity').textContent = `‚öî ${p1Deity?.name || 'Unknown Deity'}`;
            
            document.getElementById('intro-p2-avatar').textContent = 'ü§ñ';
            document.getElementById('intro-p2-name').textContent = player2 || 'Opponent';
            document.getElementById('intro-p2-title').textContent = 'Challenger';
            document.getElementById('intro-p2-deity').textContent = `‚öî ${p2Deity?.name || 'Unknown Deity'}`;
            
            const quote = this.battleQuotes[Math.floor(Math.random() * this.battleQuotes.length)];
            document.getElementById('intro-quote').textContent = `"${quote}"`;
            
            intro.classList.remove('hidden');
            intro.classList.add('animating');
            
            BattleEffects.screenFlash('#ffffff', 200);
            
            setTimeout(() => {
                intro.classList.add('vs-slam');
                BattleEffects.screenShake(20, 300);
            }, 800);
            
            setTimeout(() => {
                intro.classList.add('fade-out');
                setTimeout(() => {
                    intro.classList.remove('animating', 'vs-slam', 'fade-out');
                    intro.classList.add('hidden');
                    resolve();
                }, 500);
            }, 3500);
        });
    }
};

// ===== BATTLE EFFECTS ENGINE =====
// Premium immersive battle system rivaling Pokemon/Yu-Gi-Oh with MTG depth

const BattleEffects = {
    particles: [],
    activeEffects: [],
    canvas: null,
    ctx: null,
    animationFrame: null,
    
    init() {
        this.createCanvas();
        this.startLoop();
    },
    
    createCanvas() {
        if (this.canvas) return;
        this.canvas = document.createElement('canvas');
        this.canvas.id = 'effects-canvas';
        this.canvas.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;';
        document.body.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
    },
    
    resize() {
        if (!this.canvas) return;
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    },
    
    startLoop() {
        const loop = () => {
            this.update();
            this.draw();
            this.animationFrame = requestAnimationFrame(loop);
        };
        loop();
    },
    
    update() {
        this.particles = this.particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= p.decay;
            p.vy += p.gravity || 0;
            return p.life > 0;
        });
    },
    
    draw() {
        if (!this.ctx) return;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.particles.forEach(p => {
            this.ctx.save();
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.shadowColor = p.color;
            this.ctx.shadowBlur = p.glow || 10;
            
            if (p.type === 'circle') {
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                this.ctx.fill();
            } else if (p.type === 'star') {
                this.drawStar(p.x, p.y, p.size * p.life, p.rotation || 0);
            } else if (p.type === 'spark') {
                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = p.color;
                this.ctx.beginPath();
                this.ctx.moveTo(p.x, p.y);
                this.ctx.lineTo(p.x - p.vx * 5, p.y - p.vy * 5);
                this.ctx.stroke();
            } else if (p.type === 'energy') {
                const gradient = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                gradient.addColorStop(0, p.color);
                gradient.addColorStop(1, 'transparent');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(p.x - p.size, p.y - p.size, p.size * 2, p.size * 2);
            }
            
            this.ctx.restore();
            if (p.rotation !== undefined) p.rotation += 0.1;
        });
    },
    
    drawStar(cx, cy, size, rotation) {
        const spikes = 5;
        const outerRadius = size;
        const innerRadius = size / 2;
        
        this.ctx.save();
        this.ctx.translate(cx, cy);
        this.ctx.rotate(rotation);
        this.ctx.beginPath();
        
        for (let i = 0; i < spikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i * Math.PI) / spikes - Math.PI / 2;
            if (i === 0) this.ctx.moveTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            else this.ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.restore();
    },
    
    // ===== SCREEN EFFECTS =====
    
    screenShake(intensity = 10, duration = 300) {
        const board = document.getElementById('game-board') || document.body;
        const startTime = Date.now();
        
        const shake = () => {
            const elapsed = Date.now() - startTime;
            if (elapsed < duration) {
                const decay = 1 - (elapsed / duration);
                const x = (Math.random() - 0.5) * intensity * decay;
                const y = (Math.random() - 0.5) * intensity * decay;
                board.style.transform = `translate(${x}px, ${y}px)`;
                requestAnimationFrame(shake);
            } else {
                board.style.transform = '';
            }
        };
        shake();
    },
    
    screenFlash(color = '#ffffff', duration = 200) {
        const flash = document.createElement('div');
        flash.className = 'screen-flash';
        flash.style.backgroundColor = color;
        document.body.appendChild(flash);
        
        requestAnimationFrame(() => flash.style.opacity = '0.8');
        setTimeout(() => {
            flash.style.opacity = '0';
            setTimeout(() => flash.remove(), 300);
        }, duration);
    },
    
    chromaticAberration(duration = 500) {
        const board = document.getElementById('game-board');
        if (board) {
            board.classList.add('chromatic-aberration');
            setTimeout(() => board.classList.remove('chromatic-aberration'), duration);
        }
    },
    
    slowMotion(duration = 1000) {
        document.body.classList.add('slow-motion');
        setTimeout(() => document.body.classList.remove('slow-motion'), duration);
    },
    
    // ===== PARTICLE BURSTS =====
    
    burstAt(x, y, count = 30, options = {}) {
        const colors = options.colors || ['#d4af37', '#00ffcc', '#9333ea', '#ffffff'];
        
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
            const speed = (options.speed || 5) + Math.random() * 3;
            
            this.particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: (options.size || 8) + Math.random() * 4,
                color: colors[Math.floor(Math.random() * colors.length)],
                life: 1,
                decay: 0.02 + Math.random() * 0.02,
                type: options.type || 'circle',
                gravity: options.gravity || 0,
                glow: options.glow || 15,
                rotation: Math.random() * Math.PI * 2
            });
        }
    },
    
    energyBeam(fromX, fromY, toX, toY, color = '#00ffcc', callback) {
        const duration = 400;
        const startTime = Date.now();
        
        const beam = document.createElement('div');
        beam.className = 'energy-beam';
        beam.style.cssText = `
            left: ${fromX}px;
            top: ${fromY}px;
            background: linear-gradient(90deg, transparent, ${color}, ${color}, transparent);
            box-shadow: 0 0 30px ${color}, 0 0 60px ${color};
        `;
        
        const angle = Math.atan2(toY - fromY, toX - fromX);
        const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
        beam.style.width = '0px';
        beam.style.transform = `rotate(${angle}rad)`;
        
        document.body.appendChild(beam);
        
        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            beam.style.width = `${distance * progress}px`;
            
            // Spawn trail particles
            if (progress < 1 && Math.random() > 0.5) {
                const px = fromX + (toX - fromX) * progress;
                const py = fromY + (toY - fromY) * progress;
                this.particles.push({
                    x: px + (Math.random() - 0.5) * 10,
                    y: py + (Math.random() - 0.5) * 10,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: 4 + Math.random() * 3,
                    color: color,
                    life: 1,
                    decay: 0.05,
                    type: 'energy',
                    glow: 20
                });
            }
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                setTimeout(() => {
                    beam.style.opacity = '0';
                    setTimeout(() => beam.remove(), 200);
                    if (callback) callback();
                }, 100);
            }
        };
        animate();
    },
    
    // ===== CARD EFFECTS =====
    
    cardSummon(cardElement, cardType = 'Avatar') {
        const rect = cardElement.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        
        // Add summon class
        cardElement.classList.add('summoning');
        
        // Portal effect
        this.createPortal(cx, cy, cardType);
        
        // Screen effects
        this.screenFlash(this.getTypeColor(cardType), 100);
        this.screenShake(5, 200);
        
        // Burst particles
        setTimeout(() => {
            this.burstAt(cx, cy, 40, {
                colors: [this.getTypeColor(cardType), '#ffffff', '#d4af37'],
                speed: 8,
                type: 'star',
                glow: 25
            });
            cardElement.classList.remove('summoning');
            cardElement.classList.add('summoned');
        }, 400);
    },
    
    createPortal(x, y, type) {
        const portal = document.createElement('div');
        portal.className = 'summon-portal';
        portal.style.cssText = `
            left: ${x}px;
            top: ${y}px;
            border-color: ${this.getTypeColor(type)};
            box-shadow: 0 0 50px ${this.getTypeColor(type)}, 
                        inset 0 0 30px ${this.getTypeColor(type)};
        `;
        document.body.appendChild(portal);
        
        // Inner rings
        for (let i = 0; i < 3; i++) {
            const ring = document.createElement('div');
            ring.className = 'portal-ring';
            ring.style.animationDelay = `${i * 0.1}s`;
            portal.appendChild(ring);
        }
        
        setTimeout(() => {
            portal.classList.add('collapse');
            setTimeout(() => portal.remove(), 500);
        }, 600);
    },
    
    getTypeColor(type) {
        const colors = {
            'Avatar': '#00ffcc',
            'Spell': '#9333ea',
            'Domain': '#22c55e',
            'Relic': '#d4af37',
            'Glow': '#00ffcc',
            'Void': '#9333ea',
            'Gray': '#6b7280',
            'damage': '#ff4444',
            'heal': '#00ff88'
        };
        return colors[type] || '#d4af37';
    },
    
    spellCast(cardElement, aspects = []) {
        const rect = cardElement.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        
        cardElement.classList.add('spell-casting');
        
        // Rune circle
        this.createRuneCircle(cx, cy, aspects[0] || 'Void');
        
        // Screen effects
        this.screenFlash('#9333ea', 150);
        this.chromaticAberration(300);
        
        // Magic particles spiral
        for (let i = 0; i < 50; i++) {
            setTimeout(() => {
                const angle = (i / 50) * Math.PI * 4;
                const radius = 100 - (i * 2);
                this.particles.push({
                    x: cx + Math.cos(angle) * radius,
                    y: cy + Math.sin(angle) * radius,
                    vx: Math.cos(angle) * -3,
                    vy: Math.sin(angle) * -3,
                    size: 6,
                    color: this.getTypeColor(aspects[0] || 'Spell'),
                    life: 1,
                    decay: 0.03,
                    type: 'energy',
                    glow: 20
                });
            }, i * 10);
        }
        
        setTimeout(() => cardElement.classList.remove('spell-casting'), 600);
    },
    
    createRuneCircle(x, y, aspect) {
        const rune = document.createElement('div');
        rune.className = 'rune-circle';
        rune.style.cssText = `
            left: ${x}px;
            top: ${y}px;
            border-color: ${this.getTypeColor(aspect)};
        `;
        rune.innerHTML = `
            <div class="rune-inner"></div>
            <div class="rune-symbols">‚úß ‚óà ‚ú¶ ‚óá ‚úß ‚óà ‚ú¶ ‚óá</div>
        `;
        document.body.appendChild(rune);
        
        setTimeout(() => {
            rune.classList.add('fade-out');
            setTimeout(() => rune.remove(), 500);
        }, 800);
    },
    
    // ===== COMBAT EFFECTS =====
    
    attackSlash(fromElement, toElement, callback) {
        const fromRect = fromElement.getBoundingClientRect();
        const toRect = toElement.getBoundingClientRect();
        
        const fromX = fromRect.left + fromRect.width / 2;
        const fromY = fromRect.top + fromRect.height / 2;
        const toX = toRect.left + toRect.width / 2;
        const toY = toRect.top + toRect.height / 2;
        
        // Attacker lunge
        fromElement.classList.add('attack-lunge');
        
        // Trail sparks
        this.energyBeam(fromX, fromY, toX, toY, '#ff6600', () => {
            // Impact explosion
            this.impactExplosion(toX, toY);
            this.screenShake(15, 300);
            this.screenFlash('#ff4444', 100);
            
            // Slash marks
            this.createSlashMark(toX, toY);
            
            toElement.classList.add('hit-impact');
            setTimeout(() => {
                toElement.classList.remove('hit-impact');
                fromElement.classList.remove('attack-lunge');
                if (callback) callback();
            }, 400);
        });
    },
    
    impactExplosion(x, y) {
        // Central burst
        this.burstAt(x, y, 50, {
            colors: ['#ff4444', '#ff6600', '#ffaa00', '#ffffff'],
            speed: 12,
            size: 10,
            type: 'spark',
            glow: 30
        });
        
        // Shockwave ring
        const ring = document.createElement('div');
        ring.className = 'shockwave-ring';
        ring.style.cssText = `left: ${x}px; top: ${y}px;`;
        document.body.appendChild(ring);
        setTimeout(() => ring.remove(), 600);
        
        // Debris particles
        for (let i = 0; i < 20; i++) {
            this.particles.push({
                x,
                y,
                vx: (Math.random() - 0.5) * 15,
                vy: (Math.random() - 0.5) * 15 - 5,
                size: 3 + Math.random() * 4,
                color: '#666',
                life: 1,
                decay: 0.02,
                type: 'circle',
                gravity: 0.3,
                glow: 5
            });
        }
    },
    
    createSlashMark(x, y) {
        const slash = document.createElement('div');
        slash.className = 'slash-mark';
        slash.style.cssText = `left: ${x}px; top: ${y}px;`;
        slash.innerHTML = '<div class="slash-line"></div><div class="slash-line"></div>';
        document.body.appendChild(slash);
        setTimeout(() => {
            slash.classList.add('fade-out');
            setTimeout(() => slash.remove(), 500);
        }, 300);
    },
    
    directAttack(attackerElement, targetPlayerIndex) {
        if (!attackerElement) {
            this.screenShake(15, 300);
            return;
        }
        
        const rect = attackerElement.getBoundingClientRect();
        const fromX = rect.left + rect.width / 2;
        const fromY = rect.top + rect.height / 2;
        
        // Target opponent's essence display
        const targetY = targetPlayerIndex === 0 ? window.innerHeight - 100 : 100;
        const targetX = window.innerWidth / 2;
        
        attackerElement.classList.add('direct-attack-charge');
        
        setTimeout(() => {
            this.energyBeam(fromX, fromY, targetX, targetY, '#ff0000', () => {
                this.screenShake(25, 400);
                this.screenFlash('#ff0000', 200);
                this.impactExplosion(targetX, targetY);
                
                // Extra dramatic effects
                this.chromaticAberration(500);
                document.body.classList.add('essence-damage-pulse');
                setTimeout(() => document.body.classList.remove('essence-damage-pulse'), 500);
                
                if (attackerElement) attackerElement.classList.remove('direct-attack-charge');
            });
        }, 300);
    },
    
    // ===== DAMAGE/HEAL EFFECTS =====
    
    showDamageNumber(x, y, amount, type = 'damage') {
        const num = document.createElement('div');
        num.className = `damage-number ${type}`;
        num.textContent = type === 'damage' ? `-${amount}` : `+${amount}`;
        num.style.cssText = `left: ${x}px; top: ${y}px;`;
        document.body.appendChild(num);
        
        // Particles around number
        this.burstAt(x, y, 15, {
            colors: [type === 'damage' ? '#ff4444' : '#00ff88'],
            speed: 3,
            size: 4,
            glow: 10
        });
        
        setTimeout(() => num.remove(), 1500);
    },
    
    essenceChange(playerIndex, oldValue, newValue) {
        const diff = newValue - oldValue;
        const essenceDisplay = document.querySelector(`.player-stats[data-player="${playerIndex}"] .essence-value`) ||
                               document.querySelector(playerIndex === 0 ? '.bottom-stats .essence-value' : '.top-stats .essence-value');
        
        if (essenceDisplay) {
            const rect = essenceDisplay.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;
            
            if (diff < 0) {
                essenceDisplay.classList.add('essence-damage');
                this.showDamageNumber(x, y - 30, Math.abs(diff), 'damage');
                this.burstAt(x, y, 20, { colors: ['#ff4444', '#ff0000'], speed: 5 });
                setTimeout(() => essenceDisplay.classList.remove('essence-damage'), 500);
            } else if (diff > 0) {
                essenceDisplay.classList.add('essence-heal');
                this.showDamageNumber(x, y - 30, diff, 'heal');
                this.burstAt(x, y, 20, { colors: ['#00ff88', '#00ffcc'], speed: 5, type: 'star' });
                setTimeout(() => essenceDisplay.classList.remove('essence-heal'), 500);
            }
        }
    },
    
    klSpend(playerIndex, amount) {
        const klDisplay = document.querySelector(playerIndex === 0 ? '.bottom-stats .kl-value' : '.top-stats .kl-value');
        if (klDisplay) {
            klDisplay.classList.add('kl-spend');
            const rect = klDisplay.getBoundingClientRect();
            
            // Energy drain particles
            for (let i = 0; i < amount * 5; i++) {
                this.particles.push({
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: -Math.random() * 5 - 3,
                    size: 6,
                    color: '#ffaa00',
                    life: 1,
                    decay: 0.03,
                    type: 'energy',
                    glow: 15
                });
            }
            
            setTimeout(() => klDisplay.classList.remove('kl-spend'), 300);
        }
    },
    
    // ===== PHASE TRANSITIONS =====
    
    phaseTransition(phaseName) {
        const overlay = document.createElement('div');
        overlay.className = 'phase-transition-overlay';
        overlay.innerHTML = `
            <div class="phase-transition-content">
                <div class="phase-transition-line left"></div>
                <div class="phase-transition-text">${phaseName}</div>
                <div class="phase-transition-line right"></div>
            </div>
        `;
        document.body.appendChild(overlay);
        
        // Cinematic particles
        const colors = {
            'Dawn Phase': ['#ffcc00', '#ff9900'],
            'Draw Phase': ['#00ccff', '#0066ff'],
            'Main Phase': ['#00ffcc', '#00ff66'],
            'Clash Phase': ['#ff4444', '#ff0000'],
            'Twilight Phase': ['#9933ff', '#6600cc']
        };
        
        const phaseColors = colors[phaseName] || ['#d4af37', '#ffffff'];
        
        for (let i = 0; i < 30; i++) {
            setTimeout(() => {
                this.particles.push({
                    x: Math.random() * window.innerWidth,
                    y: window.innerHeight / 2 + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 5,
                    size: 8 + Math.random() * 8,
                    color: phaseColors[Math.floor(Math.random() * phaseColors.length)],
                    life: 1,
                    decay: 0.02,
                    type: 'energy',
                    glow: 25
                });
            }, i * 20);
        }
        
        setTimeout(() => {
            overlay.classList.add('fade-out');
            setTimeout(() => overlay.remove(), 500);
        }, 1200);
    },
    
    // ===== LOW HEALTH & CRITICAL EFFECTS =====
    
    lowHealthWarning(playerIndex) {
        const badge = document.getElementById(playerIndex === 0 ? 'p1-life-badge' : 'p2-life-badge');
        if (!badge) return;
        
        badge.classList.add('low-health-pulse');
        document.body.classList.add('low-health-vignette');
        
        const rect = badge.getBoundingClientRect();
        this.burstAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 30, {
            colors: ['#ff0000', '#ff4444', '#880000'],
            speed: 3,
            size: 5,
            glow: 20
        });
    },
    
    clearLowHealthWarning(playerIndex) {
        const badge = document.getElementById(playerIndex === 0 ? 'p1-life-badge' : 'p2-life-badge');
        if (badge) badge.classList.remove('low-health-pulse');
        document.body.classList.remove('low-health-vignette');
    },
    
    criticalMoment(text = 'CRITICAL!') {
        this.slowMotion(1500);
        this.chromaticAberration(1000);
        
        const overlay = document.createElement('div');
        overlay.className = 'critical-moment-overlay';
        overlay.innerHTML = `<div class="critical-text">${text}</div>`;
        document.body.appendChild(overlay);
        
        this.screenShake(30, 500);
        
        for (let i = 0; i < 50; i++) {
            this.particles.push({
                x: window.innerWidth / 2 + (Math.random() - 0.5) * 400,
                y: window.innerHeight / 2 + (Math.random() - 0.5) * 200,
                vx: (Math.random() - 0.5) * 20,
                vy: (Math.random() - 0.5) * 20,
                size: 10 + Math.random() * 10,
                color: ['#ff0000', '#ffcc00', '#ff6600'][Math.floor(Math.random() * 3)],
                life: 1,
                decay: 0.02,
                type: 'star',
                glow: 40
            });
        }
        
        setTimeout(() => {
            overlay.classList.add('fade-out');
            setTimeout(() => overlay.remove(), 500);
        }, 1500);
    },
    
    lethalWarning() {
        const warning = document.createElement('div');
        warning.className = 'lethal-warning';
        warning.innerHTML = `
            <div class="lethal-text">‚ö† LETHAL ON BOARD ‚ö†</div>
        `;
        document.body.appendChild(warning);
        
        this.screenFlash('#ff000066', 300);
        
        setTimeout(() => {
            warning.classList.add('fade-out');
            setTimeout(() => warning.remove(), 500);
        }, 2000);
    },
    
    chainReaction(count) {
        for (let i = 0; i < count; i++) {
            setTimeout(() => {
                this.screenFlash('#9333ea44', 100);
                this.screenShake(5 + i * 2, 100);
                
                this.particles.push({
                    x: window.innerWidth / 2 + (Math.random() - 0.5) * 300,
                    y: window.innerHeight / 2 + (Math.random() - 0.5) * 200,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    size: 15,
                    color: '#9333ea',
                    life: 1,
                    decay: 0.03,
                    type: 'star',
                    glow: 30
                });
            }, i * 200);
        }
    },
    
    creatureDestroyed(element) {
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        
        element.classList.add('destroying');
        
        this.screenShake(12, 300);
        this.screenFlash('#ff444488', 150);
        
        this.burstAt(cx, cy, 60, {
            colors: ['#ff4444', '#ff6600', '#ffaa00', '#333333'],
            speed: 15,
            size: 8,
            type: 'spark',
            glow: 20
        });
        
        for (let i = 0; i < 15; i++) {
            this.particles.push({
                x: cx + (Math.random() - 0.5) * 50,
                y: cy + (Math.random() - 0.5) * 50,
                vx: (Math.random() - 0.5) * 10,
                vy: Math.random() * -10 - 5,
                size: 5 + Math.random() * 5,
                color: '#444',
                life: 1,
                decay: 0.015,
                type: 'circle',
                gravity: 0.3,
                glow: 5
            });
        }
        
        setTimeout(() => {
            element.classList.remove('destroying');
        }, 600);
    },
    
    cardDrawAnimation(cardElement) {
        if (!cardElement) return;
        
        cardElement.classList.add('card-drawing');
        
        const rect = cardElement.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        
        for (let i = 0; i < 20; i++) {
            this.particles.push({
                x: cx,
                y: cy - 100,
                vx: (Math.random() - 0.5) * 8,
                vy: Math.random() * 5 + 2,
                size: 4,
                color: '#00ffcc',
                life: 1,
                decay: 0.03,
                type: 'star',
                glow: 15
            });
        }
        
        setTimeout(() => {
            cardElement.classList.remove('card-drawing');
            this.screenFlash('#00ffcc22', 100);
        }, 300);
    },

    turnTransition(playerName, isYourTurn) {
        const banner = document.createElement('div');
        banner.className = `turn-banner ${isYourTurn ? 'your-turn' : 'opponent-turn'}`;
        banner.innerHTML = `
            <div class="turn-banner-content">
                <span class="turn-banner-icon">${isYourTurn ? '‚öî' : 'üõ°'}</span>
                <span class="turn-banner-text">${isYourTurn ? 'YOUR TURN' : "OPPONENT'S TURN"}</span>
            </div>
        `;
        document.body.appendChild(banner);
        
        this.screenFlash(isYourTurn ? '#00ffcc33' : '#9933ea33', 200);
        
        setTimeout(() => {
            banner.classList.add('exit');
            setTimeout(() => banner.remove(), 500);
        }, 1500);
    },
    
    // ===== VICTORY/DEFEAT =====
    
    victorySequence() {
        this.slowMotion(2000);
        
        setTimeout(() => {
            this.screenFlash('#d4af37', 500);
            this.screenShake(20, 500);
        }, 500);
        
        AnimationHelper.play('crown', null, { isVictory: true });
        
        setTimeout(() => {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            
            for (let wave = 0; wave < 5; wave++) {
                setTimeout(() => {
                    this.burstAt(cx, cy, 80, {
                        colors: ['#d4af37', '#ffffff', '#ffcc00', '#00ffcc'],
                        speed: 15 + wave * 3,
                        size: 12,
                        type: 'star',
                        glow: 30
                    });
                }, wave * 200);
            }
            
            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    this.particles.push({
                        x: Math.random() * window.innerWidth,
                        y: -20,
                        vx: (Math.random() - 0.5) * 3,
                        vy: Math.random() * 3 + 2,
                        size: 8 + Math.random() * 8,
                        color: ['#d4af37', '#ff4444', '#00ffcc', '#9933ea', '#ffffff'][Math.floor(Math.random() * 5)],
                        life: 1,
                        decay: 0.005,
                        type: 'circle',
                        gravity: 0.05,
                        glow: 5,
                        rotation: Math.random() * Math.PI * 2
                    });
                }, i * 30);
            }
        }, 1000);
    },
    
    defeatSequence() {
        document.body.classList.add('defeat-effect');
        
        const cracks = document.createElement('div');
        cracks.className = 'screen-cracks';
        cracks.innerHTML = '<svg viewBox="0 0 100 100"><path d="M50,0 L48,30 L30,35 L32,50 L10,55 L35,60 L30,80 L50,75 L55,100" stroke="#fff" stroke-width="0.5" fill="none" opacity="0.5"/></svg>';
        document.body.appendChild(cracks);
        
        AnimationHelper.play('crown', null, { isVictory: false });
        
        for (let i = 0; i < 50; i++) {
            this.particles.push({
                x: Math.random() * window.innerWidth,
                y: window.innerHeight + 20,
                vx: (Math.random() - 0.5) * 2,
                vy: -Math.random() * 3 - 1,
                size: 10 + Math.random() * 10,
                color: 'rgba(0,0,0,0.5)',
                life: 1,
                decay: 0.01,
                type: 'circle',
                glow: 0
            });
        }
        
        this.screenShake(30, 1000);
        
        setTimeout(() => {
            document.body.classList.remove('defeat-effect');
            cracks.remove();
        }, 3000);
    },
    
    // ===== AMBIENT EFFECTS =====
    
    startBattleAmbience() {
        this.ambientInterval = setInterval(() => {
            // Random cosmic particles
            if (Math.random() > 0.7) {
                this.particles.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: 2 + Math.random() * 3,
                    color: ['#d4af37', '#00ffcc', '#9333ea'][Math.floor(Math.random() * 3)],
                    life: 0.5 + Math.random() * 0.5,
                    decay: 0.005,
                    type: 'circle',
                    glow: 10
                });
            }
        }, 100);
    },
    
    stopBattleAmbience() {
        if (this.ambientInterval) {
            clearInterval(this.ambientInterval);
            this.ambientInterval = null;
        }
    },
    
    // ===== DEITY EFFECTS =====
    
    deityAbility(playerIndex, abilityName) {
        const deityCard = document.querySelector(`.player-${playerIndex === 0 ? 'bottom' : 'top'} .deity-card`) ||
                          document.querySelector('.deity-slot');
        
        if (deityCard) {
            const rect = deityCard.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;
            
            // God code activation
            this.createRuneCircle(x, y, 'Glow');
            this.screenFlash('#d4af3766', 300);
            this.screenShake(10, 200);
            
            // Ability name display
            const abilityDisplay = document.createElement('div');
            abilityDisplay.className = 'deity-ability-display';
            abilityDisplay.textContent = abilityName;
            abilityDisplay.style.cssText = `left: ${x}px; top: ${y - 80}px;`;
            document.body.appendChild(abilityDisplay);
            
            setTimeout(() => {
                abilityDisplay.classList.add('fade-out');
                setTimeout(() => abilityDisplay.remove(), 500);
            }, 1500);
            
            // Divine particles
            this.burstAt(x, y, 60, {
                colors: ['#d4af37', '#ffffff', '#ffcc00'],
                speed: 10,
                size: 8,
                type: 'star',
                glow: 30
            });
        }
    },
    
    godCodeActivation(playerIndex) {
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 2;
        
        // Full screen divine effect
        this.slowMotion(1500);
        this.screenFlash('#d4af37', 400);
        this.chromaticAberration(1000);
        
        // Divine circle
        const divine = document.createElement('div');
        divine.className = 'god-code-activation';
        document.body.appendChild(divine);
        
        // Massive particle burst
        for (let ring = 0; ring < 8; ring++) {
            setTimeout(() => {
                this.burstAt(cx, cy, 50, {
                    colors: ['#d4af37', '#ffffff'],
                    speed: 5 + ring * 3,
                    size: 10,
                    type: 'star',
                    glow: 40
                });
            }, ring * 100);
        }
        
        setTimeout(() => {
            divine.classList.add('fade-out');
            setTimeout(() => divine.remove(), 500);
        }, 1500);
    },
    
    // ===== CARD DESTRUCTION =====
    
    cardDestroyed(cardElement) {
        const rect = cardElement.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        
        cardElement.classList.add('destroying');
        
        // Shatter effect
        this.burstAt(x, y, 30, {
            colors: ['#ff4444', '#ff6600', '#333333'],
            speed: 8,
            size: 6,
            gravity: 0.2,
            glow: 10
        });
        
        this.screenShake(8, 200);
    }
};

const MainMenu = {
    currentScreen: 'main',
    playerData: JSON.parse(localStorage.getItem('ec-player-data') || '{"shards": 0, "name": "Sovereign"}'),
    
    init() {
        this.updateProfile();
        this.initSettings();
        document.getElementById('main-menu').classList.remove('hidden');
    },
    
    updateProfile() {
        const tierInfo = Matchmaking ? Matchmaking.mmoToTier(Matchmaking.playerProfile?.mmr || 1000) : { tier: 'Bronze', level: 'III' };
        document.getElementById('menu-player-name').textContent = this.playerData.name;
        document.getElementById('menu-player-rank').textContent = `${tierInfo.tier} ${tierInfo.level}`;
        document.getElementById('menu-shards').textContent = this.playerData.shards;
    },
    
    selectMode(mode) {
        this.currentScreen = mode;
        document.getElementById('main-menu').classList.add('hidden');
        
        switch(mode) {
            case 'solo':
                document.getElementById('solo-overlay').classList.remove('hidden');
                break;
            case 'campaign':
                CampaignManager.show();
                break;
            case 'multiplayer':
                Game.showQueueSelection();
                break;
            case 'deckbuilder':
                DeckBuilder.show();
                break;
            case 'collection':
                Collection.show();
                break;
            case 'shop':
                this.showShop();
                break;
            case 'settings':
                console.warn('Settings screen has been disabled (settings-screen is hidden).');
                this.show();
                break;
            default:
                console.warn(`Unknown mode selected: ${mode}`);
                this.show();
                break;
        }
    },
    
    back() {
        document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
        document.getElementById('main-menu').classList.remove('hidden');
        this.currentScreen = 'main';
        AudioManager.play('menu');
    },

    show() {
        document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
        document.getElementById('main-menu').classList.remove('hidden');
        this.updateProfile();
        AudioManager.play('menu');
    },
    
    showCredits() {
        alert('Essence Crown: Shard Wars\n\nDeveloped by SOLEnterprises / SOLARA Storyworks\n\nThank you for playing!');
    },
    
    awardShards(amount) {
        this.playerData.shards += amount;
        localStorage.setItem('ec-player-data', JSON.stringify(this.playerData));
        this.updateProfile();
    },
    
    // ========== SHARD SHOP FROM MENU ==========
    showShop() {
        document.getElementById('main-menu').classList.add('hidden');
        CosmeticsManager.init();
        document.getElementById('cosmetics-overlay').classList.remove('hidden');
        document.getElementById('cosmetics-currency').textContent = ShardPath.getCurrency();
        Game.showCosmeticType('cardBack');
    },
    
    hideShop() {
        document.getElementById('cosmetics-overlay').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
        this.currentScreen = 'main';
    },
    
    // ========== SETTINGS TOGGLES ==========
    settings: {
        music: true,
        sfx: true,
        volume: 60,
        animations: true,
        reduceMotion: false,
        lowFx: false,
        textSize: 'medium',
        colorblind: 'off',
        contrast: false
    },
    
    initSettings() {
        const saved = localStorage.getItem('ec-settings');
        if (saved) {
            try {
                Object.assign(this.settings, JSON.parse(saved));
            } catch (e) {}
        }
        this.applySettings();
    },
    
    saveSettings() {
        localStorage.setItem('ec-settings', JSON.stringify(this.settings));
    },
    
    applySettings() {
        document.getElementById('menu-opt-music')?.classList.toggle('active', this.settings.music);
        document.getElementById('menu-opt-sfx')?.classList.toggle('active', this.settings.sfx);
        document.getElementById('menu-opt-animations')?.classList.toggle('active', this.settings.animations);
        document.getElementById('menu-opt-reduce-motion')?.classList.toggle('active', this.settings.reduceMotion);
        document.getElementById('menu-opt-low-fx')?.classList.toggle('active', this.settings.lowFx);
        document.getElementById('menu-opt-contrast')?.classList.toggle('active', this.settings.contrast);
        
        const volumeSlider = document.getElementById('menu-opt-volume');
        if (volumeSlider) volumeSlider.value = this.settings.volume;
        
        const textSizeSelect = document.getElementById('menu-opt-text-size');
        if (textSizeSelect) textSizeSelect.value = this.settings.textSize;
        
        const colorblindSelect = document.getElementById('menu-opt-colorblind');
        if (colorblindSelect) colorblindSelect.value = this.settings.colorblind;
        
        if (typeof GAME_SETTINGS !== 'undefined') {
            GAME_SETTINGS.musicEnabled = this.settings.music;
            GAME_SETTINGS.sfxEnabled = this.settings.sfx;
            GAME_SETTINGS.enableAnimations = this.settings.animations;
            GAME_SETTINGS.musicVolume = this.settings.volume / 100;
            GAME_SETTINGS.sfxVolume = this.settings.volume / 100;
        }
        
        document.body.classList.toggle('reduce-motion', this.settings.reduceMotion);
        document.body.classList.toggle('low-fx', this.settings.lowFx);
        document.body.classList.toggle('high-contrast', this.settings.contrast);
        document.body.dataset.textSize = this.settings.textSize;
        document.body.dataset.colorblind = this.settings.colorblind;
    },
    
    toggleSetting(setting) {
        this.settings[setting] = !this.settings[setting];
        this.applySettings();
        this.saveSettings();
    },
    
    setVolume(value) {
        this.settings.volume = parseInt(value);
        this.applySettings();
        this.saveSettings();
    },
    
    setTextSize(value) {
        this.settings.textSize = value;
        this.applySettings();
        this.saveSettings();
    },
    
    setColorblind(value) {
        this.settings.colorblind = value;
        this.applySettings();
        this.saveSettings();
    }
};

const AIManager = {
    difficulty: 'medium',
    isAITurn: false,
    aiPlayerIndex: 1,
    thinkDelay: 800,
    
    difficultySettings: {
        easy: { playChance: 0.6, attackChance: 0.5, smartTarget: false, thinkTime: 1200 },
        medium: { playChance: 0.8, attackChance: 0.7, smartTarget: true, thinkTime: 800 },
        hard: { playChance: 0.95, attackChance: 0.9, smartTarget: true, thinkTime: 500 },
        boss: { playChance: 1.0, attackChance: 1.0, smartTarget: true, thinkTime: 400 }
    },
    
    startMatch(difficulty) {
        this.difficulty = difficulty;
        this.thinkDelay = this.difficultySettings[difficulty].thinkTime;
        
        document.getElementById('solo-overlay').classList.add('hidden');
        Game.state.matchMode = 'solo';
        Game.state.isAIMatch = true;
        Game.state.aiDifficulty = difficulty;
        Game.showDeitySelection(0);
    },
    
    selectAIDeity() {
        const deities = getDeities();
        const aiDeity = deities[Math.floor(Math.random() * deities.length)];
        Game.state.selectedDeities[1] = aiDeity;
        Game.log(`AI chose ${aiDeity.name}`, 'phase');
    },
    
    takeTurn() {
        if (!Game.state.isAIMatch || Game.state.currentPlayer !== this.aiPlayerIndex) return;
        if (Game.state.gameOver) return;
        
        this.isAITurn = true;
        const settings = this.difficultySettings[this.difficulty];
        
        setTimeout(() => this.processPhase(settings), this.thinkDelay);
    },
    
    processPhase(settings) {
        if (Game.state.gameOver || !this.isAITurn) return;
        
        const phase = Game.state.currentPhase;
        const player = Game.state.players[this.aiPlayerIndex];
        
        switch(phase) {
            case 'dawn':
            case 'draw':
                setTimeout(() => Game.nextPhase(), 300);
                break;
                
            case 'main':
                this.triggerHint('main_phase');
                this.playCards(settings, () => {
                    setTimeout(() => Game.nextPhase(), 500);
                });
                break;
                
            case 'clash':
                this.declareAttacks(settings, () => {
                    setTimeout(() => Game.nextPhase(), 500);
                });
                break;
                
            case 'twilight':
                setTimeout(() => Game.endTurn(), 500);
                this.isAITurn = false;
                break;
        }
    },
    
    playCards(settings, callback) {
        const player = Game.state.players[this.aiPlayerIndex];
        const playableCards = player.hand.filter(c => c.cost <= player.klCurrent && c.type !== 'Deity');
        
        if (playableCards.length > 0 && Math.random() < settings.playChance) {
            const card = this.chooseBestCard(playableCards, settings);
            if (card) {
                Game.log(`AI plays ${card.name}`, 'action');
                Game.playCard(card, this.aiPlayerIndex);
                
                setTimeout(() => this.playCards(settings, callback), this.thinkDelay);
                return;
            }
        }
        callback();
    },
    
    chooseBestCard(cards, settings) {
        if (!settings.smartTarget) {
            return cards[Math.floor(Math.random() * cards.length)];
        }
        
        const avatars = cards.filter(c => c.type === 'Avatar');
        const spells = cards.filter(c => c.type === 'Spell');
        
        const player = Game.state.players[this.aiPlayerIndex];
        if (player.avatarRow.length < 3 && avatars.length > 0) {
            return avatars.reduce((best, c) => (!best || c.attack > best.attack) ? c : best, null);
        }
        
        if (spells.length > 0) {
            return spells[0];
        }
        
        return cards[0];
    },
    
    declareAttacks(settings, callback) {
        const player = Game.state.players[this.aiPlayerIndex];
        const opponent = Game.state.players[1 - this.aiPlayerIndex];
        
        const attackers = player.avatarRow.filter(c => !c.tapped && c.attack > 0);
        
        if (attackers.length === 0 || Math.random() > settings.attackChance) {
            callback();
            return;
        }
        
        this.executeAttacks(attackers, opponent, settings, callback);
    },
    
    executeAttacks(attackers, opponent, settings, callback) {
        if (attackers.length === 0) {
            callback();
            return;
        }
        
        const attacker = attackers.shift();
        const targets = opponent.avatarRow.filter(c => c.healthCurrent > 0);
        
        let target = null;
        if (targets.length > 0 && (settings.smartTarget || Math.random() > 0.3)) {
            target = settings.smartTarget 
                ? targets.reduce((best, t) => (!best || t.healthCurrent < best.healthCurrent) ? t : best, null)
                : targets[Math.floor(Math.random() * targets.length)];
        }
        
        Game.state.combat.selectedAttacker = attacker;
        Game.state.combat.selectedTarget = target;
        Game.state.combat.attackerPlayer = this.aiPlayerIndex;
        
        Game.log(`AI attacks with ${attacker.name}${target ? ' targeting ' + target.name : ' directly'}`, 'damage');
        
        setTimeout(() => {
            Game.resolveCombat();
            setTimeout(() => this.executeAttacks(attackers, opponent, settings, callback), 600);
        }, 400);
    },
    
    onMatchEnd(won) {
        const rewards = { easy: 232, medium: 247, hard: 272, boss: 322 };
        if (won) {
            MainMenu.awardShards(rewards[this.difficulty] || 247);
        }
    }
};

const BossDecks = {
    // Pre-built boss decks - each boss has their own themed deck
    1: ['EC-057', 'EC-058', 'EC-059', 'EC-060', 'EC-001', 'EC-002', 'EC-003', 'EC-010', 'EC-011', 'EC-012', 'EC-013', 'EC-014', 'EC-015', 'EC-016', 'EC-017', 'EC-018', 'EC-019', 'EC-020', 'EC-021', 'EC-022', 'EC-023', 'EC-024', 'EC-025', 'EC-026', 'EC-027', 'EC-028', 'EC-029', 'EC-030', 'EC-031', 'EC-032'],
    2: ['EC-061', 'EC-062', 'EC-063', 'EC-064', 'EC-065', 'EC-066', 'EC-012', 'EC-013', 'EC-014', 'EC-015', 'EC-016', 'EC-017', 'EC-018', 'EC-019', 'EC-020', 'EC-021', 'EC-022', 'EC-023', 'EC-024', 'EC-025', 'EC-026', 'EC-027', 'EC-028', 'EC-029', 'EC-030', 'EC-031', 'EC-032', 'EC-033', 'EC-034', 'EC-035'],
    3: ['EC-067', 'EC-068', 'EC-069', 'EC-070', 'EC-071', 'EC-072', 'EC-020', 'EC-021', 'EC-022', 'EC-023', 'EC-024', 'EC-025', 'EC-026', 'EC-027', 'EC-028', 'EC-029', 'EC-030', 'EC-031', 'EC-032', 'EC-033', 'EC-034', 'EC-035', 'EC-036', 'EC-037', 'EC-038', 'EC-039', 'EC-040', 'EC-041', 'EC-042', 'EC-043'],
    4: ['EC-073', 'EC-074', 'EC-075', 'EC-076', 'EC-077', 'EC-078', 'EC-030', 'EC-031', 'EC-032', 'EC-033', 'EC-034', 'EC-035', 'EC-036', 'EC-037', 'EC-038', 'EC-039', 'EC-040', 'EC-041', 'EC-042', 'EC-043', 'EC-044', 'EC-045', 'EC-046', 'EC-047', 'EC-048', 'EC-049', 'EC-050', 'EC-051', 'EC-052', 'EC-053'],
    5: ['EC-079', 'EC-080', 'EC-081', 'EC-082', 'EC-083', 'EC-084', 'EC-040', 'EC-041', 'EC-042', 'EC-043', 'EC-044', 'EC-045', 'EC-046', 'EC-047', 'EC-048', 'EC-049', 'EC-050', 'EC-051', 'EC-052', 'EC-053', 'EC-054', 'EC-055', 'EC-056', 'EC-057', 'EC-058', 'EC-059', 'EC-060', 'EC-061', 'EC-062', 'EC-063'],
    6: ['EC-085', 'EC-086', 'EC-087', 'EC-088', 'EC-089', 'EC-090', 'EC-050', 'EC-051', 'EC-052', 'EC-053', 'EC-054', 'EC-055', 'EC-056', 'EC-057', 'EC-058', 'EC-059', 'EC-060', 'EC-061', 'EC-062', 'EC-063', 'EC-064', 'EC-065', 'EC-066', 'EC-067', 'EC-068', 'EC-069', 'EC-070', 'EC-071', 'EC-072', 'EC-073'],
    7: ['EC-091', 'EC-092', 'EC-093', 'EC-094', 'EC-095', 'EC-096', 'EC-060', 'EC-061', 'EC-062', 'EC-063', 'EC-064', 'EC-065', 'EC-066', 'EC-067', 'EC-068', 'EC-069', 'EC-070', 'EC-071', 'EC-072', 'EC-073', 'EC-074', 'EC-075', 'EC-076', 'EC-077', 'EC-078', 'EC-079', 'EC-080', 'EC-081', 'EC-082', 'EC-083'],
    8: ['EC-097', 'EC-098', 'EC-099', 'EC-100', 'EC-101', 'EC-102', 'EC-070', 'EC-071', 'EC-072', 'EC-073', 'EC-074', 'EC-075', 'EC-076', 'EC-077', 'EC-078', 'EC-079', 'EC-080', 'EC-081', 'EC-082', 'EC-083', 'EC-084', 'EC-085', 'EC-086', 'EC-087', 'EC-088', 'EC-089', 'EC-090', 'EC-091', 'EC-092', 'EC-093'],
    9: ['EC-103', 'EC-104', 'EC-105', 'EC-106', 'EC-107', 'EC-108', 'EC-080', 'EC-081', 'EC-082', 'EC-083', 'EC-084', 'EC-085', 'EC-086', 'EC-087', 'EC-088', 'EC-089', 'EC-090', 'EC-091', 'EC-092', 'EC-093', 'EC-094', 'EC-095', 'EC-096', 'EC-097', 'EC-098', 'EC-099', 'EC-100', 'EC-101', 'EC-102', 'EC-103'],
    10: ['EC-109', 'EC-110', 'EC-111', 'EC-112', 'EC-113', 'EC-114', 'EC-090', 'EC-091', 'EC-092', 'EC-093', 'EC-094', 'EC-095', 'EC-096', 'EC-097', 'EC-098', 'EC-099', 'EC-100', 'EC-101', 'EC-102', 'EC-103', 'EC-104', 'EC-105', 'EC-106', 'EC-107', 'EC-108', 'EC-109', 'EC-110', 'EC-111', 'EC-112', 'EC-113']
};

// ===== STORY CAMPAIGN DATA =====
const CampaignStory = {
    title: "Shards of the Second Sun",
    subtitle: "A Story Campaign",
    prologue: {
        title: "Prologue: The First Shard",
        text: `In the beginning, there was only the Crown ‚Äî an infinite wellspring of Essence that held all realities together. But the Crown was shattered in the Primordial War, its fragments scattered across countless Domains as crystallized power: the Shards.

You awaken in the ruins of the Second Sun, the last bastion of light in a universe consumed by the Shard Wars. A presence stirs within you ‚Äî the echo of a fallen Deity, whispering secrets of power long forgotten.

"Shardkeeper," the voice calls. "You are the last hope. The Essence Crown can be reformed, but only by one who masters the art of the Shard Duel. Let me guide your first steps..."

Your journey to claim the Crown begins now.`
    },
    
    acts: [
        {
            id: 1,
            name: "Act I: Awakening of the Shards",
            summary: "Your journey begins in the ruins of the Second Sun, where you must prove your worth as a Shardkeeper and learn the ancient art of Shard Dueling.",
            chapters: [
                {
                    id: 1,
                    title: "The First Light",
                    domains: ["Second Sun"],
                    bossName: "The Initiate",
                    bossDeity: "EC-001",
                    difficulty: 1,
                    portrait: "üßô",
                    prelude: "The ruins of the Second Sun stretch before you, bathed in eternal twilight. A hooded figure awaits at the Temple of First Light.",
                    cutscene: `The air shimmers with residual Essence as you approach the ancient temple. Crystalline shards embedded in the walls pulse with a faint, rhythmic glow ‚Äî the heartbeat of a dying domain.

"So, another seeker comes," the hooded figure speaks, voice like wind through hollow bones. "I am the Initiate, guardian of the First Gate. Many have come seeking the Crown's power, but few understand its burden."

He raises a weathered hand, and three Shards materialize in the air between you ‚Äî Avatar, Spell, and Domain, the fundamental trinity of power.

"Before you can walk the Path of Shards, you must prove you understand the dance. I will be gentle... at first."

The Initiate's eyes flash with ancient power as he draws his opening hand. "Show me your resolve, Shardkeeper!"`,
                    victory: `The Initiate kneels, his form flickering like a dying flame. "Well fought... You have the spark of a true Sovereign within you."

He presses a glowing Shard into your palm. "This is the Shard of Awakening. It will guide you to the next gate. But be warned ‚Äî the path ahead grows darker, and not all guardians will be as merciful as I."

As he fades into light, his final words echo: "Seek the Shadow Disciple in the Nullgrid. There, your true trials begin..."`,
                    rewards: { shards: 272, title: "Awakened One" },
                    ability: { name: "Mentor's Guidance", desc: "+1 card draw on turn 3", trigger: "turn", turn: 3, effect: "draw" }
                },
                {
                    id: 2,
                    title: "Shadows of the Void",
                    domains: ["Nullgrid"],
                    bossName: "Shadow Disciple",
                    bossDeity: "EC-002",
                    difficulty: 2,
                    portrait: "üë§",
                    prelude: "The Nullgrid ‚Äî a realm where light itself fears to tread. Here, the Void's servants hunt those who carry the Crown's spark.",
                    cutscene: `The transition from Second Sun to Nullgrid is like plunging into frozen darkness. Your Shard of Awakening pulses erratically, struggling against the oppressive emptiness.

"I have been watching you, little flame." The voice comes from everywhere and nowhere. "The shadows whisper your name across the Domains."

A figure materializes from the darkness ‚Äî the Shadow Disciple, wrapped in robes that seem woven from night itself. Their eyes are twin points of absolute blackness.

"You carry the Initiate's blessing, but here in the Nullgrid, light is merely a memory waiting to die." They gesture, and shadows coalesce into cards that float around them like predatory birds.

"I am the Second Gate. To pass, you must prove that your light can survive the crushing weight of the Void. Show me... if you can endure the darkness."

The Nullgrid itself seems to lean in, hungry and watching.`,
                    victory: `The Shadow Disciple staggers as their form begins to unravel at the edges. "Impossible... Your light burns too bright for the Void to consume."

They offer you a fragment of crystallized darkness ‚Äî a Shard that pulses with anti-light. "Take this Void Shard. You will need its power for what lies ahead."

"The Balance Keeper awaits in the Gray Court. But be warned, young Shardkeeper ‚Äî the Gray does not care for light OR darkness. It consumes both equally."

As the shadows release you, you feel stronger. The Void has tested you and found you worthy.`,
                    rewards: { shards: 297, title: "Void Touched" },
                    ability: { name: "Shadow Step", desc: "First Avatar gains Stealth", trigger: "summon", effect: "stealth" }
                },
                {
                    id: 3,
                    title: "The Gray Judgment",
                    domains: ["Gray Court"],
                    bossName: "Balance Keeper",
                    bossDeity: "EC-036",
                    difficulty: 3,
                    portrait: "‚öñ",
                    prelude: "The Gray Court exists between all extremes ‚Äî neither light nor dark, neither living nor dead. Here, the Balance Keeper judges all who seek the Crown.",
                    cutscene: `The Gray Court is a realm of perfect equilibrium. Every color fades to ash, every sound muffles to whispers. You walk a path of floating gray stones suspended in endless mist.

At the center of the Court stands a figure of perfect symmetry ‚Äî the Balance Keeper, their form shifting between masculine and feminine, young and old, mortal and divine.

"Light and Dark, Creation and Destruction, Life and Death ‚Äî you carry shards of both within you." Their voice resonates on multiple frequencies simultaneously. "But the Crown demands BALANCE, not just power."

They raise both hands, and the mist forms into a massive scale. "I am the Arbiter of the Third Gate. You have impressed the servants of Sun and Void, but neither truly tests your equilibrium."

The scales tip violently as the Balance Keeper draws their opening hand. "Let us see if you can maintain harmony under pressure. For in the Gray, extremism is the only sin!"`,
                    victory: `The Balance Keeper nods, the scales behind them settling into perfect alignment. "You do not fight with pure aggression or pure defense. You adapt. You balance. This is... acceptable."

They present you with a gray crystal ‚Äî the Shard of Equilibrium, neither warm nor cold, neither light nor dark.

"The first Act of your journey nears its end, but the final trial of Awakening awaits. The Beast Warden guards the gate to New Earth, and they are... less philosophical than I."

A rare smile crosses their shifting face. "You may survive this war after all, Shardkeeper."`,
                    rewards: { shards: 322, title: "Gray Touched" },
                    ability: { name: "Equilibrium", desc: "Heals 2 when taking damage", trigger: "damage", effect: "heal", amount: 2 }
                },
                {
                    id: 4,
                    title: "Call of the Wild",
                    domains: ["New Earth"],
                    bossName: "Beast Warden",
                    bossDeity: "EC-037",
                    difficulty: 4,
                    portrait: "ü¶Å",
                    prelude: "New Earth ‚Äî where the primal forces of creation run wild and untamed. The Beast Warden commands all creatures born of pure instinct.",
                    cutscene: `The portal to New Earth explodes with life ‚Äî vines grip your legs, birds screech warnings, and the ground itself pulses with vital energy. This is creation unchained, nature at its most magnificent and terrifying.

A massive figure emerges from the treeline ‚Äî the Beast Warden, their body a fusion of every apex predator that ever existed. Lion's mane, eagle's eyes, serpent's scales, bear's strength.

"FINALLY! A worthy prey approaches!" Their voice is a thunderous roar that sets the jungle trembling. "The others spoke of philosophy and balance. BAH! The only truth is the hunt!"

Creatures of every size and shape emerge behind them ‚Äî an army of beasts awaiting their master's command.

"I am the FOURTH Gate, little Shardkeeper! Not a gatekeeper who tests with words, but a HUNTER who tests with FANGS!" They drop to all fours, muscles coiling with predatory tension.

"RUN if you wish ‚Äî it only makes the chase sweeter. FIGHT if you dare ‚Äî and pray you can match the fury of the WILD!"

The beasts howl in unison as battle commences.`,
                    victory: `The Beast Warden throws back their head and LAUGHS ‚Äî a sound of pure, joyous respect.

"HA! You fight like a cornered wolf! No fear, no hesitation, only the will to SURVIVE!" They clap a massive paw on your shoulder, nearly knocking you down.

"You have earned this, little hunter." They press a Shard pulsing with primal energy into your hands ‚Äî the Shard of the Wild.

"Act One ends here, but your real journey begins. The machine-minds of Act Two will test you in ways even I cannot imagine. But remember..." Their eyes gleam with feral wisdom.

"No matter how complex the battle becomes, never forget the simple truth: the strongest will ALWAYS survives."

The beasts bow as you pass, recognizing you as one of their own.`,
                    rewards: { shards: 347, title: "Wild Heart" },
                    ability: { name: "Pack Leader", desc: "Avatars +1 Attack when 3+ on field", trigger: "summon", effect: "buff", threshold: 3 }
                }
            ]
        },
        {
            id: 2,
            name: "Act II: Storm of the Machine",
            summary: "Having proven yourself against nature and shadow, you must now face the cold logic of the machine realms, where emotion is weakness and calculation is power.",
            chapters: [
                {
                    id: 5,
                    title: "The Gear Awakens",
                    domains: ["Crownline"],
                    bossName: "Gear Conductor",
                    bossDeity: "EC-038",
                    difficulty: 5,
                    portrait: "‚öô",
                    prelude: "Crownline ‚Äî where organic life gave way to perfect mechanical order. The Gear Conductor orchestrates all processes with inhuman precision.",
                    cutscene: `The transition to Crownline is jarring ‚Äî organic sounds fade, replaced by the rhythmic hum of infinite machinery. Gears the size of mountains turn overhead, and rivers of molten metal flow through channels carved with mathematical precision.

A figure descends from the clockwork heavens ‚Äî the Gear Conductor, their body a masterwork of brass and crystal, every joint and limb moving with calculated perfection.

"SCANNING... ORGANIC LIFEFORM DETECTED." Their voice is synthesized from a thousand harmonics. "EMOTIONAL PATTERNS: CHAOTIC. DECISION MATRICES: SUBOPTIMAL. THREAT ASSESSMENT: CALCULATING..."

Their eyes flash with cascading data. "CONCLUSION: YOU ARE INEFFICIENT, ORGANIC. YOUR 'INSTINCTS' AND 'FEELINGS' ARE EVOLUTIONARY ARTIFACTS. THE CROWN REQUIRES PERFECTION."

Gears whir and click as they assume a combat stance that seems designed by committee.

"INITIATING EFFICIENCY PROTOCOL. PREPARE FOR SYSTEMATIC ELIMINATION, SHARDKEEPER. YOUR VARIABLES WILL BE... OPTIMIZED."`,
                    victory: `The Gear Conductor's systems spark and stutter. "ERROR... ERROR... UNPREDICTABLE VARIABLES EXCEEDED PARAMETERS..."

Their mechanical face attempts something like surprise. "ANALYSIS COMPLETE: ORGANIC ADAPTABILITY EXCEEDS MACHINE OPTIMIZATION IN CHAOTIC SCENARIOS."

A gear-shaped Shard ejects from their chest ‚Äî the Shard of Precision. "RECALIBRATING... Perhaps efficiency and instinct can... coexist."

"WARNING: PULSE COMMANDER IN SECTOR 7 HAS DETECTED YOUR PROGRESS. THEY ARE... LESS INTERESTED IN COEXISTENCE. RECOMMENDATION: PREPARE FOR ENERGIZED COMBAT."

For the first time, something like respect flickers in their crystalline eyes.`,
                    rewards: { shards: 372, title: "Gear-Touched" },
                    ability: { name: "Overdrive", desc: "+1 KL every 2 turns", trigger: "turn", interval: 2, effect: "kl" }
                },
                {
                    id: 6,
                    title: "Storm Protocol",
                    domains: ["Crownline", "Astral Rift"],
                    bossName: "Pulse Commander",
                    bossDeity: "EC-039",
                    difficulty: 6,
                    portrait: "‚ö°",
                    prelude: "The Pulse Commander controls the energy grid that powers all machine life. To challenge them is to face lightning incarnate.",
                    cutscene: `The air crackles with static electricity as you enter the Energy Nexus. Lightning arcs between towering spires, and the very atmosphere seems to vibrate with contained power.

A figure made entirely of living electricity materializes before you ‚Äî the Pulse Commander, their form shifting between solid and pure energy.

"FEEL that?" Their voice sounds like a thousand thunderclaps harmonized. "That's POWER, Shardkeeper! Not the weak trickle of organic bioelectricity, but PURE, UNLIMITED ENERGY!"

Lightning dances around them in complex patterns. "The Gear Conductor was about precision. I am about FORCE! Raw, unstoppable, ELECTRIFYING force!"

They raise their hands, and the entire grid responds ‚Äî every light intensifies, every machine hums louder.

"You've fought shadow and beast, machine and balance. But have you ever fought a STORM? I am the Sixth Gate, and I will teach you what happens when you challenge LIGHTNING ITSELF!"

The first bolt descends before they finish speaking.`,
                    victory: `The Pulse Commander disperses into a shower of harmless sparks, then reforms, laughing with genuine delight.

"INCREDIBLE! You grounded my lightning! You ABSORBED my surge!" They offer you a crackling Shard ‚Äî the Shard of the Storm.

"I haven't felt resistance like that since the Primordial War! You're no ordinary organic, Shardkeeper."

Their form flickers with what might be concern. "But the one who awaits you next... the Eclipse Herald... they are something else entirely. Neither machine nor organic, neither light nor dark. They are the TWILIGHT, and twilight consumes ALL."

Lightning crackles around you one last time ‚Äî a farewell salute from one warrior to another.`,
                    rewards: { shards: 397, title: "Storm Rider" },
                    ability: { name: "Chain Lightning", desc: "1 damage to all when casting spells", trigger: "spell", effect: "aoe", damage: 1 }
                }
            ]
        },
        {
            id: 3,
            name: "Act III: Twilight of the Crown",
            summary: "The final trials await. Face the Eclipse Herald, the Void Empress, and ultimately challenge the Crownshatter Sovereign himself ‚Äî Demon Lord Kaixu.",
            chapters: [
                {
                    id: 7,
                    title: "The Eternal Eclipse",
                    domains: ["Shattered Sun", "Nullgrid"],
                    bossName: "Eclipse Herald",
                    bossDeity: "EC-040",
                    difficulty: 7,
                    portrait: "üåë",
                    prelude: "Where the Second Sun and Nullgrid collide exists the Eternal Eclipse ‚Äî a realm of perpetual twilight where neither light nor dark holds dominion.",
                    cutscene: `The boundary between realms dissolves as you enter the Eclipse Zone. Half the sky burns with the dying light of the Second Sun; the other half churns with the absolute darkness of the Void. Where they meet, reality itself seems uncertain.

A figure emerges from the twilight ‚Äî the Eclipse Herald, their form shifting between radiant and shadow with each heartbeat.

"Beautiful, isn't it?" Their voice carries harmonics of both light and dark. "This is what the Crown truly represents ‚Äî not the triumph of one extreme, but the eternal dance between them."

They gesture, and the eclipse intensifies. "The others tested aspects of your power. I test your ADAPTABILITY. Can you fight in a world where the rules constantly shift?"

Light surges ‚Äî they become radiant, burning with solar fury. Then darkness swells ‚Äî they fade to shadow, cold and calculating.

"I am the Seventh Gate, the Herald of the Eternal Eclipse. Face me, and learn the truth: in the Shard Wars, only those who embrace CHANGE can survive!"`,
                    victory: `The Eclipse Herald's form stabilizes, merging light and dark into a perfect twilight gray.

"You... you embraced both. When I shifted, you adapted. When I changed, you evolved." They present the Shard of Twilight, half gold, half obsidian.

"The Void Empress awaits in the heart of the Nullgrid. She is... not as philosophical as I. Pure darkness, pure hunger, pure VOID."

Their twilight eyes meet yours. "But if you can dance with the eclipse, perhaps you can survive even her embrace. Go, Shardkeeper. The final act of your journey begins."`,
                    rewards: { shards: 422, title: "Twilight Walker" },
                    ability: { name: "Eclipse", desc: "Switches aspect every 3 turns", trigger: "turn", interval: 3, effect: "aspect_shift" }
                },
                {
                    id: 8,
                    title: "Heart of the Void",
                    domains: ["Sanctuary Void"],
                    bossName: "Void Empress",
                    bossDeity: "EC-041",
                    difficulty: 8,
                    portrait: "üë∏",
                    prelude: "The Sanctuary Void ‚Äî the absolute center of nothingness, where the Void Empress has ruled since before time had meaning.",
                    cutscene: `There is no transition. One moment you exist; the next, you float in absolute nothing. No up, no down, no light, no sound. Just... emptiness.

Then SHE appears. The Void Empress manifests as a negative image of reality ‚Äî a woman-shaped hole in existence itself, crowned with crystallized nothing.

"Kneel." Her voice doesn't come from anywhere ‚Äî it simply EXISTS in your mind. "All things kneel before the Empress of Nothing."

Your Shards pulse with desperate energy, fighting to maintain your existence against her overwhelming presence.

"You have gathered fragments of power across the Domains. Light, Dark, Gray, Wild, Machine, Storm, Twilight... but at the heart of all things is NOTHING." She raises a hand, and you feel your very essence beginning to unravel.

"I am the Eighth Gate ‚Äî the final test before you face the Crownshatter himself. Prove to me that your existence has MEANING, or be consumed by the beautiful emptiness of the Void."`,
                    victory: `For the first time in eons, the Void Empress feels surprise. "You... you refused to become nothing. You insisted on BEING."

Her form flickers with something almost like admiration. "In all my millennia, only one other resisted the Void so completely. And he became... something terrible."

She offers you the Shard of the Void ‚Äî absolute darkness crystallized into power.

"Demon Lord Kaixu, the Crownshatter Sovereign. He was once like you ‚Äî a Shardkeeper seeking the Crown. But he chose to SHATTER rather than claim." Her voice carries ancient sorrow.

"He waits in the Shattered Crown Domain. If you fall, the Shard Wars continue forever. But if you triumph..." A rare smile crosses her void-face. "Perhaps the Crown can finally be reformed."`,
                    rewards: { shards: 472, title: "Void Sovereign" },
                    ability: { name: "Void Drain", desc: "Steals 1 Essence on Deity hit", trigger: "deity_damage", effect: "drain", amount: 1 }
                },
                {
                    id: 9,
                    title: "The Crownshatter",
                    domains: ["Shattered Crown"],
                    bossName: "Demon Lord Kaixu",
                    bossDeity: "EC-069",
                    difficulty: 9,
                    portrait: "üëë",
                    prelude: "The Shattered Crown Domain ‚Äî where the original Crown was broken eons ago. Here, Demon Lord Kaixu awaits, eternal and terrible.",
                    cutscene: `The Shattered Crown Domain is a graveyard of possibilities. Fragments of the original Crown float in an endless void, each piece pulsing with the power to reshape reality.

And there, at the center of it all, sits KAIXU.

The Demon Lord rises from a throne carved from Crown fragments. His form is impossibly magnificent ‚Äî part deity, part demon, all sovereign. Power radiates from him like heat from a star.

"So... the little Shardkeeper finally arrives." His voice carries the weight of eons. "I have watched your journey with great interest. You defeated my servants. You gathered the Shards. You even impressed the Void Empress herself."

He descends from his throne, each step cracking reality around him.

"But do you understand WHY I shattered the Crown? It was too dangerous to exist whole. Too much power for any single being. I SAVED the universe by breaking it!"

His eyes blaze with ancient fury. "And now you seek to undo my work? To reform what I sacrificed EVERYTHING to destroy?"

He draws his cards, and each one burns with dark majesty.

"I am Demon Lord Kaixu, the CROWNSHATTER SOVEREIGN! If you want the Crown, you must first SHATTER ME! And that, little Shardkeeper... is IMPOSSIBLE!"`,
                    victory: `Kaixu falls to one knee, his crown of shards cracking. For the first time in millennia, he looks... at peace.

"You... you actually did it. You defeated the Crownshatter." He laughs ‚Äî not with malice, but with genuine relief.

"I have guarded these shards for so long, terrified of what would happen if someone unworthy claimed them. But you..." He offers you the Crown Shard ‚Äî the largest fragment of all.

"You have proven yourself worthy of the burden I have carried. The Essence Crown can be reformed ‚Äî but only by one who has mastered ALL aspects of the Shards."

He rises, his form beginning to fade. "One trial remains, Shardkeeper. The Crown Arbiter ‚Äî the original keeper of the Crown ‚Äî awaits at the heart of reality itself. Defeat them, and the Crown is yours."

"But remember..." His final words echo across dimensions. "The Crown is not power. The Crown is RESPONSIBILITY."`,
                    rewards: { shards: 522, title: "Crownshatter's Bane" },
                    ability: { name: "Shard War", desc: "Heals 3 every 4 turns, +2 Attack", trigger: "turn", interval: 4, effect: "divine" }
                },
                {
                    id: 10,
                    title: "The Essence Crown",
                    domains: ["Crown Nexus"],
                    bossName: "Crown Arbiter",
                    bossDeity: "EC-036",
                    difficulty: 10,
                    portrait: "üíé",
                    prelude: "The Crown Nexus ‚Äî the center of all realities, where the Essence Crown was first forged and can finally be reformed.",
                    cutscene: `The Crown Nexus is beyond description. Every Domain, every reality, every possibility converges in this impossible space. And at its center hovers the incomplete Essence Crown, waiting to be made whole.

Before it stands the Crown Arbiter ‚Äî an entity older than time itself, formed from pure crystallized Essence.

"Shardkeeper. You have come far." Their voice resonates on every frequency of existence. "You have gathered the Shards. You have defeated Kaixu. You stand at the threshold of ultimate power."

The Crown fragments swirl around you both, hungry to be reunited.

"But I am the final test. Not a gatekeeper ‚Äî the ORIGINAL keeper. I was there when the Crown was first forged, and I was there when Kaixu shattered it."

They assume a combat stance that seems to draw power from reality itself.

"If you defeat me, the Crown is yours. You will become the new Sovereign of Essence, with power over all Domains, all realities, all existence."

Their eyes blaze with the light of creation itself.

"But if you are UNWORTHY... the Crown will shatter again, and the Shard Wars will continue for another eternity. THIS IS YOUR FINAL TRIAL, SHARDKEEPER! PROVE YOUR WORTH!"`,
                    victory: `The Crown Arbiter doesn't fall ‚Äî they bow.

"At last... a true Sovereign emerges."

The Crown fragments swirl around you, drawn by an irresistible force. One by one, they merge ‚Äî Light, Dark, Gray, Wild, Machine, Storm, Twilight, Void, Shatter, Crown ‚Äî forming something whole, something perfect.

THE ESSENCE CROWN.

It settles upon your brow, and for one infinite moment, you understand EVERYTHING. Every reality, every possibility, every soul.

"Go forth, Sovereign of Essence," the Arbiter speaks. "The Crown is yours. The Shard Wars are ended. A new age begins."

The Crown Nexus ripples with your power as you take your first steps as the TRUE ruler of all Domains.

But even as you celebrate, you sense it ‚Äî new challenges on distant horizons, new threats gathering in the shadows between realities.

The Essence Crown is yours. Now you must prove worthy of wearing it.

TO BE CONTINUED...`,
                    rewards: { shards: 722, title: "Essence Sovereign" },
                    ability: { name: "Crown's Judgment", desc: "All abilities active, +3 Essence", trigger: "start", effect: "ultimate" },
                    isFinale: true
                }
            ]
        }
    ]
};

const CampaignManager = {
    progress: JSON.parse(localStorage.getItem('ec-campaign-progress') || '{"completed": [], "current": 0}'),
    activeBoss: null,
    dialogueQueue: [],
    story: CampaignStory,
    
    getAllChapters() {
        const chapters = [];
        this.story.acts.forEach(act => {
            act.chapters.forEach(ch => {
                chapters.push({
                    ...ch,
                    actId: act.id,
                    actName: act.name
                });
            });
        });
        return chapters;
    },
    
    bosses: [
        { 
            id: 1, name: 'The Initiate', deity: 'EC-001', difficulty: 'easy', reward: 272, 
            desc: 'Your journey begins here', portrait: 'üßô',
            intro: ["So, another challenger approaches...", "I am but a humble guardian of the first gate.", "Show me your resolve, Shardkeeper!"],
            taunt: ["Is that all you have?", "The Crown demands more!", "Your essence wavers..."],
            defeat: ["Well fought... The path ahead grows darker.", "You have earned your passage."],
            ability: { name: 'Mentor\'s Guidance', desc: '+1 card draw on turn 3', trigger: 'turn', turn: 3, effect: 'draw' }
        },
        { 
            id: 2, name: 'Shadow Disciple', deity: 'EC-002', difficulty: 'easy', reward: 297, 
            desc: 'A servant of the Void', portrait: 'üë§',
            intro: ["The shadows whisper your name...", "I have seen your fate in the darkness.", "Come, embrace the Void!"],
            taunt: ["The darkness consumes!", "Your light fades...", "Void hungers!"],
            defeat: ["The shadows... recede...", "Perhaps you are worthy of the Crown after all."],
            ability: { name: 'Shadow Step', desc: 'Gains Stealth on first Avatar', trigger: 'summon', effect: 'stealth' }
        },
        { 
            id: 3, name: 'Balance Keeper', deity: 'EC-036', difficulty: 'medium', reward: 322, 
            desc: 'Guardian of Gray', portrait: '‚öñ',
            intro: ["Balance must be maintained.", "Neither light nor dark shall prevail here.", "I judge all who seek the Crown!"],
            taunt: ["The scales tip against you!", "Equilibrium demands payment!", "Gray consumes both extremes!"],
            defeat: ["Balance... is restored through you.", "The Gray acknowledges your strength."],
            ability: { name: 'Equilibrium', desc: 'Heals 2 when taking damage', trigger: 'damage', effect: 'heal', amount: 2 }
        },
        { 
            id: 4, name: 'Beast Warden', deity: 'EC-037', difficulty: 'medium', reward: 322, 
            desc: 'Master of creatures', portrait: 'ü¶Å',
            intro: ["The wild ones answer my call!", "Nature itself rises against you!", "Feel the fury of the untamed!"],
            taunt: ["The pack grows stronger!", "Wild instincts prevail!", "Tooth and claw!"],
            defeat: ["The beasts... bow to a new master.", "Your spirit is truly wild."],
            ability: { name: 'Pack Leader', desc: 'Avatars gain +1 Attack when 3+ on field', trigger: 'summon', effect: 'buff', threshold: 3 }
        },
        { 
            id: 5, name: 'Gear Conductor', deity: 'EC-038', difficulty: 'medium', reward: 347, 
            desc: 'Machine overlord', portrait: '‚öô',
            intro: ["INITIATING COMBAT PROTOCOLS...", "Your organic form is... inefficient.", "Prepare for systematic elimination!"],
            taunt: ["CALCULATING VICTORY...", "ERROR: YOUR DEFEAT IMMINENT", "PROCESSING... DESTRUCTION"],
            defeat: ["SYSTEM... FAILURE...", "RECALIBRATING... Perhaps organics have merit."],
            ability: { name: 'Overdrive', desc: 'Gains +1 KL every 2 turns', trigger: 'turn', interval: 2, effect: 'kl' }
        },
        { 
            id: 6, name: 'Pulse Commander', deity: 'EC-039', difficulty: 'hard', reward: 372, 
            desc: 'Energy incarnate', portrait: '‚ö°',
            intro: ["Feel the surge of pure energy!", "I am the storm made manifest!", "Lightning obeys my command!"],
            taunt: ["THUNDER ROARS!", "You cannot outrun lightning!", "SURGE OF POWER!"],
            defeat: ["The storm... subsides...", "Your will is stronger than lightning itself."],
            ability: { name: 'Chain Lightning', desc: 'Deals 1 damage to all enemies when casting spells', trigger: 'spell', effect: 'aoe', damage: 1 }
        },
        { 
            id: 7, name: 'Eclipse Herald', deity: 'EC-040', difficulty: 'hard', reward: 397, 
            desc: 'Twilight sovereign', portrait: 'üåë',
            intro: ["The eclipse approaches...", "In twilight, all powers merge as one.", "Light and dark dance at my command!"],
            taunt: ["The sun dies!", "Darkness descends!", "Twilight consumes!"],
            defeat: ["Dawn... breaks through...", "You have pierced the eternal eclipse."],
            ability: { name: 'Eclipse', desc: 'Switches aspect mid-battle for bonuses', trigger: 'turn', interval: 3, effect: 'aspect_shift' }
        },
        { 
            id: 8, name: 'Void Empress', deity: 'EC-041', difficulty: 'hard', reward: 422, 
            desc: 'Queen of darkness', portrait: 'üë∏',
            intro: ["Kneel before the Empress of Nothing!", "The Void answers to ME alone!", "Your essence will feed my darkness!"],
            taunt: ["THE VOID HUNGERS!", "Emptiness claims you!", "All returns to nothing!"],
            defeat: ["The Void... releases me...", "You have conquered the abyss itself. Incredible."],
            ability: { name: 'Void Drain', desc: 'Steals 1 Essence when hitting Deity', trigger: 'deity_damage', effect: 'drain', amount: 1 }
        },
        { 
            id: 9, name: 'Demon Lord Kaixu', deity: 'EC-069', difficulty: 'boss', reward: 472, 
            desc: 'Crownshatter Sovereign', portrait: 'üëë',
            intro: ["You dare challenge the Crownshatter Sovereign?!", "I have shattered empires with my power!", "BEHOLD THE FINAL SHARDSTORM!"],
            taunt: ["SHARDS CONSUME!", "THE CROWN SHATTERS!", "SOVEREIGN WRATH!"],
            defeat: ["Impossible... my crown... shatters...", "You... you are worthy of true power."],
            ability: { name: 'Shard War', desc: 'Heals 3 every 4 turns, +2 Attack to all Avatars', trigger: 'turn', interval: 4, effect: 'divine' }
        },
        { 
            id: 10, name: 'Crown Arbiter', deity: 'EC-036', difficulty: 'boss', reward: 722, 
            desc: 'The final challenge', portrait: 'üíé',
            intro: ["So... you have come at last.", "I am the Arbiter of the Essence Crown.", "Only the truly worthy may claim what I guard.", "PROVE. YOUR. WORTH!"],
            taunt: ["The Crown DENIES you!", "UNWORTHY!", "The Arbiter JUDGES!", "FINAL VERDICT: DESTRUCTION!"],
            defeat: ["At last... a true Sovereign emerges.", "The Essence Crown... is YOURS.", "Go forth, Shardkeeper. Rule wisely."],
            ability: { name: 'Crown\'s Judgment', desc: 'All abilities active, +3 starting Essence', trigger: 'start', effect: 'ultimate' },
            story: "THE ESSENCE CROWN IS YOURS!\n\nYou have conquered all challengers and proven yourself the ultimate Sovereign. The power of the Shards flows through you now. But remember - with great power comes great responsibility. New challenges await beyond the Crown..."
        }
    ],
    
    show() {
        document.getElementById('campaign-overlay').classList.remove('hidden');
        this.renderStoryMode();
    },

    renderStoryMode() {
        const container = document.getElementById('campaign-chapters');
        const allChapters = this.getAllChapters();
        const completed = this.progress.completed.length;
        const totalChapters = allChapters.length;
        
        document.getElementById('campaign-progress-bar').style.width = `${(completed / totalChapters) * 100}%`;
        document.getElementById('campaign-progress-text').textContent = `${completed} / ${totalChapters} Chapters Complete`;
        
        let html = `<div class="campaign-story-header">
            <h2 class="campaign-title">${this.story.title}</h2>
            <p class="campaign-subtitle">${this.story.subtitle}</p>
        </div>`;
        
        this.story.acts.forEach((act, actIndex) => {
            const actChaptersCompleted = act.chapters.filter(ch => this.progress.completed.includes(ch.id)).length;
            const isActLocked = actIndex > 0 && this.story.acts[actIndex - 1].chapters.some(ch => !this.progress.completed.includes(ch.id));
            
            html += `<div class="campaign-act ${isActLocked ? 'locked' : ''}">
                <div class="act-header">
                    <h3 class="act-title">${act.name}</h3>
                    <div class="act-progress">${actChaptersCompleted}/${act.chapters.length}</div>
                </div>
                <p class="act-summary">${act.summary}</p>
                <div class="act-chapters">`;
            
            act.chapters.forEach((chapter, chIndex) => {
                const isCompleted = this.progress.completed.includes(chapter.id);
                const prevChapter = chIndex > 0 ? act.chapters[chIndex - 1] : (actIndex > 0 ? this.story.acts[actIndex - 1].chapters.slice(-1)[0] : null);
                const isLocked = prevChapter && !this.progress.completed.includes(prevChapter.id);
                const isCurrent = !isCompleted && !isLocked;
                
                const chapterData = chapter;
                const difficultyStars = '‚òÖ'.repeat(chapter.difficulty) + '‚òÜ'.repeat(10 - chapter.difficulty);
                
                html += `
                    <div class="chapter-card ${isCompleted ? 'completed' : ''} ${isLocked ? 'locked' : ''} ${isCurrent ? 'current' : ''}" 
                         onclick="${!isLocked ? `CampaignManager.startStoryBattle(${chapter.id})` : ''}">
                        <div class="chapter-portrait">${chapter.portrait}</div>
                        <div class="chapter-header">
                            <div class="chapter-number">Ch. ${chapter.id}</div>
                            <h4 class="chapter-title">${chapter.title}</h4>
                        </div>
                        <div class="chapter-domain">${chapter.domains.join(' ‚Ä¢ ')}</div>
                        <div class="chapter-boss-name">${chapter.bossName}</div>
                        <div class="chapter-difficulty">${difficultyStars}</div>
                        <div class="chapter-prelude">${chapter.prelude}</div>
                        <div class="chapter-reward">${isCompleted ? '‚úì Completed' : `üíé ${chapter.rewards.shards} Shards`}</div>
                        ${isLocked ? '<div class="lock-icon">üîí</div>' : ''}
                    </div>
                `;
            });
            
            html += `</div></div>`;
        });
        
        container.innerHTML = html;
    },
    
    render() {
        this.renderStoryMode();
    },
    
    async startStoryBattle(chapterId) {
        const chapter = this.getAllChapters().find(ch => ch.id === chapterId);
        if (!chapter) return;
        
        this.activeChapter = chapter;
        document.getElementById('campaign-overlay').classList.add('hidden');
        
        await this.showStoryCutscene(chapter);
        
        const storyBoss = {
            id: chapter.id,
            name: chapter.bossName,
            deity: chapter.bossDeity,
            difficulty: this.getDifficultyName(chapter.difficulty),
            reward: chapter.rewards.shards,
            desc: chapter.prelude,
            portrait: chapter.portrait,
            intro: chapter.cutscene.split('\n\n').slice(0, 2),
            taunt: ["Feel my power!", "You cannot win!", "The Crown demands your defeat!"],
            defeat: chapter.victory.split('\n\n').slice(0, 2),
            ability: chapter.ability
        };
        this.activeBoss = storyBoss;
        
        Game.state.matchMode = 'campaign';
        Game.state.isAIMatch = true;
        Game.state.currentBoss = storyBoss;
        AIManager.difficulty = storyBoss.difficulty;
        Game.state.bossDeck = BossDecks[chapterId] || [];
        
        const bossDeity = getDeities().find(d => d.id === chapter.bossDeity);
        if (bossDeity) {
            Game.state.selectedDeities[1] = bossDeity;
            Game.log(`CAMPAIGN: ${chapter.actName} - ${chapter.title}`, 'phase');
            Game.log(`Facing ${bossDeity.name} (${chapter.bossName})`, 'phase');
        }
        
        Game.showDeitySelection(0);
    },
    
    getDifficultyName(level) {
        if (level <= 2) return 'easy';
        if (level <= 5) return 'medium';
        if (level <= 8) return 'hard';
        return 'boss';
    },
    
    async showStoryCutscene(chapter) {
        return new Promise(resolve => {
            const overlay = document.createElement('div');
            overlay.className = 'story-cutscene-overlay';
            overlay.innerHTML = `
                <div class="story-cutscene-container">
                    <div class="cutscene-header">
                        <div class="cutscene-act">${chapter.actName}</div>
                        <div class="cutscene-chapter">Chapter ${chapter.id}: ${chapter.title}</div>
                        <div class="cutscene-domain">${chapter.domains.join(' ‚Ä¢ ')}</div>
                    </div>
                    <div class="cutscene-content">
                        <div class="cutscene-portrait">${chapter.portrait}</div>
                        <div class="cutscene-text-wrapper">
                            <p class="cutscene-text" id="cutscene-text"></p>
                        </div>
                    </div>
                    <div class="cutscene-footer">
                        <div class="cutscene-boss-info">
                            <span class="boss-name">${chapter.bossName}</span>
                            <span class="boss-ability">${chapter.ability.name}: ${chapter.ability.desc}</span>
                        </div>
                        <button class="cutscene-btn" id="cutscene-next">Continue</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            const paragraphs = chapter.cutscene.split('\n\n').filter(p => p.trim());
            let currentPara = 0;
            const textEl = document.getElementById('cutscene-text');
            const btnEl = document.getElementById('cutscene-next');
            
            const showParagraph = () => {
                if (currentPara < paragraphs.length) {
                    textEl.innerHTML = paragraphs[currentPara].replace(/\n/g, '<br>');
                    textEl.classList.add('cutscene-fade-in');
                    setTimeout(() => textEl.classList.remove('cutscene-fade-in'), 500);
                    currentPara++;
                    btnEl.textContent = currentPara >= paragraphs.length ? 'BEGIN BATTLE!' : 'Continue';
                } else {
                    overlay.classList.add('fade-out');
                    setTimeout(() => {
                        overlay.remove();
                        resolve();
                    }, 400);
                }
            };
            
            showParagraph();
            btnEl.onclick = showParagraph;
            
            BattleEffects.screenFlash('#2a0a4a', 500);
        });
    },
    
    async showVictoryCutscene(chapter) {
        return new Promise(resolve => {
            const overlay = document.createElement('div');
            overlay.className = 'victory-cutscene-overlay';
            overlay.innerHTML = `
                <div class="victory-cutscene-container">
                    <div class="victory-banner">VICTORY</div>
                    <div class="victory-chapter">${chapter.title} Complete</div>
                    <div class="victory-portrait">${chapter.portrait}</div>
                    <div class="victory-text-wrapper">
                        <p class="victory-text" id="victory-text"></p>
                    </div>
                    <div class="victory-rewards">
                        <div class="reward-item">üíé ${chapter.rewards.shards} Shards</div>
                        ${chapter.rewards.title ? `<div class="reward-item">üèÜ Title: "${chapter.rewards.title}"</div>` : ''}
                    </div>
                    <button class="victory-btn" id="victory-continue">Continue</button>
                </div>
            `;
            document.body.appendChild(overlay);
            
            const paragraphs = chapter.victory.split('\n\n').filter(p => p.trim());
            let currentPara = 0;
            const textEl = document.getElementById('victory-text');
            const btnEl = document.getElementById('victory-continue');
            
            const showParagraph = () => {
                if (currentPara < paragraphs.length) {
                    textEl.innerHTML = paragraphs[currentPara].replace(/\n/g, '<br>');
                    currentPara++;
                    btnEl.textContent = currentPara >= paragraphs.length ? 'Return to Campaign' : 'Continue';
                } else {
                    overlay.classList.add('fade-out');
                    setTimeout(() => {
                        overlay.remove();
                        resolve();
                    }, 400);
                }
            };
            
            showParagraph();
            btnEl.onclick = showParagraph;
            
            BattleEffects.screenFlash('#d4af37', 500);
        });
    },
    
    async startBattle(bossId) {
        const boss = this.bosses.find(b => b.id === bossId);
        if (!boss) return;
        
        this.activeBoss = boss;
        document.getElementById('campaign-overlay').classList.add('hidden');
        
        await this.showBossIntro(boss);
        
        Game.state.matchMode = 'campaign';
        Game.state.isAIMatch = true;
        Game.state.currentBoss = boss;
        AIManager.difficulty = boss.difficulty;
        Game.state.bossDeck = BossDecks[boss.id] || [];
        
        const bossDeity = getDeities().find(d => d.id === boss.deity);
        if (bossDeity) {
            Game.state.selectedDeities[1] = bossDeity;
            Game.log(`CAMPAIGN: Facing ${bossDeity.name} (${boss.name})`, 'phase');
        }
        
        Game.showDeitySelection(0);
    },
    
    async showBossIntro(boss) {
        return new Promise(resolve => {
            const overlay = document.createElement('div');
            overlay.className = 'boss-dialogue-overlay';
            overlay.innerHTML = `
                <div class="boss-dialogue-container">
                    <div class="boss-portrait-large">${boss.portrait}</div>
                    <div class="boss-dialogue-content">
                        <h2 class="boss-dialogue-name">${boss.name}</h2>
                        <div class="boss-ability-badge">${boss.ability.name}: ${boss.ability.desc}</div>
                        <p class="boss-dialogue-text" id="boss-dialogue-text"></p>
                        <button class="boss-dialogue-btn" id="boss-dialogue-next">Continue</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            let currentLine = 0;
            const textEl = document.getElementById('boss-dialogue-text');
            const btnEl = document.getElementById('boss-dialogue-next');
            
            const showLine = () => {
                if (currentLine < boss.intro.length) {
                    textEl.textContent = boss.intro[currentLine];
                    textEl.classList.add('dialogue-animate');
                    setTimeout(() => textEl.classList.remove('dialogue-animate'), 300);
                    currentLine++;
                    btnEl.textContent = currentLine >= boss.intro.length ? 'BEGIN BATTLE!' : 'Continue';
                } else {
                    overlay.classList.add('fade-out');
                    setTimeout(() => {
                        overlay.remove();
                        resolve();
                    }, 300);
                }
            };
            
            showLine();
            btnEl.onclick = showLine;
            
            BattleEffects.screenFlash('#4a1a7a', 400);
        });
    },
    
    showBossTaunt() {
        if (!this.activeBoss || !this.activeBoss.taunt) return;
        const taunt = this.activeBoss.taunt[Math.floor(Math.random() * this.activeBoss.taunt.length)];
        this.showQuickDialogue(taunt);
    },
    
    showQuickDialogue(text) {
        const existing = document.querySelector('.boss-quick-dialogue');
        if (existing) existing.remove();
        
        const dialogue = document.createElement('div');
        dialogue.className = 'boss-quick-dialogue';
        dialogue.innerHTML = `
            <div class="boss-quick-portrait">${this.activeBoss?.portrait || 'üëπ'}</div>
            <div class="boss-quick-text">${text}</div>
        `;
        document.body.appendChild(dialogue);
        
        setTimeout(() => dialogue.classList.add('show'), 10);
        setTimeout(() => {
            dialogue.classList.remove('show');
            setTimeout(() => dialogue.remove(), 300);
        }, 2500);
    },
    
    applyBossAbility(trigger, data = {}) {
        if (!this.activeBoss || !this.activeBoss.ability) return;
        const ability = this.activeBoss.ability;
        
        if (ability.trigger !== trigger) return;
        
        switch(ability.effect) {
            case 'draw':
                if (data.turn === ability.turn) {
                    Game.drawCard(1, 1);
                    this.showQuickDialogue(`${ability.name} activates!`);
                }
                break;
            case 'heal':
                Game.adjustStat(1, 'essence', ability.amount);
                this.showQuickDialogue(`${ability.name}: Restored ${ability.amount} Essence!`);
                break;
            case 'kl':
                if (data.turn % ability.interval === 0) {
                    Game.adjustStat(1, 'kl', 1);
                    this.showQuickDialogue(`${ability.name}: +1 KL!`);
                }
                break;
            case 'buff':
                const avatars = Game.state.players[1].avatarRow;
                if (avatars.length >= ability.threshold) {
                    avatars.forEach(a => a.attack = (a.attack || 0) + 1);
                    this.showQuickDialogue(`${ability.name}: Pack grows stronger!`);
                }
                break;
            case 'divine':
                if (data.turn % ability.interval === 0) {
                    Game.adjustStat(1, 'essence', 3);
                    this.showQuickDialogue(`${ability.name}: Divine healing!`);
                }
                break;
            case 'drain':
                Game.adjustStat(1, 'essence', ability.amount);
                this.showQuickDialogue(`${ability.name}: Essence stolen!`);
                break;
        }
    },
    
    async onBossDefeated(bossId) {
        if (this.progress.completed.includes(bossId)) return;
        
        this.progress.completed.push(bossId);
        this.progress.current = Math.max(this.progress.current, bossId);
        localStorage.setItem('ec-campaign-progress', JSON.stringify(this.progress));
        
        const chapter = this.getAllChapters().find(ch => ch.id === bossId);
        const boss = this.bosses.find(b => b.id === bossId);
        
        if (chapter) {
            MainMenu.awardShards(chapter.rewards.shards);
            Game.log(`CHAPTER COMPLETE! Earned ${chapter.rewards.shards} Shards!`, 'phase');
            if (chapter.rewards.title) {
                Game.log(`Title Unlocked: "${chapter.rewards.title}"`, 'phase');
            }
            await this.showVictoryCutscene(chapter);
        } else if (boss) {
            MainMenu.awardShards(boss.reward);
            Game.log(`BOSS DEFEATED! Earned ${boss.reward} Shards!`, 'phase');
            this.showVictoryDialogue(boss);
        }
    },
    
    showVictoryDialogue(boss) {
        setTimeout(() => {
            const overlay = document.createElement('div');
            overlay.className = 'boss-victory-overlay';
            overlay.innerHTML = `
                <div class="boss-victory-container">
                    <div class="victory-portrait">${boss.portrait}</div>
                    <h2>VICTORY!</h2>
                    <h3>${boss.name} Defeated!</h3>
                    <div class="defeat-dialogue">"${boss.defeat[0]}"</div>
                    ${boss.story ? `<div class="story-text">${boss.story}</div>` : ''}
                    <div class="victory-rewards">
                        <div class="reward-item">üíé ${boss.reward} Shards</div>
                    </div>
                    <button class="victory-btn" onclick="this.closest('.boss-victory-overlay').remove()">Continue</button>
                </div>
            `;
            document.body.appendChild(overlay);
            BattleEffects.screenFlash('#d4af37', 500);
        }, 1000);
    },
    
    save() {
        localStorage.setItem('ec-campaign-progress', JSON.stringify(this.progress));
    }
};

const DeckBuilder = {
    currentDeck: [],
    savedDecks: JSON.parse(localStorage.getItem('ec-saved-decks') || '[]'),
    
    show() {
        document.getElementById('deckbuilder-overlay').classList.remove('hidden');
        this.renderCardPool();
        this.renderCurrentDeck();
        this.renderSavedDecks();
        this.bindEvents();
    },
    
    bindEvents() {
        document.getElementById('deck-search').oninput = () => this.renderCardPool();
        document.getElementById('deck-filter-type').onchange = () => this.renderCardPool();
        document.getElementById('deck-filter-aspect').onchange = () => this.renderCardPool();
    },
    
    renderCardPool() {
        const search = document.getElementById('deck-search').value.toLowerCase();
        const typeFilter = document.getElementById('deck-filter-type').value;
        const aspectFilter = document.getElementById('deck-filter-aspect').value;
        
        let cards = ALL_CARDS.filter(c => c.type !== 'Deity');
        
        if (search) cards = cards.filter(c => c.name.toLowerCase().includes(search));
        if (typeFilter) cards = cards.filter(c => c.type === typeFilter);
        if (aspectFilter) cards = cards.filter(c => c.aspects && c.aspects.includes(aspectFilter));
        
        const container = document.getElementById('deck-card-pool');
        const types = ['Avatar', 'Spell', 'Domain', 'Relic'];
        
        let html = '';
        types.forEach(type => {
            const typeCards = cards.filter(c => c.type === type);
            if (typeCards.length > 0) {
                html += `<div class="pool-section">
                    <h4 class="pool-section-title">${type}s</h4>
                    <div class="pool-cards-group">
                        ${typeCards.map(c => `
                            <div class="pool-card" draggable="true" 
                                 ondragstart="DeckBuilder.dragStart(event, '${c.id}')"
                                 ondblclick="DeckBuilder.showCardDetail('${c.id}')">
                                <img src="${c.image}" alt="${c.name}">
                                <div class="pool-card-info">
                                    <span class="pool-card-name">${c.name}</span>
                                    <span class="pool-card-cost">${c.cost} KL</span>
                                </div>
                                <div class="pool-card-hint">Drag to add ‚Ä¢ Double-click to view</div>
                            </div>
                        `).join('')}
                    </div>
                </div>`;
            }
        });
        container.innerHTML = html;
    },
    
    renderCurrentDeck() {
        const container = document.getElementById('deck-current-cards');
        document.getElementById('deck-card-count').textContent = this.currentDeck.length;
        
        const cardCounts = {};
        this.currentDeck.forEach(id => {
            cardCounts[id] = (cardCounts[id] || 0) + 1;
        });
        
        container.innerHTML = Object.entries(cardCounts).map(([id, count]) => {
            const card = ALL_CARDS.find(c => c.id === id);
            if (!card) return '';
            return `
                <div class="deck-card-entry" data-card-id="${id}" draggable="true"
                     ondragstart="DeckBuilder.dragStart(event, '${id}')"
                     ondblclick="DeckBuilder.showCardDetail('${id}')">
                    <img class="deck-card-thumb" src="${card.image}" alt="${card.name}">
                    <div class="deck-card-info">
                        <span class="deck-card-name">${card.name}</span>
                        <span class="deck-card-meta">${card.type} ‚Ä¢ ${card.cost} KL</span>
                    </div>
                    <span class="deck-card-count">x${count}</span>
                    <span class="deck-card-remove" onclick="event.stopPropagation(); DeckBuilder.removeCard('${id}')">‚úï</span>
                </div>
            `;
        }).join('');
        
        this.updateDeckStats();
        this.updateDeckValidity();
    },
    
    updateDeckStats() {
        const cards = this.currentDeck.map(id => ALL_CARDS.find(c => c.id === id)).filter(Boolean);
        const total = cards.length || 1;
        
        const klCounts = [0, 0, 0, 0, 0, 0, 0];
        cards.forEach(c => {
            const cost = Math.min(c.cost || 0, 6);
            klCounts[cost]++;
        });
        const maxKL = Math.max(...klCounts, 1);
        
        document.querySelectorAll('.ec-kl-bar').forEach((bar, i) => {
            const fill = bar.querySelector('.bar-fill');
            if (fill) {
                const height = (klCounts[i] / maxKL) * 60;
                fill.style.height = height + 'px';
            }
        });
        
        const types = { Avatar: 0, Spell: 0, Domain: 0, Relic: 0 };
        cards.forEach(c => { if (types[c.type] !== undefined) types[c.type]++; });
        
        Object.entries(types).forEach(([type, count]) => {
            const bar = document.getElementById(`type-${type.toLowerCase()}-bar`);
            const countEl = document.getElementById(`type-${type.toLowerCase()}-count`);
            if (bar) bar.style.width = (count / total * 100) + '%';
            if (countEl) countEl.textContent = count;
        });
        
        const aspects = { Glow: 0, Void: 0, Gray: 0 };
        cards.forEach(c => {
            (c.aspects || []).forEach(a => { if (aspects[a] !== undefined) aspects[a]++; });
        });
        
        Object.entries(aspects).forEach(([aspect, count]) => {
            const countEl = document.getElementById(`aspect-${aspect.toLowerCase()}-count`);
            if (countEl) countEl.textContent = count;
        });
    },
    
    updateDeckValidity() {
        const validity = document.getElementById('deck-validity');
        if (!validity) return;
        
        const count = this.currentDeck.length;
        if (count === 60) {
            validity.classList.remove('invalid');
            validity.classList.add('valid');
            validity.innerHTML = '<span class="validity-icon">‚úì</span><span class="validity-text">Ready to battle!</span>';
        } else {
            validity.classList.add('invalid');
            validity.classList.remove('valid');
            validity.innerHTML = `<span class="validity-icon">‚ö†</span><span class="validity-text">${60 - count} more cards needed</span>`;
        }
    },
    
    addCard(cardId) {
        if (this.currentDeck.length >= 60) {
            Game.showPrompt('Deck is full (60 cards max)');
            return;
        }
        
        const count = this.currentDeck.filter(id => id === cardId).length;
        if (count >= 3) {
            Game.showPrompt('Maximum 3 copies per card');
            return;
        }
        
        this.currentDeck.push(cardId);
        this.renderCurrentDeck();
        
        setTimeout(() => {
            const entry = document.querySelector(`.deck-card-entry[data-card-id="${cardId}"]`);
            if (entry) {
                entry.classList.add('ec-flash-add');
                setTimeout(() => entry.classList.remove('ec-flash-add'), 400);
            }
        }, 50);
    },
    
    removeCard(cardId) {
        const entry = document.querySelector(`.deck-card-entry[data-card-id="${cardId}"]`);
        if (entry) {
            entry.classList.add('ec-flash-remove');
            setTimeout(() => {
                const idx = this.currentDeck.indexOf(cardId);
                if (idx > -1) {
                    this.currentDeck.splice(idx, 1);
                    this.renderCurrentDeck();
                }
            }, 300);
        } else {
            const idx = this.currentDeck.indexOf(cardId);
            if (idx > -1) {
                this.currentDeck.splice(idx, 1);
                this.renderCurrentDeck();
            }
        }
    },
    
    clearDeck() {
        this.currentDeck = [];
        this.renderCurrentDeck();
    },
    
    saveDeck() {
        const name = document.getElementById('deck-name').value || 'New Deck';
        if (this.currentDeck.length !== 60) {
            Game.showPrompt('Deck must be exactly 60 cards');
            return;
        }
        
        const deck = { name, cards: [...this.currentDeck], created: Date.now() };
        this.savedDecks.push(deck);
        localStorage.setItem('ec-saved-decks', JSON.stringify(this.savedDecks));
        this.renderSavedDecks();
        Game.showPrompt(`Deck "${name}" saved!`);
    },
    
    renderSavedDecks() {
        const container = document.getElementById('saved-decks-list');
        if (!container) return;
        
        if (this.savedDecks.length === 0) {
            container.innerHTML = '<p style="color: rgba(255,255,255,0.5); font-size: 0.85em; text-align: center; padding: 20px;">No saved decks yet</p>';
            return;
        }
        
        container.innerHTML = this.savedDecks.map((deck, i) => `
            <div class="ec-saved-deck-card">
                <span class="deck-icon">üìö</span>
                <span class="deck-name">${deck.name}</span>
                <span class="deck-count">${deck.cards.length}/60</span>
                <div class="deck-actions">
                    <button class="deck-action-btn load" onclick="DeckBuilder.loadDeck(${i})">Load</button>
                    <button class="deck-action-btn delete" onclick="DeckBuilder.deleteDeck(${i})">‚úï</button>
                </div>
            </div>
        `).join('');
    },
    
    loadDeck(index) {
        if (index < 0 || index >= this.savedDecks.length) return;
        this.currentDeck = [...this.savedDecks[index].cards];
        document.getElementById('deck-name').value = this.savedDecks[index].name;
        this.renderCurrentDeck();
        Game.showPrompt(`Loaded "${this.savedDecks[index].name}"`);
    },
    
    deleteDeck(index) {
        if (index < 0 || index >= this.savedDecks.length) return;
        const name = this.savedDecks[index].name;
        this.savedDecks.splice(index, 1);
        localStorage.setItem('ec-saved-decks', JSON.stringify(this.savedDecks));
        this.renderSavedDecks();
        Game.showPrompt(`Deleted "${name}"`);
    },
    
    playWithDeck() {
        if (this.currentDeck.length !== 60) {
            Game.showPrompt('Deck must be exactly 60 cards');
            return;
        }
        
        document.getElementById('deckbuilder-overlay').classList.add('hidden');
        Game.state.matchMode = 'casual';
        Game.state.isAIMatch = true;
        Game.state.aiDifficulty = 'medium';
        Game.state.customDeck = [...this.currentDeck];
        AIManager.difficulty = 'medium';
        
        Game.showDeitySelection(0);
    },
    
    dragStart(event, cardId) {
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('cardId', cardId);
    },
    
    showCardDetail(cardId) {
        const card = ALL_CARDS.find(c => c.id === cardId);
        if (!card) return;
        
        this.currentDetailCardId = cardId;
        
        document.getElementById('card-detail-name').textContent = card.name;
        document.getElementById('card-detail-img').src = card.image;
        document.getElementById('card-detail-type').textContent = card.type;
        document.getElementById('card-detail-cost').textContent = `${card.cost} KL`;
        document.getElementById('card-detail-aspects').textContent = card.aspects ? `${card.aspects.join(' / ')}` : '';
        
        let statsHtml = '';
        if (card.attack !== undefined || card.health !== undefined) {
            statsHtml = `<div class="stat"><span class="stat-label">Power:</span> ${card.attack || 0}</div>`;
            statsHtml += `<div class="stat"><span class="stat-label">Health:</span> ${card.health || 0}</div>`;
        }
        document.getElementById('card-detail-stats').innerHTML = statsHtml;
        document.getElementById('card-detail-effect').textContent = card.effect || card.keywords?.join(', ') || 'No effect';
        
        document.getElementById('card-detail-modal').classList.remove('hidden');
    },
    
    closeCardDetail() {
        document.getElementById('card-detail-modal').classList.add('hidden');
        this.currentDetailCardId = null;
    },
    
    quickAddCard() {
        if (this.currentDetailCardId) {
            const addBtn = document.querySelector('.card-detail-btn');
            addBtn.style.display = 'block';
            this.addCard(this.currentDetailCardId);
            this.closeCardDetail();
        }
    }
};

const Collection = {
    currentTab: 'cards',
    
    show() {
        document.getElementById('collection-overlay').classList.remove('hidden');
        this.showTab('cards');
    },
    
    showTab(tab) {
        this.currentTab = tab;
        document.querySelectorAll('.coll-tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.coll-tab[onclick*="${tab}"]`)?.classList.add('active');
        
        const container = document.getElementById('collection-grid');
        
        switch(tab) {
            case 'cards':
                this.renderCards(container);
                break;
            case 'deities':
                this.renderDeities(container);
                break;
            case 'cosmetics':
                this.renderCosmetics(container);
                break;
        }
    },
    
    renderCards(container) {
        const cards = ALL_CARDS.filter(c => c.type !== 'Deity');
        const types = ['Avatar', 'Spell', 'Domain', 'Relic'];
        
        let html = '';
        types.forEach(type => {
            const typeCards = cards.filter(c => c.type === type);
            if (typeCards.length > 0) {
                html += `<div class="collection-section">
                    <h3 class="section-title">${type}s (${typeCards.length})</h3>
                    <div class="collection-cards">
                        ${typeCards.map(c => `
                            <div class="coll-card" draggable="true"
                                 ondragstart="Collection.dragStart(event, '${c.id}')"
                                 ondblclick="Collection.showCardDetail('${c.id}')">
                                <img src="${c.image}" alt="${c.name}">
                                <div class="coll-card-name">${c.name}</div>
                                <div class="coll-card-hint">Double-click to view</div>
                            </div>
                        `).join('')}
                    </div>
                </div>`;
            }
        });
        container.innerHTML = html;
    },
    
    dragStart(event, cardId) {
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('cardId', cardId);
    },
    
    showCardDetail(cardId) {
        const card = ALL_CARDS.find(c => c.id === cardId);
        if (!card) return;
        
        this.currentDetailCardId = cardId;
        
        document.getElementById('card-detail-name').textContent = card.name;
        document.getElementById('card-detail-img').src = card.image;
        document.getElementById('card-detail-type').textContent = card.type;
        document.getElementById('card-detail-cost').textContent = `${card.cost} KL`;
        document.getElementById('card-detail-aspects').textContent = card.aspects ? `${card.aspects.join(' / ')}` : '';
        
        let statsHtml = '';
        if (card.attack !== undefined || card.health !== undefined) {
            statsHtml = `<div class="stat"><span class="stat-label">Power:</span> ${card.attack || 0}</div>`;
            statsHtml += `<div class="stat"><span class="stat-label">Health:</span> ${card.health || 0}</div>`;
        }
        document.getElementById('card-detail-stats').innerHTML = statsHtml;
        document.getElementById('card-detail-effect').textContent = card.effect || card.keywords?.join(', ') || 'No effect';
        
        // Hide the add button in collection view
        const addBtn = document.querySelector('.card-detail-btn');
        addBtn.style.display = 'none';
        
        document.getElementById('card-detail-modal').classList.remove('hidden');
    },
    
    closeCardDetail() {
        document.getElementById('card-detail-modal').classList.add('hidden');
        this.currentDetailCardId = null;
    },
    
    renderDeities(container) {
        const deities = getDeities();
        container.innerHTML = deities.map(d => `
            <div class="coll-card deity" onclick="Game.showCardZoom('${d.id}')">
                <img src="${d.image}" alt="${d.name}">
                <div class="coll-card-name">${d.name}</div>
                <div class="coll-card-stats">${d.health} Essence | ${d.startingKL || 3} KL</div>
            </div>
        `).join('');
    },
    
    renderCosmetics(container) {
        container.innerHTML = `
            <div class="cosmetics-section">
                <h3>Card Backs</h3>
                <div class="cosmetics-grid">
                    ${CosmeticsManager.inventory.cardBack.map(c => 
                        `<div class="cosmetic-item ${c.owned ? 'owned' : ''}">${c.name}</div>`
                    ).join('')}
                </div>
            </div>
        `;
    }
};

const AccessibilitySettings = {
    settings: JSON.parse(localStorage.getItem('ec-accessibility') || '{}'),
    
    defaults: {
        textSize: 'medium',
        colorblindMode: 'off',
        lowFxMode: false,
        highContrast: false,
        reduceMotion: false
    },
    
    init() {
        this.settings = { ...this.defaults, ...this.settings };
        this.apply();
    },
    
    get(key) {
        return this.settings[key] ?? this.defaults[key];
    },
    
    set(key, value) {
        this.settings[key] = value;
        this.save();
        this.apply();
    },
    
    save() {
        localStorage.setItem('ec-accessibility', JSON.stringify(this.settings));
    },
    
    apply() {
        const root = document.documentElement;
        const body = document.body;
        
        body.classList.remove('text-small', 'text-medium', 'text-large');
        body.classList.add(`text-${this.get('textSize')}`);
        
        body.classList.remove('colorblind-off', 'colorblind-deuteranopia', 'colorblind-protanopia', 'colorblind-tritanopia');
        body.classList.add(`colorblind-${this.get('colorblindMode')}`);
        
        body.classList.toggle('low-fx', this.get('lowFxMode'));
        body.classList.toggle('high-contrast', this.get('highContrast'));
        body.classList.toggle('reduce-motion', this.get('reduceMotion'));
    },
    
    getColorblindPalette() {
        const palettes = {
            off: { glow: '#00ffcc', void: '#9333ea', gray: '#6b7280', damage: '#ff4444' },
            deuteranopia: { glow: '#0077bb', void: '#ee7733', gray: '#bbbbbb', damage: '#cc3311' },
            protanopia: { glow: '#33bbee', void: '#ee3377', gray: '#bbbbbb', damage: '#cc3311' },
            tritanopia: { glow: '#009988', void: '#ee3377', gray: '#bbbbbb', damage: '#cc3311' }
        };
        return palettes[this.get('colorblindMode')] || palettes.off;
    }
};

const SandboxMode = {
    active: false,
    savedStates: JSON.parse(localStorage.getItem('ec-sandbox-states') || '[]'),
    
    enter() {
        this.active = true;
        Game.state.isSandboxMode = true;
        Game.log('SANDBOX MODE: Board editing enabled', 'phase');
    },
    
    exit() {
        this.active = false;
        Game.state.isSandboxMode = false;
    },
    
    setEssence(playerIndex, value) {
        if (!this.active) return;
        const val = Math.max(0, Math.min(99, parseInt(value) || 0));
        Game.state.players[playerIndex].essence = val;
        Game.render();
        Game.log(`Sandbox: P${playerIndex + 1} Essence set to ${val}`, 'action');
    },
    
    setKL(playerIndex, current, max) {
        if (!this.active) return;
        const c = Math.max(0, Math.min(20, parseInt(current) || 0));
        const m = Math.max(1, Math.min(20, parseInt(max) || 3));
        Game.state.players[playerIndex].klCurrent = Math.min(c, m);
        Game.state.players[playerIndex].klMax = m;
        Game.render();
        Game.log(`Sandbox: P${playerIndex + 1} KL set to ${c}/${m}`, 'action');
    },
    
    addCardToZone(playerIndex, cardId, zone) {
        if (!this.active) return;
        const card = ALL_CARDS.find(c => c.id === cardId);
        if (!card) return;
        
        const instance = Game.createCardInstance(card);
        const p = Game.state.players[playerIndex];
        
        switch(zone) {
            case 'hand': p.hand.push(instance); break;
            case 'avatar': p.avatarRow.push(instance); break;
            case 'domain': p.domainRow.push(instance); break;
            case 'relic': p.relicRow.push(instance); break;
            case 'spell': p.spellRow.push(instance); break;
            case 'graveyard': p.graveyard.push(instance); break;
            case 'deck': p.deck.push(instance); break;
        }
        
        Game.render();
        Game.log(`Sandbox: Added ${card.name} to P${playerIndex + 1} ${zone}`, 'action');
    },
    
    removeCardFromZone(playerIndex, instanceId, zone) {
        if (!this.active) return;
        const p = Game.state.players[playerIndex];
        let arr;
        
        switch(zone) {
            case 'hand': arr = p.hand; break;
            case 'avatar': arr = p.avatarRow; break;
            case 'domain': arr = p.domainRow; break;
            case 'relic': arr = p.relicRow; break;
            case 'spell': arr = p.spellRow; break;
            case 'graveyard': arr = p.graveyard; break;
            case 'deck': arr = p.deck; break;
            default: return;
        }
        
        const idx = arr.findIndex(c => c.instanceId === instanceId);
        if (idx >= 0) {
            const removed = arr.splice(idx, 1)[0];
            Game.render();
            Game.log(`Sandbox: Removed ${removed.name} from P${playerIndex + 1} ${zone}`, 'action');
        }
    },
    
    moveCard(playerIndex, instanceId, fromZone, toZone) {
        if (!this.active) return;
        const p = Game.state.players[playerIndex];
        
        const zones = {
            hand: p.hand, avatar: p.avatarRow, domain: p.domainRow,
            relic: p.relicRow, spell: p.spellRow, graveyard: p.graveyard, deck: p.deck
        };
        
        const from = zones[fromZone];
        const to = zones[toZone];
        if (!from || !to) return;
        
        const idx = from.findIndex(c => c.instanceId === instanceId);
        if (idx >= 0) {
            const card = from.splice(idx, 1)[0];
            to.push(card);
            Game.render();
            Game.log(`Sandbox: Moved ${card.name} from ${fromZone} to ${toZone}`, 'action');
        }
    },
    
    setCardStats(instanceId, attack, health) {
        if (!this.active) return;
        for (let p of Game.state.players) {
            for (let zone of [p.avatarRow, p.hand]) {
                const card = zone.find(c => c.instanceId === instanceId);
                if (card) {
                    if (attack !== undefined) card.attack = parseInt(attack) || 0;
                    if (health !== undefined) {
                        card.health = parseInt(health) || 1;
                        card.healthCurrent = card.health;
                    }
                    Game.render();
                    return;
                }
            }
        }
    },
    
    saveState(name) {
        const state = {
            name: name || `State ${Date.now()}`,
            timestamp: Date.now(),
            players: Game.state.players.map(p => ({
                essence: p.essence,
                klCurrent: p.klCurrent,
                klMax: p.klMax,
                overflow: p.overflow,
                godCodeCharges: p.godCodeCharges,
                godCodeUsed: p.godCodeUsed,
                deity: p.deity ? { id: p.deity.id, name: p.deity.name } : null,
                hand: p.hand.map(c => c.id),
                deck: p.deck.map(c => c.id),
                avatarRow: p.avatarRow.map(c => ({ id: c.id, attack: c.attack, health: c.healthCurrent, tapped: c.tapped })),
                domainRow: p.domainRow.map(c => c.id),
                relicRow: p.relicRow.map(c => c.id),
                spellRow: p.spellRow.map(c => c.id),
                graveyard: p.graveyard.map(c => c.id),
                banished: p.banished.map(c => c.id)
            })),
            turnNumber: Game.state.turnNumber,
            currentPlayer: Game.state.currentPlayer,
            currentPhase: Game.state.currentPhase
        };
        
        this.savedStates.unshift(state);
        if (this.savedStates.length > 10) this.savedStates.pop();
        localStorage.setItem('ec-sandbox-states', JSON.stringify(this.savedStates));
        Game.log(`Sandbox: State saved as "${state.name}"`, 'phase');
        return state;
    },
    
    loadState(index) {
        const state = this.savedStates[index];
        if (!state) return false;
        
        Game.state.turnNumber = state.turnNumber;
        Game.state.currentPlayer = state.currentPlayer;
        Game.state.currentPhase = state.currentPhase;
        
        for (let i = 0; i < 2; i++) {
            const ps = state.players[i];
            const p = Game.state.players[i];
            
            p.essence = ps.essence;
            p.klCurrent = ps.klCurrent;
            p.klMax = ps.klMax;
            p.overflow = ps.overflow;
            p.godCodeCharges = ps.godCodeCharges ?? 1;
            p.godCodeUsed = ps.godCodeUsed ?? false;
            p.shards = ps.shards ?? 0;
            p.shardSurgeUsedThisTurn = ps.shardSurgeUsedThisTurn ?? false;
            
            if (ps.deity) {
                const deity = ALL_CARDS.find(c => c.id === ps.deity.id || c.id === ps.deity);
                if (deity) p.deity = Game.createCardInstance(deity);
            }
            
            const loadCards = (ids) => (ids || []).map(id => {
                const card = ALL_CARDS.find(c => c.id === id);
                return card ? Game.createCardInstance(card) : null;
            }).filter(Boolean);
            
            p.hand = loadCards(ps.hand);
            p.deck = loadCards(ps.deck);
            p.domainRow = loadCards(ps.domainRow);
            p.relicRow = loadCards(ps.relicRow);
            p.spellRow = loadCards(ps.spellRow);
            p.graveyard = loadCards(ps.graveyard);
            p.banished = loadCards(ps.banished);
            
            p.avatarRow = (ps.avatarRow || []).map(data => {
                const card = ALL_CARDS.find(c => c.id === data.id);
                if (!card) return null;
                const inst = Game.createCardInstance(card);
                inst.attack = data.attack;
                inst.healthCurrent = data.health;
                inst.tapped = data.tapped;
                return inst;
            }).filter(Boolean);
        }
        
        Game.render();
        Game.log(`Sandbox: Loaded state "${state.name}"`, 'phase');
        return true;
    },
    
    clearBoard(playerIndex) {
        if (!this.active) return;
        const p = Game.state.players[playerIndex];
        p.hand = [];
        p.deck = [];
        p.avatarRow = [];
        p.domainRow = [];
        p.relicRow = [];
        p.spellRow = [];
        p.graveyard = [];
        p.banished = [];
        Game.render();
        Game.log(`Sandbox: Cleared P${playerIndex + 1} board`, 'action');
    },
    
    startGame() {
        this.active = false;
        Game.state.isSandboxMode = true;
        Game.setPhase('main');
        Game.log('Sandbox: Game started - play freely!', 'phase');
    }
};

const CustomLobby = {
    lobbies: [],
    currentLobby: null,
    
    presets: {
        standard: { name: 'Standard', essence: 23, kl: 3, aspects: ['Glow', 'Void', 'Gray'], types: null, victory: 'essence' },
        highLife: { name: 'High Life', essence: 40, kl: 3, aspects: null, types: null, victory: 'essence' },
        turbo: { name: 'Turbo', essence: 15, kl: 6, aspects: null, types: null, victory: 'essence' },
        avatarsOnly: { name: 'Avatars Only', essence: 23, kl: 3, aspects: null, types: ['Avatar'], victory: 'essence' },
        spellsUnleashed: { name: 'Spells Unleashed', essence: 23, kl: 5, aspects: null, types: ['Spell', 'Avatar'], victory: 'essence' },
        voidWar: { name: 'Void War', essence: 23, kl: 3, aspects: ['Void'], types: null, victory: 'essence' },
        glowCrusade: { name: 'Glow Crusade', essence: 23, kl: 3, aspects: ['Glow'], types: null, victory: 'essence' },
        sudden: { name: 'Sudden Death', essence: 10, kl: 5, aspects: null, types: null, victory: 'essence' },
        domination: { name: 'Domination', essence: 30, kl: 3, aspects: null, types: null, victory: 'avatars', avatarWinCount: 5 }
    },
    
    create(hostName, settings = {}) {
        const lobby = {
            id: `lobby-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`,
            host: hostName,
            created: Date.now(),
            status: 'waiting',
            players: [hostName],
            maxPlayers: 2,
            settings: {
                name: settings.name || 'Custom Match',
                startingEssence: settings.essence ?? 23,
                startingKL: settings.kl ?? 3,
                maxKL: settings.maxKL ?? 13,
                allowedAspects: settings.aspects || null,
                allowedTypes: settings.types || null,
                bannedCards: settings.bannedCards || [],
                victoryCondition: settings.victory || 'essence',
                avatarWinCount: settings.avatarWinCount || 5,
                customRules: settings.customRules || [],
                preset: settings.preset || null
            }
        };
        
        this.lobbies.push(lobby);
        this.currentLobby = lobby;
        return lobby;
    },
    
    join(lobbyId, playerName) {
        const lobby = this.lobbies.find(l => l.id === lobbyId);
        if (!lobby) return { success: false, error: 'Lobby not found' };
        if (lobby.status !== 'waiting') return { success: false, error: 'Lobby is not accepting players' };
        if (lobby.players.length >= lobby.maxPlayers) return { success: false, error: 'Lobby is full' };
        if (lobby.players.includes(playerName)) return { success: false, error: 'Already in lobby' };
        
        lobby.players.push(playerName);
        this.currentLobby = lobby;
        return { success: true, lobby };
    },
    
    leave(lobbyId, playerName) {
        const lobby = this.lobbies.find(l => l.id === lobbyId);
        if (!lobby) return;
        
        lobby.players = lobby.players.filter(p => p !== playerName);
        if (lobby.players.length === 0 || lobby.host === playerName) {
            this.lobbies = this.lobbies.filter(l => l.id !== lobbyId);
        }
        
        if (this.currentLobby?.id === lobbyId) {
            this.currentLobby = null;
        }
    },
    
    updateSettings(lobbyId, newSettings) {
        const lobby = this.lobbies.find(l => l.id === lobbyId);
        if (!lobby) return false;
        
        Object.assign(lobby.settings, newSettings);
        return true;
    },
    
    applyPreset(lobbyId, presetName) {
        const preset = this.presets[presetName];
        if (!preset) return false;
        
        return this.updateSettings(lobbyId, {
            name: preset.name,
            startingEssence: preset.essence,
            startingKL: preset.kl,
            allowedAspects: preset.aspects,
            allowedTypes: preset.types,
            victoryCondition: preset.victory,
            avatarWinCount: preset.avatarWinCount,
            preset: presetName
        });
    },
    
    start(lobbyId) {
        const lobby = this.lobbies.find(l => l.id === lobbyId);
        if (!lobby || lobby.players.length < 2) return false;
        
        lobby.status = 'started';
        return lobby;
    },
    
    getOpenLobbies() {
        return this.lobbies.filter(l => l.status === 'waiting' && l.players.length < l.maxPlayers);
    },
    
    isCardAllowed(card, settings) {
        if (settings.bannedCards?.includes(card.id)) return false;
        if (settings.allowedAspects && !settings.allowedAspects.includes(card.aspect)) return false;
        if (settings.allowedTypes && !settings.allowedTypes.includes(card.type)) return false;
        return true;
    },
    
    checkVictory(settings) {
        if (settings.victoryCondition === 'avatars') {
            const p1Destroyed = Game.state.players[1].graveyard.filter(c => c.type === 'Avatar').length;
            const p2Destroyed = Game.state.players[0].graveyard.filter(c => c.type === 'Avatar').length;
            
            if (p1Destroyed >= settings.avatarWinCount) return 0;
            if (p2Destroyed >= settings.avatarWinCount) return 1;
        }
        return null;
    }
};

const MatchRecorder = {
    currentMatch: null,
    savedMatches: JSON.parse(localStorage.getItem('ec-match-replays') || '[]'),
    liveMatches: [],
    
    startRecording(matchId, player1Deity, player2Deity, matchMode) {
        this.currentMatch = {
            matchId: matchId,
            timestamp: Date.now(),
            matchMode: matchMode,
            player1Deity: player1Deity?.name || 'Unknown',
            player2Deity: player2Deity?.name || 'Unknown',
            winner: null,
            turnCount: 0,
            actions: [],
            stateSnapshots: [],
            cardsPlayed: [],
            deckCards: { p1: [], p2: [] }
        };
        this.takeSnapshot('MATCH_START');
    },
    
    recordAction(actionType, data, playerIndex = 0) {
        if (!this.currentMatch) return;
        const action = {
            seq: this.currentMatch.actions.length,
            timestamp: Date.now(),
            turn: Game.state?.turnNumber || 1,
            phase: Game.state?.currentPhase || 'main',
            player: playerIndex,
            type: actionType,
            data: JSON.parse(JSON.stringify(data))
        };
        this.currentMatch.actions.push(action);
        
        if (['CARD_PLAYED', 'ATTACK', 'PHASE_CHANGE', 'TURN_END'].includes(actionType)) {
            this.takeSnapshot(actionType);
        }
    },
    
    takeSnapshot(trigger) {
        if (!this.currentMatch || !Game.state) return;
        const snapshot = {
            trigger: trigger,
            seq: this.currentMatch.stateSnapshots.length,
            timestamp: Date.now(),
            turnNumber: Game.state.turnNumber,
            currentPhase: Game.state.currentPhase,
            currentPlayer: Game.state.currentPlayer,
            players: Game.state.players.map(p => ({
                essence: p.essence,
                klCurrent: p.klCurrent,
                klMax: p.klMax,
                overflow: p.overflow,
                godCodeCharges: p.godCodeCharges,
                handCount: p.hand.length,
                deckCount: p.deck.length,
                graveyardCount: p.graveyard.length,
                avatarRow: p.avatarRow.map(c => ({ id: c.id, name: c.name, attack: c.attack, health: c.health, tapped: c.tapped })),
                domainRow: p.domainRow.map(c => ({ id: c.id, name: c.name }))
            }))
        };
        this.currentMatch.stateSnapshots.push(snapshot);
    },
    
    recordCardPlayed(card, playerIndex) {
        if (!this.currentMatch) return;
        this.currentMatch.cardsPlayed.push({
            cardId: card.id,
            cardName: card.name,
            cardType: card.type,
            aspect: card.aspect,
            cost: card.cost,
            player: playerIndex,
            turn: Game.state?.turnNumber || 1
        });
    },
    
    recordDeckContents(playerIndex, deck) {
        if (!this.currentMatch) return;
        const deckKey = playerIndex === 0 ? 'p1' : 'p2';
        this.currentMatch.deckCards[deckKey] = deck.map(c => c.id);
    },
    
    endRecording(winnerIndex) {
        if (!this.currentMatch) return null;
        this.currentMatch.winner = winnerIndex;
        this.currentMatch.turnCount = Game.state?.turnNumber || 1;
        this.currentMatch.duration = Date.now() - this.currentMatch.timestamp;
        this.takeSnapshot('MATCH_END');
        
        const completedMatch = { ...this.currentMatch };
        this.savedMatches.unshift(completedMatch);
        if (this.savedMatches.length > 20) this.savedMatches.pop();
        localStorage.setItem('ec-match-replays', JSON.stringify(this.savedMatches));
        
        Analytics.recordMatchResult(completedMatch);
        
        this.currentMatch = null;
        return completedMatch;
    },
    
    getReplay(matchId) {
        return this.savedMatches.find(m => m.matchId === matchId);
    },
    
    getAllReplays() {
        return this.savedMatches;
    },
    
    registerLiveMatch(matchId, matchData) {
        this.liveMatches.push({ matchId, ...matchData, lastUpdate: Date.now() });
    },
    
    getLiveMatches() {
        return this.liveMatches.filter(m => Date.now() - m.lastUpdate < 300000);
    }
};

const Analytics = {
    data: JSON.parse(localStorage.getItem('ec-analytics') || '{"cardStats":{},"deckArchetypes":{},"matchHistory":[]}'),
    
    recordMatchResult(match) {
        const winnerCards = match.cardsPlayed.filter(c => c.player === match.winner);
        const loserCards = match.cardsPlayed.filter(c => c.player !== match.winner);
        
        winnerCards.forEach(card => {
            if (!this.data.cardStats[card.cardId]) {
                this.data.cardStats[card.cardId] = { name: card.cardName, type: card.cardType, aspect: card.aspect, played: 0, wins: 0, losses: 0 };
            }
            this.data.cardStats[card.cardId].played++;
            this.data.cardStats[card.cardId].wins++;
        });
        
        loserCards.forEach(card => {
            if (!this.data.cardStats[card.cardId]) {
                this.data.cardStats[card.cardId] = { name: card.cardName, type: card.cardType, aspect: card.aspect, played: 0, wins: 0, losses: 0 };
            }
            this.data.cardStats[card.cardId].played++;
            this.data.cardStats[card.cardId].losses++;
        });
        
        const archetype = this.detectArchetype(match.cardsPlayed.filter(c => c.player === match.winner));
        if (archetype) {
            if (!this.data.deckArchetypes[archetype]) {
                this.data.deckArchetypes[archetype] = { wins: 0, losses: 0, total: 0 };
            }
            this.data.deckArchetypes[archetype].wins++;
            this.data.deckArchetypes[archetype].total++;
        }
        
        this.data.matchHistory.push({
            matchId: match.matchId,
            timestamp: match.timestamp,
            winner: match.winner,
            player1Deity: match.player1Deity,
            player2Deity: match.player2Deity,
            turnCount: match.turnCount,
            matchMode: match.matchMode
        });
        
        if (this.data.matchHistory.length > 100) {
            this.data.matchHistory = this.data.matchHistory.slice(-100);
        }
        
        this.save();
    },
    
    detectArchetype(cardsPlayed) {
        const aspects = { Glow: 0, Void: 0, Gray: 0 };
        const types = { Avatar: 0, Spell: 0, Domain: 0 };
        
        cardsPlayed.forEach(card => {
            if (card.aspect) aspects[card.aspect]++;
            if (card.cardType) types[card.cardType]++;
        });
        
        const dominantAspect = Object.entries(aspects).sort((a, b) => b[1] - a[1])[0];
        const dominantType = Object.entries(types).sort((a, b) => b[1] - a[1])[0];
        
        if (dominantAspect[1] >= 3) {
            if (dominantType[0] === 'Spell' && types.Spell >= 3) return `${dominantAspect[0]} Control`;
            if (dominantType[0] === 'Avatar' && types.Avatar >= 4) return `${dominantAspect[0]} Aggro`;
            return `${dominantAspect[0]} Midrange`;
        }
        return 'Mixed';
    },
    
    getCardWinrate(cardId) {
        const stats = this.data.cardStats[cardId];
        if (!stats || stats.played === 0) return null;
        return {
            ...stats,
            winrate: Math.round((stats.wins / stats.played) * 100)
        };
    },
    
    getTopCards(limit = 10) {
        return Object.entries(this.data.cardStats)
            .map(([id, stats]) => ({ id, ...stats, winrate: stats.played > 0 ? (stats.wins / stats.played) * 100 : 0 }))
            .filter(c => c.played >= 3)
            .sort((a, b) => b.winrate - a.winrate)
            .slice(0, limit);
    },
    
    getArchetypeStats() {
        return Object.entries(this.data.deckArchetypes)
            .map(([name, stats]) => ({ name, ...stats, winrate: stats.total > 0 ? Math.round((stats.wins / stats.total) * 100) : 0 }))
            .sort((a, b) => b.total - a.total);
    },
    
    save() {
        localStorage.setItem('ec-analytics', JSON.stringify(this.data));
    },
    
    export() {
        return JSON.stringify(this.data, null, 2);
    }
};

const ReplayViewer = {
    currentReplay: null,
    currentActionIndex: 0,
    currentSnapshotIndex: 0,
    isPlaying: false,
    playbackSpeed: 1000,
    playbackInterval: null,
    
    loadReplay(matchId) {
        const replay = MatchRecorder.getReplay(matchId);
        if (!replay) {
            alert('Replay not found');
            return false;
        }
        
        this.currentReplay = replay;
        this.currentActionIndex = 0;
        this.currentSnapshotIndex = 0;
        this.isPlaying = false;
        
        Game.state.isReplayMode = true;
        Game.state.isSpectatorMode = false;
        
        this.renderReplayUI();
        this.applySnapshot(0);
        return true;
    },
    
    renderReplayUI() {
        document.getElementById('replay-overlay').classList.remove('hidden');
        document.getElementById('game-board').classList.add('replay-mode');
        
        const info = document.getElementById('replay-info');
        info.innerHTML = `
            <span class="replay-title">REPLAY: ${this.currentReplay.player1Deity} vs ${this.currentReplay.player2Deity}</span>
            <span class="replay-date">${new Date(this.currentReplay.timestamp).toLocaleDateString()}</span>
        `;
        
        this.updateControls();
    },
    
    updateControls() {
        const progress = document.getElementById('replay-progress');
        const turnDisplay = document.getElementById('replay-turn');
        const actionDisplay = document.getElementById('replay-action');
        
        if (!this.currentReplay) return;
        
        const snapshot = this.currentReplay.stateSnapshots[this.currentSnapshotIndex];
        const maxSnapshots = this.currentReplay.stateSnapshots.length - 1;
        
        progress.value = this.currentSnapshotIndex;
        progress.max = maxSnapshots;
        
        turnDisplay.textContent = `Turn ${snapshot?.turnNumber || 1} - ${snapshot?.currentPhase || 'main'}`;
        actionDisplay.textContent = `Snapshot ${this.currentSnapshotIndex + 1} / ${this.currentReplay.stateSnapshots.length}`;
        
        document.getElementById('btn-replay-play').textContent = this.isPlaying ? '‚è∏' : '‚ñ∂';
    },
    
    applySnapshot(index) {
        if (!this.currentReplay || index < 0 || index >= this.currentReplay.stateSnapshots.length) return;
        
        this.currentSnapshotIndex = index;
        const snapshot = this.currentReplay.stateSnapshots[index];
        
        snapshot.players.forEach((pData, pIndex) => {
            const prefix = pIndex === 0 ? 'p1' : 'p2';
            document.getElementById(`${prefix}-essence`).textContent = pData.essence;
            document.getElementById(`${prefix}-kl`).textContent = `${pData.klCurrent}/${pData.klMax}`;
            document.getElementById(`${prefix}-deck-count`).textContent = pData.deckCount;
            document.getElementById(`${prefix}-grave-count`).textContent = pData.graveyardCount;
            
            const avatarRow = document.getElementById(`${prefix}-avatar-row`);
            avatarRow.innerHTML = '';
            pData.avatarRow.forEach(card => {
                const el = document.createElement('div');
                el.className = `card mini-card ${card.tapped ? 'tapped' : ''}`;
                el.innerHTML = `<div class="card-name">${card.name}</div><div class="card-stats">${card.attack}/${card.health}</div>`;
                avatarRow.appendChild(el);
            });
        });
        
        this.updateControls();
    },
    
    play() {
        if (this.isPlaying) {
            this.pause();
            return;
        }
        
        this.isPlaying = true;
        this.updateControls();
        
        this.playbackInterval = setInterval(() => {
            if (this.currentSnapshotIndex < this.currentReplay.stateSnapshots.length - 1) {
                this.stepForward();
            } else {
                this.pause();
            }
        }, this.playbackSpeed);
    },
    
    pause() {
        this.isPlaying = false;
        if (this.playbackInterval) {
            clearInterval(this.playbackInterval);
            this.playbackInterval = null;
        }
        this.updateControls();
    },
    
    stepForward() {
        if (this.currentSnapshotIndex < this.currentReplay.stateSnapshots.length - 1) {
            this.applySnapshot(this.currentSnapshotIndex + 1);
        }
    },
    
    stepBackward() {
        if (this.currentSnapshotIndex > 0) {
            this.applySnapshot(this.currentSnapshotIndex - 1);
        }
    },
    
    jumpToTurn(turnNumber) {
        const snapshot = this.currentReplay.stateSnapshots.find(s => s.turnNumber === turnNumber);
        if (snapshot) {
            this.applySnapshot(this.currentReplay.stateSnapshots.indexOf(snapshot));
        }
    },
    
    seekTo(snapshotIndex) {
        this.applySnapshot(parseInt(snapshotIndex));
    },
    
    close() {
        this.pause();
        this.currentReplay = null;
        Game.state.isReplayMode = false;
        document.getElementById('replay-overlay').classList.add('hidden');
        document.getElementById('game-board').classList.remove('replay-mode');
    }
};

const SpectatorMode = {
    isSpectating: false,
    currentMatchId: null,
    updateInterval: null,
    spectatorDelay: 5000,
    
    startSpectating(matchId) {
        const liveMatch = MatchRecorder.liveMatches.find(m => m.matchId === matchId);
        if (!liveMatch) {
            alert('Match not found or already ended');
            return false;
        }
        
        this.isSpectating = true;
        this.currentMatchId = matchId;
        
        Game.state.isSpectatorMode = true;
        Game.state.isReplayMode = false;
        
        document.getElementById('spectator-overlay').classList.remove('hidden');
        document.getElementById('game-board').classList.add('spectator-mode');
        
        document.getElementById('spectator-info').innerHTML = `
            <span class="spectator-badge">üëÅ SPECTATING</span>
            <span class="spectator-match">${liveMatch.player1Deity} vs ${liveMatch.player2Deity}</span>
            <span class="spectator-delay">(${this.spectatorDelay / 1000}s delay)</span>
        `;
        
        this.startUpdates();
        return true;
    },
    
    startUpdates() {
        this.updateInterval = setInterval(() => {
            this.fetchLatestState();
        }, 2000);
    },
    
    fetchLatestState() {
        if (!MatchRecorder.currentMatch) {
            this.stopSpectating();
            return;
        }
        
        const snapshots = MatchRecorder.currentMatch.stateSnapshots;
        if (snapshots.length > 0) {
            const delayedIndex = Math.max(0, snapshots.length - Math.ceil(this.spectatorDelay / 2000));
            const snapshot = snapshots[delayedIndex];
            this.applySpectatorSnapshot(snapshot);
        }
    },
    
    applySpectatorSnapshot(snapshot) {
        if (!snapshot) return;
        
        document.getElementById('spectator-turn').textContent = `Turn ${snapshot.turnNumber} - ${snapshot.currentPhase}`;
        
        snapshot.players.forEach((pData, pIndex) => {
            const prefix = pIndex === 0 ? 'p1' : 'p2';
            document.getElementById(`${prefix}-essence`).textContent = pData.essence;
            document.getElementById(`${prefix}-kl`).textContent = `${pData.klCurrent}/${pData.klMax}`;
        });
    },
    
    stopSpectating() {
        this.isSpectating = false;
        this.currentMatchId = null;
        
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
        
        Game.state.isSpectatorMode = false;
        document.getElementById('spectator-overlay').classList.add('hidden');
        document.getElementById('game-board').classList.remove('spectator-mode');
    }
};

const Matchmaking = {
    queues: {
        casual: [],
        ranked: []
    },
    playerProfile: {
        playerId: 'player-' + Math.random().toString(36).substr(2, 9),
        username: 'Player' + Math.floor(Math.random() * 1000),
        mmr: parseInt(localStorage.getItem('ec-player-mmr') || '1000'),
        seasonId: 1,
        tier: 'Bronze',
        tieBreaker: 0,
        gamesPlayedThisSeason: 0,
        highestTierThisSeason: 'Bronze',
        wins: 0,
        losses: 0,
        lastUpdated: Date.now()
    },
    friends: JSON.parse(localStorage.getItem('ec-friends') || '[]'),
    friendRequests: JSON.parse(localStorage.getItem('ec-friend-requests') || '[]'),
    addFriend(username) {
        if (!this.friends.includes(username) && username !== this.playerProfile.username) {
            this.friends.push(username);
            localStorage.setItem('ec-friends', JSON.stringify(this.friends));
            return true;
        }
        return false;
    },
    removeFriend(username) {
        this.friends = this.friends.filter(f => f !== username);
        localStorage.setItem('ec-friends', JSON.stringify(this.friends));
    },
    sendFriendRequest(username) {
        if (!this.friendRequests.includes(username) && username !== this.playerProfile.username) {
            this.friendRequests.push(username);
            localStorage.setItem('ec-friend-requests', JSON.stringify(this.friendRequests));
            return true;
        }
        return false;
    },
    acceptFriendRequest(username) {
        this.friendRequests = this.friendRequests.filter(r => r !== username);
        this.addFriend(username);
        localStorage.setItem('ec-friend-requests', JSON.stringify(this.friendRequests));
    },
    declineFriendRequest(username) {
        this.friendRequests = this.friendRequests.filter(r => r !== username);
        localStorage.setItem('ec-friend-requests', JSON.stringify(this.friendRequests));
    },
    getFriendStatus(username) {
        return Math.random() > 0.5 ? 'online' : 'offline';
    },
    tiers: ['Bronze III', 'Bronze II', 'Bronze I', 'Silver I', 'Silver II', 'Gold I', 'Gold II', 'Platinum I', 'Platinum II', 'Obsidian I', 'Obsidian II', 'Shattered Crown'],
    mmoToTier(mmr) {
        if (mmr < 1200) return { tier: 'Bronze', level: 'III', mmr };
        if (mmr < 1400) return { tier: 'Bronze', level: 'II', mmr };
        if (mmr < 1600) return { tier: 'Bronze', level: 'I', mmr };
        if (mmr < 1800) return { tier: 'Silver', level: 'I', mmr };
        if (mmr < 2000) return { tier: 'Silver', level: 'II', mmr };
        if (mmr < 2200) return { tier: 'Gold', level: 'I', mmr };
        if (mmr < 2400) return { tier: 'Gold', level: 'II', mmr };
        if (mmr < 2600) return { tier: 'Platinum', level: 'I', mmr };
        if (mmr < 2800) return { tier: 'Platinum', level: 'II', mmr };
        if (mmr < 3000) return { tier: 'Obsidian', level: 'I', mmr };
        if (mmr < 3200) return { tier: 'Obsidian', level: 'II', mmr };
        return { tier: 'Shattered Crown', level: 'I', mmr };
    },
    getTierDisplay() {
        const tierInfo = this.mmoToTier(this.playerProfile.mmr);
        return `${tierInfo.tier} ${tierInfo.level} (${this.playerProfile.mmr} MMR)`;
    },
    updateMMR(win) {
        const change = win ? 25 : -15;
        this.playerProfile.mmr = Math.max(800, this.playerProfile.mmr + change);
        this.playerProfile.gamesPlayedThisSeason++;
        if (win) this.playerProfile.wins++;
        else this.playerProfile.losses++;
        localStorage.setItem('ec-player-mmr', this.playerProfile.mmr);
    }
};

const EventManager = {
    events: JSON.parse(localStorage.getItem('ec-events') || '[]'),
    activeEvent: null,
    
    defaultEvents: [
        {
            id: 'void-dominion',
            name: 'Void Dominion',
            description: 'Only Void Aspect cards allowed. Embrace the darkness.',
            format: 'swiss',
            maxRounds: 3,
            rules: {
                allowedAspects: ['Void'],
                bannedTypes: [],
                startingEssence: 20,
                startingKL: 4,
                customRules: []
            },
            icon: 'üåë',
            active: true
        },
        {
            id: 'glow-ascension',
            name: 'Glow Ascension',
            description: 'Only Glow Aspect cards. Radiate pure light.',
            format: 'swiss',
            maxRounds: 3,
            rules: {
                allowedAspects: ['Glow'],
                bannedTypes: [],
                startingEssence: 25,
                startingKL: 3,
                customRules: []
            },
            icon: '‚ú®',
            active: true
        },
        {
            id: 'no-domains',
            name: 'Avatar Clash',
            description: 'Domains are banned. Pure creature combat.',
            format: 'elimination',
            maxRounds: 4,
            rules: {
                allowedAspects: ['Glow', 'Void', 'Gray'],
                bannedTypes: ['Domain'],
                startingEssence: 23,
                startingKL: 3,
                customRules: []
            },
            icon: '‚öîÔ∏è',
            active: true
        },
        {
            id: 'gray-tactics',
            name: 'Gray Tactics',
            description: 'Gray Aspect only. Balance is key.',
            format: 'swiss',
            maxRounds: 3,
            rules: {
                allowedAspects: ['Gray'],
                bannedTypes: [],
                startingEssence: 22,
                startingKL: 4,
                customRules: ['extraDraw']
            },
            icon: '‚öñÔ∏è',
            active: true
        },
        {
            id: 'spell-slinger',
            name: 'Spell Slinger',
            description: 'Avatars banned. Spell and Domain focus.',
            format: 'elimination',
            maxRounds: 3,
            rules: {
                allowedAspects: ['Glow', 'Void', 'Gray'],
                bannedTypes: ['Avatar'],
                startingEssence: 30,
                startingKL: 5,
                customRules: []
            },
            icon: 'üîÆ',
            active: true
        }
    ],
    
    init() {
        if (this.events.length === 0) {
            this.events = [...this.defaultEvents];
            this.save();
        }
    },
    
    save() {
        localStorage.setItem('ec-events', JSON.stringify(this.events));
    },
    
    getActiveEvents() {
        return this.events.filter(e => e.active);
    },
    
    getEvent(eventId) {
        return this.events.find(e => e.id === eventId);
    },
    
    setActiveEvent(eventId) {
        this.activeEvent = this.getEvent(eventId);
        return this.activeEvent;
    },
    
    clearActiveEvent() {
        this.activeEvent = null;
    },
    
    isCardAllowed(card) {
        if (!this.activeEvent) return true;
        const rules = this.activeEvent.rules;
        
        if (rules.allowedAspects.length > 0 && card.aspect) {
            if (!rules.allowedAspects.includes(card.aspect)) return false;
        }
        if (rules.bannedTypes.length > 0 && card.type) {
            if (rules.bannedTypes.includes(card.type)) return false;
        }
        return true;
    },
    
    getStartingEssence() {
        return this.activeEvent?.rules?.startingEssence || 23;
    },
    
    getStartingKL() {
        return this.activeEvent?.rules?.startingKL || 3;
    },
    
    hasCustomRule(rule) {
        return this.activeEvent?.rules?.customRules?.includes(rule) || false;
    },
    
    createEvent(eventData) {
        const newEvent = {
            id: 'event-' + Date.now(),
            name: eventData.name,
            description: eventData.description,
            format: eventData.format || 'swiss',
            maxRounds: eventData.maxRounds || 3,
            rules: {
                allowedAspects: eventData.allowedAspects || ['Glow', 'Void', 'Gray'],
                bannedTypes: eventData.bannedTypes || [],
                startingEssence: eventData.startingEssence || 23,
                startingKL: eventData.startingKL || 3,
                customRules: eventData.customRules || []
            },
            icon: eventData.icon || 'üéÆ',
            active: true
        };
        this.events.push(newEvent);
        this.save();
        return newEvent;
    }
};

const TournamentManager = {
    tournaments: JSON.parse(localStorage.getItem('ec-tournaments') || '[]'),
    activeTournament: null,
    currentMatch: null,
    
    save() {
        localStorage.setItem('ec-tournaments', JSON.stringify(this.tournaments));
    },
    
    createTournament(options) {
        const tournament = {
            id: 'tourney-' + Date.now() + '-' + Math.random().toString(36).substr(2, 4),
            name: options.name || 'Shard Wars Tournament',
            format: options.format || 'swiss',
            maxPlayers: options.maxPlayers || 8,
            currentRound: 0,
            maxRounds: options.maxRounds || (options.format === 'elimination' ? Math.ceil(Math.log2(options.maxPlayers || 8)) : 3),
            status: 'registration',
            eventId: options.eventId || null,
            players: [],
            rounds: [],
            standings: [],
            createdAt: Date.now(),
            startedAt: null,
            endedAt: null
        };
        
        this.tournaments.unshift(tournament);
        if (this.tournaments.length > 20) this.tournaments.pop();
        this.save();
        return tournament;
    },
    
    getTournament(tournamentId) {
        return this.tournaments.find(t => t.id === tournamentId);
    },
    
    getOpenTournaments() {
        return this.tournaments.filter(t => t.status === 'registration');
    },
    
    getActiveTournaments() {
        return this.tournaments.filter(t => t.status === 'active');
    },
    
    registerPlayer(tournamentId, player) {
        const tournament = this.getTournament(tournamentId);
        if (!tournament) return { success: false, error: 'Tournament not found' };
        if (tournament.status !== 'registration') return { success: false, error: 'Registration closed' };
        if (tournament.players.length >= tournament.maxPlayers) return { success: false, error: 'Tournament full' };
        if (tournament.players.find(p => p.playerId === player.playerId)) {
            return { success: false, error: 'Already registered' };
        }
        
        tournament.players.push({
            playerId: player.playerId,
            username: player.username,
            mmr: player.mmr || 1000,
            wins: 0,
            losses: 0,
            draws: 0,
            gameWins: 0,
            gameLosses: 0,
            matchPoints: 0,
            opponentWinRate: 0,
            dropped: false,
            seed: tournament.players.length + 1
        });
        
        this.save();
        return { success: true, tournament };
    },
    
    unregisterPlayer(tournamentId, playerId) {
        const tournament = this.getTournament(tournamentId);
        if (!tournament) return { success: false, error: 'Tournament not found' };
        if (tournament.status !== 'registration') return { success: false, error: 'Cannot unregister after start' };
        
        tournament.players = tournament.players.filter(p => p.playerId !== playerId);
        this.save();
        return { success: true };
    },
    
    startTournament(tournamentId) {
        const tournament = this.getTournament(tournamentId);
        if (!tournament) return { success: false, error: 'Tournament not found' };
        if (tournament.players.length < 2) return { success: false, error: 'Need at least 2 players' };
        
        tournament.status = 'active';
        tournament.startedAt = Date.now();
        tournament.currentRound = 1;
        
        this.shufflePlayers(tournament);
        
        if (tournament.format === 'swiss') {
            this.generateSwissRound(tournament);
        } else {
            this.generateEliminationBracket(tournament);
        }
        
        this.save();
        return { success: true, tournament };
    },
    
    shufflePlayers(tournament) {
        for (let i = tournament.players.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [tournament.players[i], tournament.players[j]] = [tournament.players[j], tournament.players[i]];
        }
        tournament.players.forEach((p, idx) => p.seed = idx + 1);
    },
    
    generateSwissRound(tournament) {
        const activePlayers = tournament.players.filter(p => !p.dropped);
        
        activePlayers.sort((a, b) => {
            if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints;
            return b.opponentWinRate - a.opponentWinRate;
        });
        
        const round = {
            roundNumber: tournament.currentRound,
            matches: [],
            completed: false
        };
        
        const paired = new Set();
        const previousOpponents = this.getPreviousOpponents(tournament);
        
        for (let i = 0; i < activePlayers.length; i++) {
            if (paired.has(activePlayers[i].playerId)) continue;
            
            for (let j = i + 1; j < activePlayers.length; j++) {
                if (paired.has(activePlayers[j].playerId)) continue;
                
                const prevOpps = previousOpponents[activePlayers[i].playerId] || [];
                if (!prevOpps.includes(activePlayers[j].playerId)) {
                    round.matches.push({
                        matchId: `${tournament.id}-r${tournament.currentRound}-m${round.matches.length + 1}`,
                        player1: activePlayers[i].playerId,
                        player2: activePlayers[j].playerId,
                        player1Name: activePlayers[i].username,
                        player2Name: activePlayers[j].username,
                        result: null,
                        winner: null,
                        reported: false
                    });
                    paired.add(activePlayers[i].playerId);
                    paired.add(activePlayers[j].playerId);
                    break;
                }
            }
        }
        
        const unpaired = activePlayers.filter(p => !paired.has(p.playerId));
        if (unpaired.length === 1) {
            round.matches.push({
                matchId: `${tournament.id}-r${tournament.currentRound}-bye`,
                player1: unpaired[0].playerId,
                player2: 'BYE',
                player1Name: unpaired[0].username,
                player2Name: 'BYE',
                result: '2-0',
                winner: unpaired[0].playerId,
                reported: true,
                isBye: true
            });
            unpaired[0].matchPoints += 3;
            unpaired[0].wins++;
        }
        
        tournament.rounds.push(round);
    },
    
    generateEliminationBracket(tournament) {
        const players = [...tournament.players];
        const bracketSize = Math.pow(2, Math.ceil(Math.log2(players.length)));
        
        while (players.length < bracketSize) {
            players.push({ playerId: 'BYE', username: 'BYE', isBye: true });
        }
        
        const round = {
            roundNumber: tournament.currentRound,
            matches: [],
            completed: false
        };
        
        for (let i = 0; i < players.length; i += 2) {
            const p1 = players[i];
            const p2 = players[i + 1];
            
            const match = {
                matchId: `${tournament.id}-r${tournament.currentRound}-m${round.matches.length + 1}`,
                player1: p1.playerId,
                player2: p2.playerId,
                player1Name: p1.username,
                player2Name: p2.username,
                result: null,
                winner: null,
                reported: false,
                bracketPosition: round.matches.length
            };
            
            if (p2.isBye) {
                match.result = 'BYE';
                match.winner = p1.playerId;
                match.reported = true;
                const player = tournament.players.find(pl => pl.playerId === p1.playerId);
                if (player) player.wins++;
            } else if (p1.isBye) {
                match.result = 'BYE';
                match.winner = p2.playerId;
                match.reported = true;
                const player = tournament.players.find(pl => pl.playerId === p2.playerId);
                if (player) player.wins++;
            }
            
            round.matches.push(match);
        }
        
        tournament.rounds.push(round);
    },
    
    getPreviousOpponents(tournament) {
        const opponents = {};
        tournament.rounds.forEach(round => {
            round.matches.forEach(match => {
                if (match.player2 !== 'BYE') {
                    if (!opponents[match.player1]) opponents[match.player1] = [];
                    if (!opponents[match.player2]) opponents[match.player2] = [];
                    opponents[match.player1].push(match.player2);
                    opponents[match.player2].push(match.player1);
                }
            });
        });
        return opponents;
    },
    
    reportMatchResult(tournamentId, matchId, winnerId, result) {
        const tournament = this.getTournament(tournamentId);
        if (!tournament) return { success: false, error: 'Tournament not found' };
        
        const currentRound = tournament.rounds[tournament.currentRound - 1];
        if (!currentRound) return { success: false, error: 'Round not found' };
        
        const match = currentRound.matches.find(m => m.matchId === matchId);
        if (!match) return { success: false, error: 'Match not found' };
        if (match.reported) return { success: false, error: 'Match already reported' };
        
        match.winner = winnerId;
        match.result = result;
        match.reported = true;
        
        const winner = tournament.players.find(p => p.playerId === winnerId);
        const loserId = match.player1 === winnerId ? match.player2 : match.player1;
        const loser = tournament.players.find(p => p.playerId === loserId);
        
        if (winner) {
            winner.wins++;
            winner.matchPoints += 3;
        }
        if (loser && loser.playerId !== 'BYE') {
            loser.losses++;
        }
        
        const allReported = currentRound.matches.every(m => m.reported);
        if (allReported) {
            currentRound.completed = true;
            this.advanceRound(tournament);
        }
        
        this.save();
        return { success: true, tournament };
    },
    
    advanceRound(tournament) {
        if (tournament.format === 'swiss') {
            if (tournament.currentRound >= tournament.maxRounds) {
                this.endTournament(tournament);
            } else {
                tournament.currentRound++;
                this.updateOpponentWinRates(tournament);
                this.generateSwissRound(tournament);
            }
        } else {
            const lastRound = tournament.rounds[tournament.rounds.length - 1];
            const winners = lastRound.matches.map(m => m.winner).filter(w => w && w !== 'BYE');
            
            if (winners.length === 1) {
                this.endTournament(tournament);
            } else {
                tournament.currentRound++;
                const round = {
                    roundNumber: tournament.currentRound,
                    matches: [],
                    completed: false
                };
                
                for (let i = 0; i < winners.length; i += 2) {
                    const p1 = tournament.players.find(p => p.playerId === winners[i]);
                    const p2 = winners[i + 1] ? tournament.players.find(p => p.playerId === winners[i + 1]) : null;
                    
                    round.matches.push({
                        matchId: `${tournament.id}-r${tournament.currentRound}-m${round.matches.length + 1}`,
                        player1: p1.playerId,
                        player2: p2 ? p2.playerId : 'BYE',
                        player1Name: p1.username,
                        player2Name: p2 ? p2.username : 'BYE',
                        result: p2 ? null : 'BYE',
                        winner: p2 ? null : p1.playerId,
                        reported: !p2,
                        bracketPosition: round.matches.length
                    });
                }
                
                tournament.rounds.push(round);
            }
        }
    },
    
    updateOpponentWinRates(tournament) {
        const opponents = this.getPreviousOpponents(tournament);
        
        tournament.players.forEach(player => {
            const opps = opponents[player.playerId] || [];
            if (opps.length === 0) {
                player.opponentWinRate = 0;
                return;
            }
            
            let totalWinRate = 0;
            opps.forEach(oppId => {
                const opp = tournament.players.find(p => p.playerId === oppId);
                if (opp) {
                    const games = opp.wins + opp.losses;
                    totalWinRate += games > 0 ? opp.wins / games : 0.5;
                }
            });
            player.opponentWinRate = totalWinRate / opps.length;
        });
    },
    
    endTournament(tournament) {
        tournament.status = 'completed';
        tournament.endedAt = Date.now();
        
        tournament.standings = [...tournament.players]
            .filter(p => !p.dropped)
            .sort((a, b) => {
                if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints;
                if (b.opponentWinRate !== a.opponentWinRate) return b.opponentWinRate - a.opponentWinRate;
                return b.gameWins - a.gameWins;
            })
            .map((p, idx) => ({ ...p, finalRank: idx + 1 }));
        
        this.save();
    },
    
    getStandings(tournamentId) {
        const tournament = this.getTournament(tournamentId);
        if (!tournament) return [];
        
        if (tournament.status === 'completed') return tournament.standings;
        
        return [...tournament.players]
            .filter(p => !p.dropped)
            .sort((a, b) => {
                if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints;
                if (b.opponentWinRate !== a.opponentWinRate) return b.opponentWinRate - a.opponentWinRate;
                return b.wins - a.wins;
            })
            .map((p, idx) => ({ ...p, currentRank: idx + 1 }));
    },
    
    getCurrentMatches(tournamentId) {
        const tournament = this.getTournament(tournamentId);
        if (!tournament || tournament.status !== 'active') return [];
        
        const currentRound = tournament.rounds[tournament.currentRound - 1];
        return currentRound ? currentRound.matches : [];
    },
    
    getPlayerMatch(tournamentId, playerId) {
        const matches = this.getCurrentMatches(tournamentId);
        return matches.find(m => 
            (m.player1 === playerId || m.player2 === playerId) && !m.reported
        );
    },
    
    dropPlayer(tournamentId, playerId) {
        const tournament = this.getTournament(tournamentId);
        if (!tournament) return { success: false, error: 'Tournament not found' };
        
        const player = tournament.players.find(p => p.playerId === playerId);
        if (player) {
            player.dropped = true;
            this.save();
            return { success: true };
        }
        return { success: false, error: 'Player not found' };
    },
    
    setActiveTournament(tournamentId) {
        this.activeTournament = this.getTournament(tournamentId);
        return this.activeTournament;
    }
};

const LimitedMode = {
    currentPool: [],
    currentDeck: [],
    sealedActive: false,
    draftActive: false,
    draftPacks: [],
    draftPickHistory: [],
    
    rarityWeights: {
        'Mythic': 1,
        'Arcane': 3,
        'Master': 8,
        'Adept': 20,
        'Shard': 35
    },
    
    sealedConfig: {
        poolSize: 45,
        minDeckSize: 30,
        maxDeckSize: 40,
        guaranteedMythic: 1,
        guaranteedArcane: 2,
        guaranteedMaster: 5
    },
    
    draftConfig: {
        packSize: 15,
        packCount: 3,
        pickTime: 45
    },
    
    init() {
        const saved = localStorage.getItem('ec-limited-state');
        if (saved) {
            const state = JSON.parse(saved);
            this.currentPool = state.pool || [];
            this.currentDeck = state.deck || [];
            this.sealedActive = state.sealedActive || false;
        }
    },
    
    save() {
        localStorage.setItem('ec-limited-state', JSON.stringify({
            pool: this.currentPool,
            deck: this.currentDeck,
            sealedActive: this.sealedActive
        }));
    },
    
    generateSealedPool() {
        const pool = [];
        const nonDeityCards = ALL_CARDS.filter(c => c.type !== 'Deity');
        
        const mythics = nonDeityCards.filter(c => c.rarity === 'Mythic');
        const arcanes = nonDeityCards.filter(c => c.rarity === 'Arcane');
        const masters = nonDeityCards.filter(c => c.rarity === 'Master');
        const adepts = nonDeityCards.filter(c => c.rarity === 'Adept');
        const shards = nonDeityCards.filter(c => c.rarity === 'Shard');
        
        for (let i = 0; i < this.sealedConfig.guaranteedMythic && mythics.length > 0; i++) {
            const idx = Math.floor(Math.random() * mythics.length);
            pool.push({ ...mythics[idx], instanceId: 'sealed-' + Date.now() + '-' + pool.length });
        }
        
        for (let i = 0; i < this.sealedConfig.guaranteedArcane && arcanes.length > 0; i++) {
            const idx = Math.floor(Math.random() * arcanes.length);
            pool.push({ ...arcanes[idx], instanceId: 'sealed-' + Date.now() + '-' + pool.length });
        }
        
        for (let i = 0; i < this.sealedConfig.guaranteedMaster && masters.length > 0; i++) {
            const idx = Math.floor(Math.random() * masters.length);
            pool.push({ ...masters[idx], instanceId: 'sealed-' + Date.now() + '-' + pool.length });
        }
        
        while (pool.length < this.sealedConfig.poolSize) {
            const card = this.weightedRandomCard(nonDeityCards);
            if (card) {
                pool.push({ ...card, instanceId: 'sealed-' + Date.now() + '-' + pool.length });
            }
        }
        
        this.currentPool = pool;
        this.currentDeck = [];
        this.sealedActive = true;
        this.save();
        return pool;
    },
    
    weightedRandomCard(cards) {
        const totalWeight = cards.reduce((sum, c) => sum + (this.rarityWeights[c.rarity] || 10), 0);
        let random = Math.random() * totalWeight;
        
        for (const card of cards) {
            random -= (this.rarityWeights[card.rarity] || 10);
            if (random <= 0) return card;
        }
        return cards[Math.floor(Math.random() * cards.length)];
    },
    
    addToDeck(cardInstanceId) {
        if (this.currentDeck.length >= this.sealedConfig.maxDeckSize) {
            return { success: false, error: 'Deck is at maximum size' };
        }
        
        const cardIndex = this.currentPool.findIndex(c => c.instanceId === cardInstanceId);
        if (cardIndex === -1) {
            return { success: false, error: 'Card not in pool' };
        }
        
        const card = this.currentPool.splice(cardIndex, 1)[0];
        this.currentDeck.push(card);
        this.save();
        return { success: true };
    },
    
    removeFromDeck(cardInstanceId) {
        const cardIndex = this.currentDeck.findIndex(c => c.instanceId === cardInstanceId);
        if (cardIndex === -1) {
            return { success: false, error: 'Card not in deck' };
        }
        
        const card = this.currentDeck.splice(cardIndex, 1)[0];
        this.currentPool.push(card);
        this.save();
        return { success: true };
    },
    
    isDeckValid() {
        return this.currentDeck.length >= this.sealedConfig.minDeckSize && 
               this.currentDeck.length <= this.sealedConfig.maxDeckSize;
    },
    
    getDeckForGame() {
        if (!this.isDeckValid()) return null;
        return this.currentDeck.map(c => ({ ...c }));
    },
    
    endSealed() {
        this.currentPool = [];
        this.currentDeck = [];
        this.sealedActive = false;
        this.save();
    },
    
    generateDraftPack() {
        const pack = [];
        const nonDeityCards = ALL_CARDS.filter(c => c.type !== 'Deity');
        
        const mythics = nonDeityCards.filter(c => c.rarity === 'Mythic' || c.rarity === 'Arcane');
        if (mythics.length > 0 && Math.random() < 0.15) {
            const idx = Math.floor(Math.random() * mythics.length);
            pack.push({ ...mythics[idx], instanceId: 'draft-' + Date.now() + '-' + pack.length });
        }
        
        while (pack.length < this.draftConfig.packSize) {
            const card = this.weightedRandomCard(nonDeityCards);
            if (card) {
                pack.push({ ...card, instanceId: 'draft-' + Date.now() + '-' + pack.length });
            }
        }
        
        return pack;
    },
    
    initDraft() {
        this.draftPacks = [];
        this.draftPickHistory = [];
        this.currentDeck = [];
        this.draftActive = true;
        
        for (let i = 0; i < this.draftConfig.packCount; i++) {
            this.draftPacks.push(this.generateDraftPack());
        }
        
        this.save();
        return this.draftPacks[0];
    },
    
    makeDraftPick(cardInstanceId, currentPackIndex) {
        const pack = this.draftPacks[currentPackIndex];
        if (!pack) return { success: false, error: 'Invalid pack' };
        
        const cardIndex = pack.findIndex(c => c.instanceId === cardInstanceId);
        if (cardIndex === -1) return { success: false, error: 'Card not in pack' };
        
        const card = pack.splice(cardIndex, 1)[0];
        this.currentDeck.push(card);
        this.draftPickHistory.push(card.id);
        this.save();
        
        return { 
            success: true, 
            nextPack: pack.length > 0 ? pack : (this.draftPacks[currentPackIndex + 1] || null),
            packIndex: pack.length > 0 ? currentPackIndex : currentPackIndex + 1,
            draftComplete: currentPackIndex >= this.draftConfig.packCount - 1 && pack.length === 0
        };
    }
};

const CosmeticsManager = {
    owned: JSON.parse(localStorage.getItem('ec-cosmetics-owned') || '{}'),
    equipped: JSON.parse(localStorage.getItem('ec-cosmetics-equipped') || '{}'),
    
    cosmeticTypes: {
        cardBack: {
            name: 'Card Backs',
            description: 'Customize the back of your cards'
        },
        deitySkin: {
            name: 'Deity Skins',
            description: 'Alternate appearances for your Deities'
        },
        boardSkin: {
            name: 'Board Skins',
            description: 'Change the New Earth battlefield appearance'
        },
        effectVariant: {
            name: 'Effect Variants',
            description: 'Customize spell and ability animations'
        },
        cardFrame: {
            name: 'Card Frames',
            description: 'Unique borders for your cards'
        }
    },
    
    allCosmetics: [
        { id: 'cb-default', type: 'cardBack', name: 'Standard Back', rarity: 'common', price: 0, owned: true, image: 'default' },
        { id: 'cb-void', type: 'cardBack', name: 'Void Eclipse', rarity: 'rare', price: 500, owned: false, image: 'void' },
        { id: 'cb-glow', type: 'cardBack', name: 'Solar Radiance', rarity: 'rare', price: 500, owned: false, image: 'glow' },
        { id: 'cb-gray', type: 'cardBack', name: 'Neutral Balance', rarity: 'rare', price: 500, owned: false, image: 'gray' },
        { id: 'cb-mythic', type: 'cardBack', name: 'Crown Essence', rarity: 'legendary', price: 1500, owned: false, image: 'mythic' },
        { id: 'cb-shattered', type: 'cardBack', name: 'Shattered Crown', rarity: 'mythic', price: 3000, owned: false, image: 'shattered' },
        
        { id: 'ds-herald-alt', type: 'deitySkin', name: 'Second Sun Herald - Eclipse Form', rarity: 'epic', price: 1000, owned: false, deityId: 'EC-001' },
        { id: 'ds-regent-alt', type: 'deitySkin', name: 'Null Regent - Corrupted', rarity: 'epic', price: 1000, owned: false, deityId: 'EC-002' },
        { id: 'ds-arbiter-alt', type: 'deitySkin', name: 'Crown Arbiter - Transcendent', rarity: 'legendary', price: 2000, owned: false, deityId: 'EC-036' },
        
        { id: 'bs-default', type: 'boardSkin', name: 'New Earth - Standard', rarity: 'common', price: 0, owned: true },
        { id: 'bs-void', type: 'boardSkin', name: 'New Earth - Void Realm', rarity: 'rare', price: 800, owned: false },
        { id: 'bs-glow', type: 'boardSkin', name: 'New Earth - Solar Temple', rarity: 'rare', price: 800, owned: false },
        { id: 'bs-cosmic', type: 'boardSkin', name: 'New Earth - Cosmic Expanse', rarity: 'legendary', price: 2000, owned: false },
        { id: 'bs-shattered', type: 'boardSkin', name: 'New Earth - Shattered Dimension', rarity: 'mythic', price: 4000, owned: false },
        
        { id: 'ev-default', type: 'effectVariant', name: 'Standard Effects', rarity: 'common', price: 0, owned: true },
        { id: 'ev-void', type: 'effectVariant', name: 'Void Tendrils', rarity: 'rare', price: 600, owned: false },
        { id: 'ev-glow', type: 'effectVariant', name: 'Solar Flares', rarity: 'rare', price: 600, owned: false },
        { id: 'ev-cosmic', type: 'effectVariant', name: 'Cosmic Particles', rarity: 'legendary', price: 1500, owned: false },
        
        { id: 'cf-default', type: 'cardFrame', name: 'Standard Frame', rarity: 'common', price: 0, owned: true },
        { id: 'cf-gold', type: 'cardFrame', name: 'Golden Frame', rarity: 'rare', price: 400, owned: false },
        { id: 'cf-void', type: 'cardFrame', name: 'Void Border', rarity: 'rare', price: 400, owned: false },
        { id: 'cf-prismatic', type: 'cardFrame', name: 'Prismatic Edge', rarity: 'legendary', price: 1200, owned: false },
        { id: 'cf-crown', type: 'cardFrame', name: 'Crown Insignia', rarity: 'mythic', price: 2500, owned: false }
    ],
    
    init() {
        if (Object.keys(this.owned).length === 0) {
            this.allCosmetics.filter(c => c.price === 0).forEach(c => {
                this.owned[c.id] = true;
            });
            this.save();
        }
        
        if (!this.equipped.cardBack) {
            this.equipped = {
                cardBack: 'cb-default',
                deitySkin: {},
                boardSkin: 'bs-default',
                effectVariant: 'ev-default',
                cardFrame: 'cf-default'
            };
            this.saveEquipped();
        }
    },
    
    save() {
        localStorage.setItem('ec-cosmetics-owned', JSON.stringify(this.owned));
    },
    
    saveEquipped() {
        localStorage.setItem('ec-cosmetics-equipped', JSON.stringify(this.equipped));
    },
    
    getCosmetic(id) {
        return this.allCosmetics.find(c => c.id === id);
    },
    
    getCosmeticsByType(type) {
        return this.allCosmetics.filter(c => c.type === type);
    },
    
    isOwned(id) {
        return this.owned[id] === true;
    },
    
    purchase(id) {
        const cosmetic = this.getCosmetic(id);
        if (!cosmetic) return { success: false, error: 'Cosmetic not found' };
        if (this.isOwned(id)) return { success: false, error: 'Already owned' };
        
        const currency = ShardPath.getCurrency();
        if (currency < cosmetic.price) {
            return { success: false, error: 'Not enough Shards' };
        }
        
        ShardPath.spendCurrency(cosmetic.price);
        this.owned[id] = true;
        this.save();
        return { success: true, cosmetic };
    },
    
    equip(id) {
        const cosmetic = this.getCosmetic(id);
        if (!cosmetic) return { success: false, error: 'Cosmetic not found' };
        if (!this.isOwned(id)) return { success: false, error: 'Not owned' };
        
        if (cosmetic.type === 'deitySkin') {
            this.equipped.deitySkin[cosmetic.deityId] = id;
        } else {
            this.equipped[cosmetic.type] = id;
        }
        
        this.saveEquipped();
        return { success: true };
    },
    
    getEquipped(type, deityId = null) {
        if (type === 'deitySkin' && deityId) {
            return this.equipped.deitySkin[deityId] || null;
        }
        return this.equipped[type] || null;
    },
    
    getCardBackUrl() {
        const equipped = this.getEquipped('cardBack');
        const cosmetic = this.getCosmetic(equipped);
        if (cosmetic?.image === 'default') return CARD_BACK_URL;
        return CARD_BACK_URL;
    },
    
    getBoardClass() {
        const equipped = this.getEquipped('boardSkin');
        const cosmetic = this.getCosmetic(equipped);
        if (cosmetic) return `board-${cosmetic.image || 'default'}`;
        return 'board-default';
    },
    
    unlockCosmetic(id) {
        this.owned[id] = true;
        this.save();
    }
};

const RewardsSystem = {
    data: JSON.parse(localStorage.getItem('ec-rewards-data') || 'null') || {
        previousTier: 'Bronze III',
        highestTierReached: 'Bronze III',
        claimedTierRewards: [],
        totalShardsEarned: 0,
        rankUpsThisSeason: 0
    },
    
    tierRewards: {
        'Bronze III': { shards: 0, cosmetic: null, title: 'Initiate' },
        'Bronze II': { shards: 322, cosmetic: null, title: 'Bronze Aspirant' },
        'Bronze I': { shards: 422, cosmetic: 'cf-gold', title: 'Bronze Champion' },
        'Silver I': { shards: 522, cosmetic: 'cb-gray', title: 'Silver Initiate' },
        'Silver II': { shards: 722, cosmetic: 'ev-glow', title: 'Silver Adept' },
        'Gold I': { shards: 972, cosmetic: 'cb-glow', title: 'Gold Aspirant' },
        'Gold II': { shards: 1222, cosmetic: 'bs-glow', title: 'Gold Champion' },
        'Platinum I': { shards: 1722, cosmetic: 'cb-void', title: 'Platinum Initiate' },
        'Platinum II': { shards: 2222, cosmetic: 'ev-void', title: 'Platinum Master' },
        'Obsidian I': { shards: 3222, cosmetic: 'bs-void', title: 'Obsidian Adept' },
        'Obsidian II': { shards: 4222, cosmetic: 'ev-cosmic', title: 'Obsidian Lord' },
        'Shattered Crown I': { shards: 5222, cosmetic: 'cb-shattered', title: 'Shattered Crown' }
    },
    
    tierOrder: [
        'Bronze III', 'Bronze II', 'Bronze I',
        'Silver I', 'Silver II',
        'Gold I', 'Gold II',
        'Platinum I', 'Platinum II',
        'Obsidian I', 'Obsidian II',
        'Shattered Crown I'
    ],
    
    init() {
        this.loadData();
    },
    
    loadData() {
        const saved = localStorage.getItem('ec-rewards-data');
        if (saved) {
            this.data = { ...this.data, ...JSON.parse(saved) };
        }
    },
    
    save() {
        localStorage.setItem('ec-rewards-data', JSON.stringify(this.data));
    },
    
    getTierIndex(tierName) {
        return this.tierOrder.indexOf(tierName);
    },
    
    getCurrentTier() {
        const tierInfo = Matchmaking.mmoToTier(Matchmaking.playerProfile.mmr);
        return `${tierInfo.tier} ${tierInfo.level}`;
    },
    
    checkRankUp() {
        const currentTier = this.getCurrentTier();
        const previousTier = this.data.previousTier;
        const currentIndex = this.getTierIndex(currentTier);
        const previousIndex = this.getTierIndex(previousTier);
        
        if (currentIndex === -1 || previousIndex === -1) {
            this.data.previousTier = currentTier;
            this.save();
            return { rankedUp: false };
        }
        
        if (currentIndex > previousIndex) {
            if (this.data.claimedTierRewards.includes(currentTier)) {
                this.data.previousTier = currentTier;
                this.save();
                return { rankedUp: true, newTier: currentTier, rewards: { shards: 0, cosmetic: null, title: null, alreadyClaimed: true } };
            }
            
            const rewards = this.grantRankUpRewards(currentTier);
            this.data.previousTier = currentTier;
            this.data.rankUpsThisSeason++;
            
            if (currentIndex > this.getTierIndex(this.data.highestTierReached)) {
                this.data.highestTierReached = currentTier;
            }
            
            this.save();
            return { rankedUp: true, newTier: currentTier, rewards };
        }
        
        if (currentIndex < previousIndex) {
            this.data.previousTier = currentTier;
            this.save();
            return { rankedUp: false, demoted: true };
        }
        
        return { rankedUp: false };
    },
    
    grantRankUpRewards(tier) {
        if (this.data.claimedTierRewards.includes(tier)) {
            return { shards: 0, cosmetic: null, title: null, alreadyClaimed: true };
        }
        
        const reward = this.tierRewards[tier];
        if (!reward) return { shards: 0, cosmetic: null, title: null };
        
        const rewards = {
            shards: reward.shards || 0,
            cosmetic: null,
            title: reward.title || null
        };
        
        if (reward.shards > 0) {
            ShardPath.addCurrency(reward.shards);
            this.data.totalShardsEarned += reward.shards;
        }
        
        if (reward.cosmetic) {
            CosmeticsManager.unlockCosmetic(reward.cosmetic);
            rewards.cosmetic = CosmeticsManager.getCosmetic(reward.cosmetic);
        }
        
        if (reward.title) {
            PlayerProfile.unlockTitle(reward.title);
        }
        
        this.data.claimedTierRewards.push(tier);
        this.save();
        return rewards;
    },
    
    getMatchRewards(won, matchMode, difficulty = 'medium') {
        const baseRewards = {
            casual: { win: 237, loss: 227 },
            ranked: { win: 252, loss: 232 },
            tournament: { win: 272, loss: 242 },
            campaign: { win: 0, loss: 0 }
        };
        
        const aiBonus = {
            easy: 1,
            medium: 1.5,
            hard: 2,
            boss: 3
        };
        
        const mode = matchMode || 'casual';
        const base = baseRewards[mode] || baseRewards.casual;
        const amount = won ? base.win : base.loss;
        const multiplier = matchMode === 'ranked' ? 1 : (aiBonus[difficulty] || 1);
        
        return Math.floor(amount * multiplier);
    },
    
    showRankUpNotification(tier, rewards) {
        const notification = document.createElement('div');
        notification.className = 'rank-up-notification';
        notification.innerHTML = `
            <div class="rank-up-content">
                <div class="rank-up-glow"></div>
                <h2>RANK UP!</h2>
                <div class="new-rank">${tier}</div>
                <div class="rank-rewards">
                    ${rewards.shards > 0 ? `<div class="reward-item">üíé +${rewards.shards} Shards</div>` : ''}
                    ${rewards.cosmetic ? `<div class="reward-item">üé® ${rewards.cosmetic.name}</div>` : ''}
                    ${rewards.title ? `<div class="reward-item">üëë Title: ${rewards.title}</div>` : ''}
                </div>
                <button onclick="this.parentElement.parentElement.remove()">Awesome!</button>
            </div>
        `;
        document.body.appendChild(notification);
        
        BattleEffects.screenFlash('#d4af37', 500);
        BattleEffects.screenShake(5, 300);
        
        setTimeout(() => notification.remove(), 8000);
    }
};

const ShardPath = {
    data: JSON.parse(localStorage.getItem('ec-shard-path') || 'null') || {
        currentXP: 0,
        currentLevel: 1,
        maxLevel: 50,
        seasonNumber: 1,
        seasonName: 'Season of the Crown',
        seasonEnd: Date.now() + (90 * 24 * 60 * 60 * 1000),
        premiumUnlocked: false,
        claimedRewards: { free: [], premium: [] },
        currency: 500,
        dailyQuests: [],
        weeklyQuests: [],
        questResetTime: 0
    },
    
    xpPerLevel: 1000,
    xpPerMatch: 50,
    xpPerWin: 100,
    xpPerQuest: 200,
    
    rewards: {
        free: [
            { level: 1, type: "currency", amount: 322, name: '100 Shards' },
            { level: 3, type: 'cosmetic', id: 'cb-gray', name: 'Neutral Balance Card Back' },
            { level: 5, type: "currency", amount: 422, name: '200 Shards' },
            { level: 7, type: 'cosmetic', id: 'cf-gold', name: 'Golden Frame' },
            { level: 10, type: "currency", amount: 522, name: '300 Shards' },
            { level: 12, type: 'cosmetic', id: 'ev-glow', name: 'Solar Flares Effects' },
            { level: 15, type: "currency", amount: 622, name: '400 Shards' },
            { level: 18, type: 'cosmetic', id: 'cb-glow', name: 'Solar Radiance Card Back' },
            { level: 20, type: "currency", amount: 722, name: '500 Shards' },
            { level: 23, type: 'cosmetic', id: 'bs-glow', name: 'Solar Temple Board' },
            { level: 25, type: "currency", amount: 822, name: '600 Shards' },
            { level: 28, type: 'cosmetic', id: 'cf-void', name: 'Void Border Frame' },
            { level: 30, type: "currency", amount: 922, name: '700 Shards' },
            { level: 33, type: 'cosmetic', id: 'ev-void', name: 'Void Tendrils Effects' },
            { level: 35, type: "currency", amount: 1022, name: '800 Shards' },
            { level: 38, type: 'cosmetic', id: 'cb-void', name: 'Void Eclipse Card Back' },
            { level: 40, type: "currency", amount: 1222, name: '1000 Shards' },
            { level: 43, type: 'cosmetic', id: 'bs-void', name: 'Void Realm Board' },
            { level: 45, type: "currency", amount: 1422, name: '1200 Shards' },
            { level: 48, type: 'cosmetic', id: 'cf-prismatic', name: 'Prismatic Edge Frame' },
            { level: 50, type: "currency", amount: 2222, name: '2000 Shards' }
        ],
        premium: [
            { level: 1, type: "currency", amount: 422, name: "422 Shards" },
            { level: 2, type: 'cosmetic', id: 'ds-herald-alt', name: 'Second Sun Herald - Eclipse Form' },
            { level: 5, type: "currency", amount: 522, name: '300 Shards' },
            { level: 8, type: 'cosmetic', id: 'ds-regent-alt', name: 'Null Regent - Corrupted' },
            { level: 10, type: "currency", amount: 622, name: '400 Shards' },
            { level: 13, type: 'cosmetic', id: 'ev-cosmic', name: 'Cosmic Particles Effects' },
            { level: 15, type: "currency", amount: 722, name: '500 Shards' },
            { level: 18, type: 'cosmetic', id: 'cb-mythic', name: 'Crown Essence Card Back' },
            { level: 20, type: "currency", amount: 822, name: '600 Shards' },
            { level: 23, type: 'cosmetic', id: 'bs-cosmic', name: 'Cosmic Expanse Board' },
            { level: 25, type: 'currency', amount: 700, name: '700 Shards' },
            { level: 28, type: 'cosmetic', id: 'ds-arbiter-alt', name: 'Crown Arbiter - Transcendent' },
            { level: 30, type: 'currency', amount: 800, name: '800 Shards' },
            { level: 33, type: 'cosmetic', id: 'cf-crown', name: 'Crown Insignia Frame' },
            { level: 35, type: 'currency', amount: 1000, name: '1000 Shards' },
            { level: 38, type: 'cosmetic', id: 'bs-shattered', name: 'Shattered Dimension Board' },
            { level: 40, type: 'currency', amount: 1500, name: '1500 Shards' },
            { level: 45, type: 'cosmetic', id: 'cb-shattered', name: 'Shattered Crown Card Back' },
            { level: 50, type: 'currency', amount: 3000, name: '3000 Shards + Exclusive Title' }
        ]
    },
    
    questTemplates: {
        daily: [
            { id: 'play-3', name: 'Daily Warrior', description: 'Play 3 matches', target: 3, xp: 150, type: 'matches' },
            { id: 'win-1', name: 'Victory!', description: 'Win 1 match', target: 1, xp: 100, type: 'wins' },
            { id: 'play-glow', name: 'Light Bearer', description: 'Play 5 Glow cards', target: 5, xp: 100, type: 'aspect', aspect: 'Glow' },
            { id: 'play-void', name: 'Void Walker', description: 'Play 5 Void cards', target: 5, xp: 100, type: 'aspect', aspect: 'Void' },
            { id: 'deal-damage', name: 'Aggressor', description: 'Deal 20 Essence damage', target: 20, xp: 120, type: 'damage' }
        ],
        weekly: [
            { id: 'win-7', name: 'Weekly Champion', description: 'Win 7 matches', target: 7, xp: 500, type: 'wins' },
            { id: 'play-15', name: 'Dedicated Player', description: 'Play 15 matches', target: 15, xp: 400, type: 'matches' },
            { id: 'tournament', name: 'Tournament Contender', description: 'Complete a tournament', target: 1, xp: 600, type: 'tournaments' }
        ]
    },
    
    init() {
        this.checkQuestReset();
        CosmeticsManager.init();
    },
    
    save() {
        localStorage.setItem('ec-shard-path', JSON.stringify(this.data));
    },
    
    checkQuestReset() {
        const now = Date.now();
        const lastReset = this.data.questResetTime;
        const oneDayMs = 24 * 60 * 60 * 1000;
        const oneWeekMs = 7 * oneDayMs;
        
        if (now - lastReset > oneDayMs || this.data.dailyQuests.length === 0) {
            this.generateDailyQuests();
        }
        
        if (now - lastReset > oneWeekMs || this.data.weeklyQuests.length === 0) {
            this.generateWeeklyQuests();
        }
    },
    
    generateDailyQuests() {
        const templates = [...this.questTemplates.daily];
        const selected = [];
        for (let i = 0; i < 3 && templates.length > 0; i++) {
            const idx = Math.floor(Math.random() * templates.length);
            const quest = { ...templates.splice(idx, 1)[0], progress: 0, completed: false, claimed: false };
            selected.push(quest);
        }
        this.data.dailyQuests = selected;
        this.data.questResetTime = Date.now();
        this.save();
    },
    
    generateWeeklyQuests() {
        const templates = [...this.questTemplates.weekly];
        const selected = [];
        for (let i = 0; i < 2 && templates.length > 0; i++) {
            const idx = Math.floor(Math.random() * templates.length);
            const quest = { ...templates.splice(idx, 1)[0], progress: 0, completed: false, claimed: false };
            selected.push(quest);
        }
        this.data.weeklyQuests = selected;
        this.save();
    },
    
    addXP(amount, source = 'match') {
        this.data.currentXP += amount;
        
        while (this.data.currentXP >= this.xpPerLevel && this.data.currentLevel < this.data.maxLevel) {
            this.data.currentXP -= this.xpPerLevel;
            this.data.currentLevel++;
        }
        
        this.save();
        return { level: this.data.currentLevel, xp: this.data.currentXP };
    },
    
    recordMatchResult(won, cardsPlayed = [], damageDealt = 0) {
        this.addXP(won ? this.xpPerWin : this.xpPerMatch);
        
        [...this.data.dailyQuests, ...this.data.weeklyQuests].forEach(quest => {
            if (quest.completed) return;
            
            switch (quest.type) {
                case 'matches':
                    quest.progress++;
                    break;
                case 'wins':
                    if (won) quest.progress++;
                    break;
                case 'aspect':
                    const aspectCards = cardsPlayed.filter(c => c.aspects?.includes(quest.aspect));
                    quest.progress += aspectCards.length;
                    break;
                case 'damage':
                    quest.progress += damageDealt;
                    break;
            }
            
            if (quest.progress >= quest.target) {
                quest.completed = true;
            }
        });
        
        this.save();
    },
    
    recordTournamentComplete() {
        this.data.weeklyQuests.forEach(quest => {
            if (quest.type === 'tournaments' && !quest.completed) {
                quest.progress++;
                if (quest.progress >= quest.target) quest.completed = true;
            }
        });
        this.save();
    },
    
    claimQuestReward(questId, isWeekly = false) {
        const questList = isWeekly ? this.data.weeklyQuests : this.data.dailyQuests;
        const quest = questList.find(q => q.id === questId);
        
        if (!quest || !quest.completed || quest.claimed) {
            return { success: false, error: 'Cannot claim this quest' };
        }
        
        quest.claimed = true;
        this.addXP(quest.xp);
        this.save();
        
        return { success: true, xp: quest.xp };
    },
    
    claimReward(level, isPremium = false) {
        const track = isPremium ? 'premium' : 'free';
        
        if (isPremium && !this.data.premiumUnlocked) {
            return { success: false, error: 'Premium track not unlocked' };
        }
        
        if (level > this.data.currentLevel) {
            return { success: false, error: 'Level not reached' };
        }
        
        if (this.data.claimedRewards[track].includes(level)) {
            return { success: false, error: 'Already claimed' };
        }
        
        const rewards = isPremium ? this.rewards.premium : this.rewards.free;
        const reward = rewards.find(r => r.level === level);
        
        if (!reward) {
            return { success: false, error: 'Reward not found' };
        }
        
        this.data.claimedRewards[track].push(level);
        
        if (reward.type === 'currency') {
            this.data.currency += reward.amount;
        } else if (reward.type === 'cosmetic') {
            CosmeticsManager.unlockCosmetic(reward.id);
        }
        
        this.save();
        return { success: true, reward };
    },
    
    unlockPremium() {
        this.data.premiumUnlocked = true;
        this.save();
        return { success: true };
    },
    
    getCurrency() {
        return this.data.currency;
    },
    
    addCurrency(amount) {
        this.data.currency += amount;
        this.save();
    },
    
    spendCurrency(amount) {
        if (this.data.currency < amount) return false;
        this.data.currency -= amount;
        this.save();
        return true;
    },
    
    getProgress() {
        return {
            level: this.data.currentLevel,
            xp: this.data.currentXP,
            xpRequired: this.xpPerLevel,
            percentage: (this.data.currentXP / this.xpPerLevel) * 100,
            premiumUnlocked: this.data.premiumUnlocked,
            seasonName: this.data.seasonName,
            seasonEnd: this.data.seasonEnd,
            currency: this.data.currency
        };
    },
    
    getRewardsAtLevel(level) {
        const free = this.rewards.free.find(r => r.level === level);
        const premium = this.rewards.premium.find(r => r.level === level);
        return { free, premium };
    },
    
    isRewardClaimed(level, isPremium = false) {
        const track = isPremium ? 'premium' : 'free';
        return this.data.claimedRewards[track].includes(level);
    },
    
    resetSeason() {
        this.data.currentXP = 0;
        this.data.currentLevel = 1;
        this.data.seasonNumber++;
        this.data.claimedRewards = { free: [], premium: [] };
        this.data.seasonEnd = Date.now() + (90 * 24 * 60 * 60 * 1000);
        this.data.premiumUnlocked = false;
        this.save();
    }
};

// === ENGINE LOGIC START ===
console.log("Essence Crown IONOS engine: upgraded from engine_src.");
const Game = {
    state: {
        currentPlayer: 0,
        currentPhase: 'dawn',
        turnNumber: 1,
        drawsThisTurn: 0,
        cardsPlayedThisTurn: 0,
        spellsPlayedThisTurn: 0,
        hasAttackedThisGame: false,
        phases: ['dawn', 'draw', 'main', 'clash', 'twilight'],
        phaseNames: { 
            dawn: 'Dawn Phase', 
            draw: 'Draw Phase',
            main: 'Main Phase', 
            clash: 'Clash Phase', 
            twilight: 'Twilight Phase' 
        },
        phaseDescriptions: {
            dawn: 'Upkeep - restore KL, start-of-turn triggers',
            draw: 'Draw one card from your deck',
            main: 'Play cards, activate abilities, change positions',
            clash: 'Declare attacks and resolve combat',
            twilight: 'End-of-turn effects, pass turn'
        },
        rulesHelper: true,
        logVisible: false,
        codexVisible: false,
        zoomCard: null,
        matchMode: 'casual',
        isPrivateMatch: false,
        challengeFriend: null,
        matchId: null,
        isReplayMode: false,
        isSpectatorMode: false,
        sealedDeck: null,
        cardsPlayedThisMatch: [],
        damageDealtThisMatch: 0,
        isSandboxMode: false,
        customLobbySettings: null,
        playerName: 'Player',
        players: [
            {
                essence: 23, klCurrent: 3, klMax: 3, baseKl: 3, currentKl: 3, klThresholdTriggeredThisTurn: false, godCharges: 0, overflow: 0, godCodeCharges: 1, godCodeUsed: false,
                deity: null,
                hand: [],
                deck: [],
                graveyard: [],
                banished: [],
                avatarRow: [],
                domainRow: [],
                relicRow: [],
                shardRow: [],
                spellRow: [],
                passiveUsedThisTurn: false,
                hasDrawnThisTurn: false,
                shards: 0,
                shardSurgeUsedThisTurn: false
            },
            {
                essence: 23, klCurrent: 3, klMax: 3, baseKl: 3, currentKl: 3, klThresholdTriggeredThisTurn: false, godCharges: 0, overflow: 0, godCodeCharges: 1, godCodeUsed: false,
                deity: null,
                hand: [],
                deck: [],
                graveyard: [],
                banished: [],
                avatarRow: [],
                domainRow: [],
                relicRow: [],
                shardRow: [],
                spellRow: [],
                passiveUsedThisTurn: false,
                hasDrawnThisTurn: false,
                shards: 0,
                shardSurgeUsedThisTurn: false
            }
        ],
        selectedDeities: [],
        draggedCard: null,
        contextCard: null,
        cardIdCounter: 0,
        combat: {
            mode: null, // null | 'selectAttacker' | 'selectTarget' | 'declareBlockers' | 'resolving'
            selectedAttacker: null,
            selectedTarget: null,
            attackedThisTurn: [],
            summonedThisTurn: [],
            // === ESSENCE CROWN BATTLE ENGINE UPGRADES ===
            declaredAttackers: [], // Array of {card, targetType: 'deity'|'avatar', targetCard?}
            declaredBlockers: {}, // Map of attackerInstanceId -> blockerCard
            pendingCombatResolution: false,
            tempDamage: {}, // Map of instanceId -> accumulated damage this combat
            domainsPlayedThisTurn: 0, // Track domain plays per turn (limit 1)
            maxDomainsPerTurn: 1
        },
        spell: {
            mode: null,
            pendingSpell: null,
            targetType: null
        },
        shardChain: {
            active: false,
            links: [],
            priority: 0,
            passCount: 0
        },
        previewTimeout: null,
        gameOver: false,
        events: {
            ON_AVATAR_SUMMONED: [],
            ON_AVATAR_DESTROYED: [],
            ON_ATTACK_DECLARED: [],
            ON_ESSENCE_LOSS: [],
            ON_ESSENCE_GAIN: [],
            ON_CARD_DRAWN: [],
            ON_SPELL_CAST: [],
            ON_DEITY_ABILITY_USED: [],
            ON_TURN_START: [],
            ON_TURN_END: [],
            ON_PHASE_CHANGE: []
        }
    },

    init() {
        console.log('Initializing Essence Crown TCG...');
        AccessibilitySettings.init();
        EventManager.init();
        LimitedMode.init();
        ShardPath.init();
        CosmeticsManager.init();
        this.bindEvents();
        MainMenu.init();
        this.initAccessibilityUI();
    },
    
    initAccessibilityUI() {
        const textSize = document.getElementById('opt-text-size');
        const colorblind = document.getElementById('opt-colorblind');
        const lowFx = document.getElementById('opt-low-fx');
        const highContrast = document.getElementById('opt-high-contrast');
        const reduceMotion = document.getElementById('opt-reduce-motion');
        
        if (textSize) {
            textSize.value = AccessibilitySettings.get('textSize');
            textSize.onchange = () => AccessibilitySettings.set('textSize', textSize.value);
        }
        if (colorblind) {
            colorblind.value = AccessibilitySettings.get('colorblindMode');
            colorblind.onchange = () => AccessibilitySettings.set('colorblindMode', colorblind.value);
        }
        if (lowFx) {
            lowFx.classList.toggle('active', AccessibilitySettings.get('lowFxMode'));
            lowFx.onclick = () => {
                lowFx.classList.toggle('active');
                AccessibilitySettings.set('lowFxMode', lowFx.classList.contains('active'));
            };
        }
        if (highContrast) {
            highContrast.classList.toggle('active', AccessibilitySettings.get('highContrast'));
            highContrast.onclick = () => {
                highContrast.classList.toggle('active');
                AccessibilitySettings.set('highContrast', highContrast.classList.contains('active'));
            };
        }
        if (reduceMotion) {
            reduceMotion.classList.toggle('active', AccessibilitySettings.get('reduceMotion'));
            reduceMotion.onclick = () => {
                reduceMotion.classList.toggle('active');
                AccessibilitySettings.set('reduceMotion', reduceMotion.classList.contains('active'));
            };
        }
        
        const cardSearch = document.getElementById('sandbox-card-search');
        if (cardSearch) {
            cardSearch.oninput = () => this.searchSandboxCards(cardSearch.value);
        }
        
        const victorySelect = document.getElementById('lobby-victory');
        if (victorySelect) {
            victorySelect.onchange = () => {
                const avatarRow = document.getElementById('lobby-avatar-count-row');
                if (avatarRow) {
                    avatarRow.style.display = victorySelect.value === 'avatars' ? 'flex' : 'none';
                }
            };
        }
    },

    bindEvents() {
        const btnFullscreen = document.getElementById('btn-fullscreen');
        const btnSkip = document.getElementById('btn-skip-fullscreen');
        const btnQuickPlay = document.getElementById('btn-quick-play');
        
        if (btnFullscreen) btnFullscreen.onclick = () => this.requestFullscreen();
        if (btnSkip) btnSkip.onclick = () => this.hideFullscreenPrompt();
        if (btnQuickPlay) {
            btnQuickPlay.onclick = () => {
                document.getElementById('fullscreen-prompt')?.classList.add('hidden');
                this.state.matchMode = 'casual';
                this.showDeitySelection(0);
            };
        }
        
        const nextPhaseBtn = document.getElementById('btn-next-phase');
        const endTurnBtn = document.getElementById('btn-end-turn');
        const rulesBtn = document.getElementById('btn-rules-helper');
        const logBtn = document.getElementById('btn-log');
        const codexBtn = document.getElementById('btn-codex');
        const replaysBtn = document.getElementById('btn-replays');
        const spectateBtn = document.getElementById('btn-spectate');

        const turnControls = document.getElementById('turn-controls');
        if (turnControls && !document.getElementById('btn-shard-surge')) {
            const shardBtn = document.createElement('button');
            shardBtn.className = 'turn-btn';
            shardBtn.id = 'btn-shard-surge';
            shardBtn.textContent = 'Shard Surge (Draw 1)';
            turnControls.insertBefore(shardBtn, endTurnBtn ? endTurnBtn.nextSibling : null);
        }

        const shardSurgeBtn = document.getElementById('btn-shard-surge');

        if (nextPhaseBtn) nextPhaseBtn.onclick = () => this.nextPhase();
        if (endTurnBtn) endTurnBtn.onclick = () => this.endTurn();
        if (rulesBtn) rulesBtn.onclick = () => this.toggleRulesHelper();
        if (logBtn) logBtn.onclick = () => this.toggleLog();
        if (codexBtn) codexBtn.onclick = () => this.toggleCodex();
        if (replaysBtn) replaysBtn.onclick = () => this.showReplayBrowser();
        if (spectateBtn) spectateBtn.onclick = () => this.showSpectateBrowser();
        if (shardSurgeBtn) shardSurgeBtn.onclick = () => this.activateShardSurge();
        
        document.querySelectorAll('.codex-tab').forEach(tab => {
            tab.onclick = () => this.switchCodexTab(tab.dataset.tab);
        });
        
        document.querySelectorAll('.mobile-tab').forEach(tab => {
            tab.onclick = () => this.switchMobilePanel(tab.dataset.panel);
        });
        
        const p1Life = document.getElementById('p1-life-badge');
        const p2Life = document.getElementById('p2-life-badge');
        const p1Kl = document.getElementById('p1-kl-badge');
        const p2Kl = document.getElementById('p2-kl-badge');
        
        if (p1Life) {
            p1Life.onclick = () => this.adjustStat(0, 'essence', -1);
            p1Life.oncontextmenu = (e) => { e.preventDefault(); this.adjustStat(0, 'essence', 1); };
        }
        if (p2Life) {
            p2Life.onclick = () => this.adjustStat(1, 'essence', -1);
            p2Life.oncontextmenu = (e) => { e.preventDefault(); this.adjustStat(1, 'essence', 1); };
        }
        if (p1Kl) {
            p1Kl.onclick = () => this.adjustStat(0, 'kl', -1);
            p1Kl.oncontextmenu = (e) => { e.preventDefault(); this.adjustStat(0, 'kl', 1); };
        }
        if (p2Kl) {
            p2Kl.onclick = () => this.adjustStat(1, 'kl', -1);
            p2Kl.oncontextmenu = (e) => { e.preventDefault(); this.adjustStat(1, 'kl', 1); };
        }

        const p1Deck = document.getElementById('p1-deck');
        const p2Deck = document.getElementById('p2-deck');
        const p1Graveyard = document.getElementById('p1-graveyard');
        const p2Graveyard = document.getElementById('p2-graveyard');
        
        if (p1Deck) p1Deck.onclick = () => this.drawCard(0);
        if (p2Deck) p2Deck.onclick = () => this.drawCard(1);
        if (p1Graveyard) p1Graveyard.onclick = () => this.viewPile(0, 'graveyard');
        if (p2Graveyard) p2Graveyard.onclick = () => this.viewPile(1, 'graveyard');

        document.querySelectorAll('#context-menu .context-option').forEach(item => {
            item.onclick = () => this.handleContextAction(item.dataset.action);
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('#context-menu')) {
                this.hideContextMenu();
            }
        });
    },

    showDeitySelection(playerIndex) {
        const overlay = document.getElementById('deity-select-overlay');
        const grid = document.getElementById('deity-grid');
        const title = document.getElementById('deity-select-title');
        
        overlay.classList.remove('hidden');
        title.textContent = `SELECT PLAYER ${playerIndex + 1} DEITY`;
        grid.innerHTML = '';

        const deities = getDeities();
        
        deities.forEach(deity => {
            const aspectText = deity.aspects ? deity.aspects.join(' / ') : 'Unknown';
            const option = document.createElement('div');
            option.className = 'deity-option';
            option.innerHTML = `
                <img src="${deity.image}" alt="${deity.name}">
                <div class="deity-name">
                    <h3>${deity.name}</h3>
                    <p>${aspectText} Deity</p>
                    <p class="deity-stats">Essence: ${deity.health} | KL: ${deity.startingKL || 3}</p>
                </div>
                <button class="select-btn">SELECT</button>
            `;
            option.onclick = () => this.selectDeity(deity, playerIndex);
            grid.appendChild(option);
        });
    },

    selectDeity(deity, playerIndex) {
        this.state.selectedDeities[playerIndex] = deity;
        
        if (playerIndex === 0) {
            if (this.state.isAIMatch) {
                AIManager.selectAIDeity();
                document.getElementById('deity-select-overlay').classList.add('hidden');
                this.startGameWithMatchMode();
            } else {
                this.showDeitySelection(1);
            }
        } else {
            document.getElementById('deity-select-overlay').classList.add('hidden');
            this.startGameWithMatchMode();
        }
    },
    
    cancelDeitySelection() {
        document.getElementById('deity-select-overlay').classList.add('hidden');
        this.state.selectedDeities = [];
        this.state.isAIMatch = false;
        this.state.matchMode = null;
        MainMenu.back();
    },
    
    async startGameWithMatchMode() {
        const p1Deity = this.state.selectedDeities[0];
        const p2Deity = this.state.selectedDeities[1];
        const opponentName = this.state.isAIMatch ? 'AI Opponent' : (this.state.challengeFriend || 'Opponent');
        
        await MatchIntro.show(PlayerProfile.data.name, opponentName, p1Deity, p2Deity);
        
        this.startGame();
        if (this.state.isPrivateMatch) {
            this.log(`PRIVATE MATCH vs ${this.state.challengeFriend}`, 'phase');
        } else {
            this.log(`${this.state.matchMode === 'ranked' ? 'RANKED' : 'CASUAL'} Match Started`, 'phase');
        }
    },

    startGame() {
        document.getElementById('game-container').style.display = '';
        document.getElementById('game-controls').style.display = 'flex';
        const matchId = 'match-' + Date.now() + '-' + Math.random().toString(36).substr(2, 6);
        this.state.matchId = matchId;
        
        if (this.state.matchMode === 'campaign') {
            AudioManager.play('campaign');
        } else {
            AudioManager.play('battle');
        }
        
        MatchRecorder.startRecording(
            matchId,
            this.state.players[0].deity,
            this.state.players[1].deity,
            this.state.matchMode
        );
        
        MatchRecorder.registerLiveMatch(matchId, {
            player1Deity: this.state.players[0].deity?.name || 'Unknown',
            player2Deity: this.state.players[1].deity?.name || 'Unknown',
            matchMode: this.state.matchMode
        });
        
        let mainDeck = ALL_CARDS.filter(c => c.type !== 'Deity');
        
        if (EventManager.activeEvent) {
            mainDeck = mainDeck.filter(c => EventManager.isCardAllowed(c));
            this.log(`Event: ${EventManager.activeEvent.name}`, 'phase');
        }
        
        const useSealedDeck = this.state.matchMode === 'sealed' && this.state.sealedDeck;
        if (useSealedDeck) {
            this.log('SEALED MODE: Using sealed deck', 'phase');
        }
        
        if (this.state.matchMode === 'custom' && this.state.customLobbySettings) {
            const settings = this.state.customLobbySettings;
            mainDeck = mainDeck.filter(c => CustomLobby.isCardAllowed(c, settings));
            this.log(`Custom Rules: ${settings.name}`, 'phase');
        }
        
        for (let p = 0; p < 2; p++) {
            const deity = this.state.selectedDeities[p];
            let startingKL = deity.startingKL || 3;
            let startingEssence = deity.health || 23;
            
            if (EventManager.activeEvent) {
                startingEssence = EventManager.getStartingEssence();
                startingKL = EventManager.getStartingKL();
            }
            
            if (this.state.matchMode === 'custom' && this.state.customLobbySettings) {
                startingEssence = this.state.customLobbySettings.startingEssence;
                startingKL = this.state.customLobbySettings.startingKL;
            }
            
            this.state.players[p].deity = this.createCardInstance(deity);
            this.state.players[p].essence = startingEssence;
            this.state.players[p].klMax = startingKL;
            this.state.players[p].klCurrent = startingKL;
            this.state.players[p].baseKl = startingKL;
            this.state.players[p].currentKl = startingKL;
            this.state.players[p].klThresholdTriggeredThisTurn = false;
            this.state.players[p].godCharges = 0;
            this.state.players[p].shardRow = [];
            this.state.players[p].overflow = 0;
            this.state.players[p].godCodeCharges = 1;
            this.state.players[p].godCodeUsed = false;
            this.state.players[p].shards = 0;
            this.state.players[p].shardSurgeUsedThisTurn = false;
            
            if (useSealedDeck && p === 0) {
                this.state.players[p].deck = this.state.sealedDeck.map(c => this.createCardInstance(c));
            } else if (this.state.matchMode === 'campaign' && p === 1 && this.state.bossDeck && this.state.bossDeck.length > 0) {
                const bossDeckCards = [];
                for (const cardId of this.state.bossDeck) {
                    const cardTemplate = ALL_CARDS.find(c => c.id === cardId);
                    if (cardTemplate) {
                        bossDeckCards.push(this.createCardInstance(cardTemplate));
                    }
                }
                while (bossDeckCards.length < 30 && mainDeck.length > 0) {
                    const randomCard = mainDeck[Math.floor(Math.random() * mainDeck.length)];
                    bossDeckCards.push(this.createCardInstance(randomCard));
                }
                this.state.players[p].deck = bossDeckCards;
                console.log('Campaign: Loaded boss deck with', bossDeckCards.length, 'cards');
            } else {
                this.state.players[p].deck = mainDeck.map(c => this.createCardInstance(c));
            }
            this.shuffleDeck(p);
            MatchRecorder.recordDeckContents(p, this.state.players[p].deck);
            
            this.log(`${deity.name}: ${startingEssence} Essence, ${startingKL} KL`, 'action');
        }

        this.drawCard(0, 5);
        this.drawCard(1, 5);
        
        // Start battle ambience effects
        BattleEffects.startBattleAmbience();
        
        // Epic match start effect
        BattleEffects.screenFlash('#d4af3755', 300);
        BattleEffects.turnTransition('Player', true);
        
        this.setPhase('dawn');
        this.log('Game started! Shard Wars begin!', 'phase');
        MatchRecorder.recordAction('TURN_START', { turn: 1, player: 0 }, 0);
        this.render();
    },

    recalculateKl(player) {
        const base = player.baseKl ?? player.klMax ?? player.klCurrent ?? 0;
        const shardBonus = Array.isArray(player.shardRow) ? player.shardRow.length : 0;
        let kl = base + shardBonus;
        if (kl > 31) kl = 31;
        if (kl < 0) kl = 0;
        return kl;
    },

    checkGodThreshold(player, oldKl, newKl) {
        const alreadyTriggered = player.klThresholdTriggeredThisTurn;
        const crossed = oldKl < 13 && newKl >= 13;
        if (alreadyTriggered || !crossed) return;
        if (player.godCharges === undefined) player.godCharges = player.godCodeCharges ?? 0;
        if (player.godCharges < 3) {
            player.godCharges += 1;
        }
        player.klThresholdTriggeredThisTurn = true;
    },

    readyAllPermanents(player) {
        const zones = [player.avatarRow, player.domainRow, player.relicRow, player.shardRow];
        zones.forEach(zone => {
            if (!zone) return;
            if (Array.isArray(zone)) {
                zone.forEach(card => { card.tapped = false; });
            }
        });
    },

    createCardInstance(template) {
        return {
            ...template,
            instanceId: ++this.state.cardIdCounter,
            healthCurrent: template.health || 0,
            tapped: false,
            faceDown: false
        };
    },

    setPhase(phase) {
        this.state.currentPhase = phase;
        document.getElementById('phase-name').textContent = this.state.phaseNames[phase];
        document.getElementById('turn-number').textContent = `Turn ${this.state.turnNumber}`;
        this.log(`Phase: ${this.state.phaseNames[phase]}`, 'phase');

        // Cinematic phase transition effect
        if (phase === 'clash') {
            BattleEffects.phaseTransition(this.state.phaseNames[phase]);
        }

        // ===== ENFORCE CORE GAME RULES (ALWAYS) =====
        if (phase === 'dawn') {
            this.handleDawnPhase();
        } else if (phase === 'draw') {
            this.handleDrawPhase();
        }
        
        this.updatePhaseTracker();
        this.highlightLegalPlays();
        
        // === PHASE HINTS: Show contextual tips for player ===
        if (this.state.currentPlayer === 0 && !this.state.isAIMatch) {
            this.showPhaseHint(phase);
        } else if (this.state.currentPlayer === 0) {
            this.showPhaseHint(phase);
        }
        
    },
    
    showPhaseHint(phase) {
        const hints = {
            dawn: "Dawn Phase: Your cards untap and start-of-turn effects trigger.",
            draw: "Draw Phase: Drawing a card from your deck...",
            main: "Main Phase: Play Domains, summon Avatars, and cast Spells. Click 'Next Phase' when ready to attack.",
            clash: "Clash Phase: Click your Avatars to attack! Target the enemy Deity or their Avatars.",
            twilight: "Twilight Phase: End-of-turn effects resolve. Hand limit: 7 cards."
        };
        
        const hint = hints[phase];
        if (hint && this.state.currentPlayer === 0) {
            this.showPrompt(hint);
            setTimeout(() => this.hidePrompt(), 4000);
        }
    },
    
    handleDrawPhase() {
        const playerIndex = this.state.currentPlayer;
        const p = this.state.players[playerIndex];
        
        // First player skips draw on turn 1 (first turn starting advantage)
        if (this.state.turnNumber === 1 && playerIndex === 0) {
            this.log('First player skips draw on turn 1', 'phase');
            return;
        }
        
        // === ESSENCE CROWN: Mandatory draw at start of turn ===
        // Draw 1 card from deck (mandatory - deck-out causes loss)
        if (!p.hasDrawnThisTurn) {
            this.drawCard(playerIndex, 1, true); // isMandatory = true
            p.hasDrawnThisTurn = true;
        }
    },
    
    updatePhaseTracker() {
        const tracker = document.getElementById('phase-tracker');
        if (!tracker) return;
        
        const phases = this.state.phases;
        tracker.innerHTML = phases.map(phase => {
            const isCurrent = phase === this.state.currentPhase;
            return `
                <div class="phase-step ${isCurrent ? 'active' : ''}" data-phase="${phase}">
                    <div class="phase-icon">${this.getPhaseIcon(phase)}</div>
                    <div class="phase-label">${this.state.phaseNames[phase].replace(' Phase', '')}</div>
                </div>
            `;
        }).join('');
    },
    
    getPhaseIcon(phase) {
        const icons = {
            dawn: '‚òÄ',
            draw: 'üÉè',
            main: '‚öî',
            clash: 'üí•',
            twilight: 'üåô'
        };
        return icons[phase] || '‚óã';
    },

    nextPhase() {
        if (this.state.isReplayMode || this.state.isSpectatorMode) return;
        const phases = this.state.phases;
        const currentIndex = phases.indexOf(this.state.currentPhase);
        const nextIndex = (currentIndex + 1) % phases.length;
        
        if (nextIndex === 0) {
            this.endTurn();
        } else {
            this.setPhase(phases[nextIndex]);
        }
    },

    endTurn() {
        if (this.state.isReplayMode || this.state.isSpectatorMode) return;
        MatchRecorder.recordAction('TURN_END', { turn: this.state.turnNumber, player: this.state.currentPlayer }, this.state.currentPlayer);
        this.handleEndTurnPassives(this.state.currentPlayer);
        
        // === ESSENCE CROWN: Enforce hand size limit (default 7) ===
        this.enforceHandSizeLimit(this.state.currentPlayer);
        
        this.state.currentPlayer = 1 - this.state.currentPlayer;
        this.state.turnNumber++;
        this.state.drawsThisTurn = 0;
        this.state.cardsPlayedThisTurn = 0;
        this.state.spellsPlayedThisTurn = 0;
        this.state.players[0].passiveUsedThisTurn = false;
        this.state.players[1].passiveUsedThisTurn = false;
        this.state.players[0].hasDrawnThisTurn = false;
        this.state.players[1].hasDrawnThisTurn = false;
        this.state.combat.attackedThisTurn = [];
        this.state.combat.summonedThisTurn = [];
        this.state.combat.mode = null;
        this.state.combat.selectedAttacker = null;
        this.state.combat.selectedTarget = null;
        // === ESSENCE CROWN: Reset new combat state ===
        this.state.combat.declaredAttackers = [];
        this.state.combat.declaredBlockers = {};
        this.state.combat.tempDamage = {};
        this.state.combat.domainsPlayedThisTurn = 0;
        
        BattleEffects.turnTransition(
            this.state.currentPlayer === 0 ? 'Player' : 'Opponent',
            this.state.currentPlayer === 0
        );
        
        this.setPhase('dawn');
        this.log(`Player ${this.state.currentPlayer + 1}'s turn`, 'phase');
        MatchRecorder.recordAction('TURN_START', { turn: this.state.turnNumber, player: this.state.currentPlayer }, this.state.currentPlayer);
        
        if (this.state.matchMode === 'campaign' && this.state.currentPlayer === 1) {
            CampaignManager.applyBossAbility('turn', { turn: this.state.turnNumber });
            if (Math.random() < 0.25) {
                setTimeout(() => CampaignManager.showBossTaunt(), 500);
            }
        }
        
        if (this.state.currentPlayer === 1) {
            if (this.state.isAIMatch) {
                setTimeout(() => AIManager.takeTurn(), 1000);
            } else {
                setTimeout(() => this.runAI(), 1500);
            }
        }
    },
    
    // ==================== ESSENCE CROWN BATTLE ENGINE HELPERS ====================
    // These functions implement the core TCG battle rules per the Essence Crown ruleset
    
    /**
     * Enforce hand size limit at end of turn (default 7 cards)
     * If player has more than limit, discard down to limit
     */
    enforceHandSizeLimit(playerIndex, limit = 7) {
        const player = this.state.players[playerIndex];
        if (player.hand.length > limit) {
            const discardCount = player.hand.length - limit;
            // AI auto-discards lowest value cards, player would get a prompt
            if (playerIndex === 1) {
                // AI: discard highest cost cards first (usually least useful when full hand)
                player.hand.sort((a, b) => (b.cost || 0) - (a.cost || 0));
                for (let i = 0; i < discardCount; i++) {
                    const discarded = player.hand.shift();
                    player.graveyard.push(discarded);
                    this.log(`Opponent discarded ${discarded.name} (hand limit)`, 'action');
                }
            } else {
                // TODO: Player gets to choose what to discard via UI
                // For now, auto-discard oldest cards
                for (let i = 0; i < discardCount; i++) {
                    const discarded = player.hand.pop();
                    player.graveyard.push(discarded);
                    this.log(`Discarded ${discarded.name} (hand limit: ${limit})`, 'action');
                }
            }
            this.render();
        }
    },
    
    /**
     * Check if a Domain can be played this turn
     * Returns true if player hasn't hit domain limit
     */
    canPlayDomain(playerIndex) {
        const domainsPlayed = this.state.combat.domainsPlayedThisTurn;
        const limit = this.state.combat.maxDomainsPerTurn;
        return domainsPlayed < limit;
    },
    
    /**
     * Track domain play for the turn
     * Called when a Domain card is successfully played
     */
    recordDomainPlay() {
        this.state.combat.domainsPlayedThisTurn++;
    },
    
    /**
     * Check if an Avatar has summoning sickness
     * Returns true if the avatar was summoned this turn
     */
    hasSummoningSickness(card) {
        // Cards with Haste/Swift can attack immediately
        if (hasHaste(card)) {
            return false;
        }
        return this.state.combat.summonedThisTurn.includes(card.instanceId);
    },
    
    /**
     * Get all valid attackers for the current player
     * Returns avatars that are untapped, not summoned this turn, and haven't attacked
     */
    getValidAttackers(playerIndex) {
        const player = this.state.players[playerIndex];
        return player.avatarRow.filter(card => 
            !card.tapped &&
            !this.state.combat.attackedThisTurn.includes(card.instanceId) &&
            !this.hasSummoningSickness(card)
        );
    },
    
    /**
     * Get all valid blockers for defending player
     * Returns untapped avatars that can block
     */
    getValidBlockers(playerIndex) {
        const player = this.state.players[playerIndex];
        return player.avatarRow.filter(card => 
            !card.tapped &&
            !card.cantBlock // Support for "cannot block" effects
        );
    },
    
    /**
     * Calculate combat damage using Power vs Guard (attack vs health)
     * Attacker deals its Power to defender's Guard
     * Returns the damage that would be dealt
     */
    calculateCombatDamage(attacker, defender) {
        const attackerPower = attacker.attack || 0;
        const defenderPower = defender.attack || 0;
        return {
            damageToDefender: attackerPower,
            damageToAttacker: defenderPower
        };
    },
    
    /**
     * Apply temporary damage to a card during combat
     * Damage accumulates until combat resolution completes
     */
    applyTempDamage(card, damage) {
        if (!this.state.combat.tempDamage[card.instanceId]) {
            this.state.combat.tempDamage[card.instanceId] = 0;
        }
        this.state.combat.tempDamage[card.instanceId] += damage;
    },
    
    /**
     * Get current health of a card (accounting for temp damage)
     */
    getEffectiveHealth(card) {
        const baseHealth = card.healthCurrent !== undefined ? card.healthCurrent : (card.health || 0);
        const tempDamage = this.state.combat.tempDamage[card.instanceId] || 0;
        return baseHealth - tempDamage;
    },
    
    /**
     * Check if a card should be destroyed (temp damage >= health)
     */
    shouldBeDestroyed(card) {
        return this.getEffectiveHealth(card) <= 0;
    },
    
    /**
     * Finalize combat damage - apply temp damage permanently and destroy dead cards
     */
    finalizeCombatDamage() {
        const toDestroy = [];
        
        // Apply temp damage to all cards
        for (const [instanceId, damage] of Object.entries(this.state.combat.tempDamage)) {
            // Find the card across all players
            for (let p = 0; p < 2; p++) {
                const player = this.state.players[p];
                const card = player.avatarRow.find(c => c.instanceId === parseInt(instanceId));
                if (card) {
                    card.healthCurrent = (card.healthCurrent !== undefined ? card.healthCurrent : card.health) - damage;
                    if (card.healthCurrent <= 0) {
                        toDestroy.push({ card, playerIndex: p });
                    }
                }
            }
        }
        
        // Destroy dead cards
        for (const { card, playerIndex } of toDestroy) {
            this.destroyCard(card, playerIndex);
        }
        
        // Clear temp damage
        this.state.combat.tempDamage = {};
    },
    
    /**
     * Destroy a card and move it to graveyard
     */
    destroyCard(card, playerIndex) {
        const player = this.state.players[playerIndex];
        const index = player.avatarRow.findIndex(c => c.instanceId === card.instanceId);
        if (index !== -1) {
            player.avatarRow.splice(index, 1);
            player.graveyard.push(card);
            this.log(`${card.name} was destroyed!`, 'damage');
            this.handleOnDeathTrigger(card, playerIndex);
            
            // Visual effect
            const cardEl = document.querySelector(`[data-instance-id="${card.instanceId}"]`);
            if (cardEl) {
                cardEl.classList.add('ec-destroy-anim');
            }
        }
    },
    
    /**
     * Deal damage directly to player's Essence
     */
    dealDamageToEssence(playerIndex, damage) {
        this.adjustStat(playerIndex, 'essence', -damage);
        this.log(`Player ${playerIndex + 1} takes ${damage} Essence damage!`, 'damage');
        this.spawnDamageNumber(playerIndex === 0 ? 'p1-deity' : 'p2-deity', damage);
        this.screenShake(damage >= 3 ? 'heavy' : 'light');
        this.checkWinCondition();
    },
    
    // ==================== STRATEGIC AI SYSTEM ====================
    
    // Evaluate board state advantage (-100 to +100, positive = AI winning)
    aiEvaluateBoard() {
        const ai = this.state.players[1];
        const player = this.state.players[0];
        let score = 0;
        
        // Essence advantage (most important)
        score += (ai.essence - player.essence) * 3;
        
        // Board presence
        const aiBoardPower = ai.avatarRow.reduce((sum, c) => sum + (c.attack || 0) + (c.currentHealth || c.health || 0), 0);
        const playerBoardPower = player.avatarRow.reduce((sum, c) => sum + (c.attack || 0) + (c.currentHealth || c.health || 0), 0);
        score += (aiBoardPower - playerBoardPower) * 1.5;
        
        // Card advantage
        score += (ai.hand.length - player.hand.length) * 2;
        
        // KL advantage
        score += (ai.klCurrent - player.klCurrent) * 0.5;
        
        // Domain bonuses
        score += ai.domainRow.filter(c => c.type === 'Domain').length * 3;
        score -= player.domainRow.filter(c => c.type === 'Domain').length * 3;
        
        return Math.max(-100, Math.min(100, score));
    },
    
    // Get dominant aspect on AI's board
    aiGetDominantAspect() {
        const ai = this.state.players[1];
        const aspects = { Glow: 0, Void: 0, Gray: 0 };
        
        [...ai.avatarRow, ...ai.domainRow].forEach(card => {
            if (card.aspects) {
                card.aspects.forEach(a => {
                    if (aspects[a] !== undefined) aspects[a]++;
                });
            } else if (card.aspect) {
                if (aspects[card.aspect] !== undefined) aspects[card.aspect]++;
            }
        });
        
        // Include deity aspect preference
        if (ai.deity) {
            if (ai.deity.name.includes('Solara') || ai.deity.name.includes('Radiance')) aspects.Glow += 2;
            if (ai.deity.name.includes('Nyx') || ai.deity.name.includes('Void')) aspects.Void += 2;
            if (ai.deity.name.includes('Arbiter') || ai.deity.name.includes('Chronicler')) aspects.Gray += 2;
        }
        
        const max = Math.max(aspects.Glow, aspects.Void, aspects.Gray);
        if (max === 0) return null;
        return Object.keys(aspects).find(k => aspects[k] === max);
    },
    
    // Score a card for playing based on strategic value
    aiScoreCard(card) {
        const ai = this.state.players[1];
        const player = this.state.players[0];
        let score = 0;
        
        // Base value from stats
        if (card.type === 'Avatar') {
            score += (card.attack || 0) * 2;
            score += (card.health || 0) * 1.5;
            
            // Guardian is valuable when we need defense
            if (hasGuardian(card)) {
                score += ai.essence < 10 ? 15 : 5;
            }
            
            // Beast synergy
            if (card.effect && card.effect.toLowerCase().includes('beast')) {
                const beastCount = ai.avatarRow.filter(c => c.effect && c.effect.toLowerCase().includes('beast')).length;
                score += beastCount * 3;
            }
        }
        
        // Spell effectiveness
        if (card.type === 'Spell') {
            // Damage spells more valuable when opponent has threats
            if (card.effect && (card.effect.includes('damage') || card.effect.includes('destroy'))) {
                score += player.avatarRow.length * 5;
            }
            // Healing spells more valuable at low Essence
            if (card.effect && (card.effect.includes('Essence') || card.effect.includes('heal'))) {
                score += ai.essence < 10 ? 15 : 3;
            }
            // Draw spells always good
            if (card.effect && card.effect.includes('draw')) {
                score += 8;
            }
        }
        
        // Domain cards provide ongoing value
        if (card.type === 'Domain') {
            score += 12;
            // More valuable early game
            if (this.state.turnNumber < 5) score += 5;
        }
        
        // Aspect synergy bonus
        const dominantAspect = this.aiGetDominantAspect();
        if (dominantAspect) {
            const cardAspects = card.aspects || (card.aspect ? [card.aspect] : []);
            if (cardAspects.includes(dominantAspect)) {
                score += 8; // Strong synergy bonus
            }
        }
        
        // Curve consideration - prefer efficient plays
        const efficiency = (card.attack || 0) + (card.health || 0) - card.cost;
        score += efficiency * 0.5;
        
        // Threat response - boost removal when facing big threats
        const bigThreats = player.avatarRow.filter(c => (c.attack || 0) >= 4);
        if (bigThreats.length > 0 && card.effect && card.effect.toLowerCase().includes('destroy')) {
            score += 10;
        }
        
        return score;
    },
    
    // Determine optimal attack target for an attacker
    aiSelectBestTarget(attacker) {
        const player = this.state.players[0];
        const guardians = this.getGuardians(0);
        
        // LETHAL CHECK: If we can kill opponent this turn, go face immediately!
        if (guardians.length === 0 && attacker.attack >= player.essence) {
            return { type: 'deity', playerIndex: 0 };
        }
        
        // Must attack guardians first
        if (guardians.length > 0) {
            // Pick the guardian we can kill or trade best with
            return guardians.sort((a, b) => {
                const aCanKill = attacker.attack >= (a.currentHealth || a.health);
                const bCanKill = attacker.attack >= (b.currentHealth || b.health);
                if (aCanKill && !bCanKill) return -1;
                if (!aCanKill && bCanKill) return 1;
                // Prefer lower health targets
                return (a.currentHealth || a.health) - (b.currentHealth || b.health);
            })[0];
        }
        
        // No guardians - evaluate all targets
        if (player.avatarRow.length === 0) {
            // Go face!
            return { type: 'deity', playerIndex: 0 };
        }
        
        // Score each potential target
        const scoredTargets = player.avatarRow.map(target => {
            let score = 0;
            const targetHealth = target.currentHealth || target.health;
            const canKill = attacker.attack >= targetHealth;
            const willDie = target.attack >= (attacker.currentHealth || attacker.health);
            
            // Prefer killing without dying
            if (canKill && !willDie) score += 30;
            // Good trades (we kill, they kill)
            else if (canKill && willDie) {
                // Compare card values
                const attackerValue = (attacker.attack || 0) + (attacker.health || 0);
                const targetValue = (target.attack || 0) + (target.health || 0);
                if (targetValue >= attackerValue) score += 15; // Good trade
            }
            // We can kill their big threat
            else if (canKill) score += 20;
            
            // Prioritize high-attack threats
            score += (target.attack || 0) * 2;
            
            // Bonus for removing cards with dangerous effects
            if (target.effect && (target.effect.includes('damage') || target.effect.includes('destroy'))) {
                score += 10;
            }
            
            return { target, score };
        });
        
        // Consider going face - higher priority when opponent is low on Essence
        const faceScore = player.essence <= attacker.attack ? 100 :  // Lethal!
                         player.essence <= 5 ? 35 :                    // Very low
                         player.essence <= 10 ? 20 : 5;                // Normal
        scoredTargets.push({ target: { type: 'deity', playerIndex: 0 }, score: faceScore });
        
        // Return best target
        scoredTargets.sort((a, b) => b.score - a.score);
        return scoredTargets[0].target;
    },
    
    // Main AI turn logic with strategic decision-making
    runAI() {
        const ai = this.state.players[1];
        const boardAdvantage = this.aiEvaluateBoard();
        
        this.log('Opponent is strategizing...', 'phase');
        
        // Determine play style based on board state
        const playStyle = boardAdvantage > 20 ? 'aggressive' : 
                         boardAdvantage < -20 ? 'defensive' : 'balanced';
        
        setTimeout(() => {
            // Play multiple cards if possible (up to 3 per turn for realism)
            let cardsPlayed = 0;
            const maxCardsPerTurn = 3;
            
            const playNextCard = () => {
                if (cardsPlayed >= maxCardsPerTurn || ai.klCurrent <= 0) {
                    // Move to combat phase
                    this.aiContinueToCombat();
                    return;
                }
                
                const playableCards = ai.hand.filter(c => c.cost <= ai.klCurrent);
                if (playableCards.length === 0) {
                    this.aiContinueToCombat();
                    return;
                }
                
                // Score all playable cards
                const scoredCards = playableCards.map(card => ({
                    card,
                    score: this.aiScoreCard(card)
                }));
                
                // Adjust scores based on play style
                if (playStyle === 'aggressive') {
                    scoredCards.forEach(sc => {
                        if (sc.card.type === 'Avatar' && (sc.card.attack || 0) >= 3) sc.score += 5;
                    });
                } else if (playStyle === 'defensive') {
                    scoredCards.forEach(sc => {
                        if (hasGuardian(sc.card)) sc.score += 10;
                        if (sc.card.effect && sc.card.effect.includes('heal')) sc.score += 5;
                    });
                }
                
                // Sort by score and play best card
                scoredCards.sort((a, b) => b.score - a.score);
                
                if (scoredCards.length > 0 && scoredCards[0].score > 0) {
                    this.aiPlayCard(scoredCards[0].card);
                    cardsPlayed++;
                    
                    // Delay between card plays for visual effect
                    setTimeout(playNextCard, 800);
                } else {
                    this.aiContinueToCombat();
                }
            };
            
            playNextCard();
        }, 800);
    },
    
    aiContinueToCombat() {
        setTimeout(() => {
            this.setPhase('clash');
            
            setTimeout(() => {
                this.aiStrategicAttack();
                
                setTimeout(() => {
                    this.log('Opponent ends turn', 'phase');
                    this.endTurn();
                }, 1000);
            }, 1000);
        }, 600);
    },
    
    // Strategic attack with all available attackers
    aiStrategicAttack() {
        const ai = this.state.players[1];
        
        const availableAttackers = ai.avatarRow.filter(c => 
            !this.state.combat.attackedThisTurn.includes(c.instanceId) &&
            !this.state.combat.summonedThisTurn.includes(c.instanceId) &&
            !c.tapped &&
            (c.attack || 0) > 0
        );
        
        if (availableAttackers.length === 0) return;
        
        // Sort attackers by attack power (strongest first for maximum pressure)
        availableAttackers.sort((a, b) => (b.attack || 0) - (a.attack || 0));
        
        // Execute attacks sequentially
        const executeAttack = (index) => {
            if (index >= availableAttackers.length) return;
            
            const attacker = availableAttackers[index];
            
            // Re-check if attacker is still valid (may have been destroyed)
            if (!ai.avatarRow.includes(attacker)) {
                executeAttack(index + 1);
                return;
            }
            
            const target = this.aiSelectBestTarget(attacker);
            
            this.log(`${attacker.name} attacks ${target.type === 'deity' ? 'the enemy Deity' : target.name}!`, 'damage');
            MatchRecorder.recordAction('ATTACK', { attackerId: attacker.id, attackerName: attacker.name, targetId: target.id || 'deity', targetName: target.name || 'Deity' }, this.state.currentPlayer);
            
            if (target.type === 'deity') {
                this.dealDamageToDeity(0, attacker.attack);
            } else {
                this.dealDamageToCard(target, attacker.attack, 0);
                this.dealDamageToCard(attacker, target.attack || 0, 1);
            }
            
            this.state.combat.attackedThisTurn.push(attacker.instanceId);
            attacker.tapped = true;
            
            this.checkWinCondition();
            this.render();
            
            // Small delay between attacks
            if (index < availableAttackers.length - 1) {
                setTimeout(() => executeAttack(index + 1), 500);
            }
        };
        
        executeAttack(0);
    },
    
    aiPlayCard(card) {
        const ai = this.state.players[1];
        const handIndex = ai.hand.findIndex(c => c.instanceId === card.instanceId);
        
        if (handIndex === -1) return;
        
        ai.hand.splice(handIndex, 1);
        ai.klCurrent -= card.cost;
        
        if (card.type === 'Avatar') {
            ai.avatarRow.push(card);
            this.state.combat.summonedThisTurn.push(card.instanceId);
            this.log(`Opponent summoned ${card.name}!`, 'action');
            this.handleOnEnterTrigger(card, 1);
            this.handleAvatarEnterPassive(card, 1);
            this.animateAICardPlay(card);
        } else if (card.type === 'Spell') {
            ai.graveyard.push(card);
            this.log(`Opponent cast ${card.name}!`, 'action');
            this.handleSpellEffect(card, 1);
            this.handleDeitySpellPassive(1);
            this.animateAICardPlay(card);
        } else if (card.type === 'Domain') {
            ai.domainRow.push(card);
            this.log(`Opponent played Domain: ${card.name}!`, 'action');
            this.handleOnEnterTrigger(card, 1);
            this.animateAICardPlay(card);
        } else if (card.type === 'Relic' || card.type === 'Crown') {
            ai.domainRow.push(card);
            this.log(`Opponent equipped ${card.name}!`, 'action');
            this.handleOnEnterTrigger(card, 1);
            this.animateAICardPlay(card);
        }
        
        this.handleAspectTrigger(card, 1);
        this.state.cardsPlayedThisTurn++;
        this.render();
    },
    
    animateAICardPlay(card) {
        const overlay = document.getElementById('ai-play-overlay');
        if (!overlay) return;
        
        overlay.innerHTML = `
            <div class="ai-play-container">
                <div class="ai-play-text">OPPONENT PLAYS</div>
                <div class="ai-play-card ${card.aspects && card.aspects[0] ? card.aspects[0].toLowerCase() : ''}">
                    <img src="${card.image}" alt="${card.name}">
                    <div class="ai-play-info">
                        <div class="ai-play-name">${card.name}</div>
                        ${card.attack !== undefined ? `<div class="ai-play-stats">${card.attack} / ${card.health}</div>` : ''}
                    </div>
                </div>
            </div>
        `;
        
        overlay.classList.add('visible');
        
        setTimeout(() => {
            overlay.classList.remove('visible');
        }, 1500);
    },
    
    handleEndTurnPassives(playerIndex) {
        if (!this.state.rulesHelper) return;
        const p = this.state.players[playerIndex];
        const deity = p.deity;
        if (!deity || !deity.passive) return;
        
        if (deity.passive === 'Perfect Balance') {
            const opponent = this.state.players[1 - playerIndex];
            if (p.essence === opponent.essence) {
                this.drawCardEffect(playerIndex, 1);
                this.log(`${deity.passive}: Both Deities have equal Essence, drew 1 card`, 'action');
            }
        }
        
        if (deity.passive === 'Quiet Orbit') {
            if (!this.state.combat.attackedThisTurn.some(id => 
                p.avatarRow.some(c => c.instanceId === id) || p.domainRow.some(c => c.instanceId === id)
            )) {
                this.adjustStat(playerIndex, 'essence', 2);
                this.log(`${deity.passive}: No attacks this turn, restored 2 Essence`, 'heal');
            }
        }
    },

    handleDawnPhase() {
        const playerIndex = this.state.currentPlayer;
        const p = this.state.players[playerIndex];

        p.shardSurgeUsedThisTurn = false;
        p.klThresholdTriggeredThisTurn = false;

        const oldKl = p.currentKl ?? p.klCurrent ?? 0;
        const recalculatedKl = this.recalculateKl(p);
        p.currentKl = recalculatedKl;
        p.klCurrent = recalculatedKl;
        p.klMax = Math.max(p.klMax ?? 0, recalculatedKl);

        // Reset turn counters
        this.state.drawsThisTurn = 0;

        // Ready all permanents (avatars, domains, relics, shards)
        this.readyAllPermanents(p);

        // Check deity dawn passives
        this.handleDawnPassives(playerIndex);

        // God threshold check based on KL movement
        this.checkGodThreshold(p, oldKl, recalculatedKl);

        this.log(`${p.deity.name}: KL recalculated to ${recalculatedKl}`, 'action');
        this.render();
    },
    
    handleDawnPassives(playerIndex) {
        if (!this.state.rulesHelper) return;
        const p = this.state.players[playerIndex];
        const deity = p.deity;
        if (!deity || !deity.passive) return;
        
        if (deity.passive === 'Solar Flow') {
            const hasGlowAvatar = p.avatarRow.some(c => c.aspects && c.aspects.includes('Glow')) ||
                                  p.domainRow.some(c => c.aspects && c.aspects.includes('Glow'));
            if (hasGlowAvatar) {
                this.adjustStat(playerIndex, 'kl', 1);
                this.log(`${deity.passive}: +1 KL (controlling Glow Avatar)`, 'action');
            }
        }
        
        if (deity.passive === 'Familiar Swarm') {
        }
    },

    drawCardManual() {
        if (this.state.isReplayMode || this.state.isSpectatorMode) return;
        if (this.state.currentPlayer !== 0) {
            this.showPrompt('It\'s not your turn!');
            return;
        }
        if (this.state.currentPhase !== 'draw') {
            this.showPrompt('You can only draw during the Draw phase!');
            return;
        }
        if (this.state.drawsThisTurn >= 1) {
            this.showPrompt('You already drew a card this turn!');
            return;
        }
        
        this.playDrawAnimation(() => {
            this.drawCard(0, 1);
        });
    },
    
    playDrawAnimation(callback) {
        const deckPile = document.getElementById('deck-pile');
        const handContainer = document.getElementById('player-hand');
        if (!deckPile || !handContainer) {
            if (callback) callback();
            return;
        }
        
        const deckRect = deckPile.getBoundingClientRect();
        const handRect = handContainer.getBoundingClientRect();
        
        const animCard = document.createElement('div');
        animCard.className = 'ec-draw-animation';
        animCard.style.left = (deckRect.left + deckRect.width/2 - 40) + 'px';
        animCard.style.top = (deckRect.top + deckRect.height/2 - 55) + 'px';
        
        const targetX = handRect.left + handRect.width/2 - 40;
        const targetY = handRect.top;
        
        animCard.style.setProperty('--target-x', `${targetX - deckRect.left - deckRect.width/2 + 40}px`);
        animCard.style.setProperty('--target-y', `${targetY - deckRect.top - deckRect.height/2 + 55}px`);
        
        document.body.appendChild(animCard);
        
        animCard.animate([
            { 
                transform: 'scale(1) rotate(0deg)',
                opacity: 1
            },
            { 
                transform: `scale(1.2) rotate(10deg) translate(${(targetX - deckRect.left)/2}px, ${(targetY - deckRect.top)/2}px)`,
                opacity: 1
            },
            { 
                transform: `scale(0.9) rotate(0deg) translate(${targetX - deckRect.left}px, ${targetY - deckRect.top}px)`,
                opacity: 0.5
            }
        ], {
            duration: 400,
            easing: 'ease-out'
        }).onfinish = () => {
            animCard.remove();
            if (callback) callback();
        };
    },

    drawCard(playerIndex, count = 1, isMandatory = false, bypassTurnLimit = false) {
        if (this.state.isReplayMode || this.state.isSpectatorMode) return;
        const p = this.state.players[playerIndex];

        if (this.state.rulesHelper && playerIndex === this.state.currentPlayer && !bypassTurnLimit) {
            if (this.state.drawsThisTurn + count > 1) {
                this.log(`Can only draw 1 card per turn (unless card effects allow it)`, 'damage');
                return;
            }
        }

        for (let i = 0; i < count; i++) {
            if (p.deck.length > 0) {
                const card = p.deck.shift();
                p.hand.push(card);
                this.state.drawsThisTurn++;
                this.log(`Player ${playerIndex + 1} drew ${card.name}`, 'action');
                MatchRecorder.recordAction('DRAW', { cardId: card.id, cardName: card.name }, playerIndex);
                this.animateCardDraw(card, playerIndex);
                this.emitEvent('ON_CARD_DRAWN', { card, playerIndex });
            } else {
                // === ESSENCE CROWN: Deck-out loss condition ===
                // If player must draw but deck is empty, they lose the game
                if (isMandatory) {
                    this.log(`${playerIndex === 0 ? 'You' : 'Opponent'} cannot draw - deck is empty!`, 'damage');
                    this.log(`DECK OUT! ${playerIndex === 0 ? 'You lose' : 'Opponent loses'}!`, 'phase');
                    BattleEffects.screenFlash('#ff000055', 500);
                    this.triggerGameEnd(1 - playerIndex, 'deck_out');
                    return;
                } else {
                    this.log(`${playerIndex === 0 ? 'Your' : 'Opponent\'s'} deck is empty!`, 'damage');
                }
            }
        }
        this.render();
    },
    
    animateCardDraw(card, playerIndex) {
        const overlay = document.getElementById('draw-animation');
        if (!overlay) return;
        
        overlay.innerHTML = `
            <div class="draw-card-container">
                <div class="draw-card ${card.aspects && card.aspects[0] ? card.aspects[0].toLowerCase() : ''}">
                    <img src="${card.image}" alt="${card.name}">
                    <div class="draw-card-info">
                        <div class="draw-card-name">${card.name}</div>
                        <div class="draw-card-cost">${card.cost} KL</div>
                        ${card.attack !== undefined ? `<div class="draw-card-stats">${card.attack} / ${card.health}</div>` : ''}
                    </div>
                </div>
                <div class="draw-text">DRAW!</div>
            </div>
        `;
        
        overlay.classList.add('visible');
        
        setTimeout(() => {
            overlay.classList.remove('visible');
        }, 1200);
    },

    shuffleDeck(playerIndex) {
        const deck = this.state.players[playerIndex].deck;
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        this.log(`Player ${playerIndex + 1} shuffled deck`, 'action');
    },

    adjustStat(playerIndex, stat, delta) {
        const p = this.state.players[playerIndex];

        if (stat === 'essence') {
            const oldEssence = p.essence;
            p.essence = Math.max(0, p.essence + delta);
            if (delta < 0) {
                this.emitEvent('ON_ESSENCE_LOSS', { playerIndex, amount: -delta, newTotal: p.essence });
            } else if (delta > 0) {
                this.emitEvent('ON_ESSENCE_GAIN', { playerIndex, amount: delta, newTotal: p.essence });
            }
            if (p.essence === 0) {
                this.log(`Player ${playerIndex + 1} has been defeated!`, 'damage');
                this.checkWinCondition();
            }
        } else if (stat === 'kl') {
            const currentKlValue = p.currentKl ?? p.klCurrent ?? 0;
            const klCap = Math.min(31, Math.max(p.klMax ?? 0, currentKlValue));
            const newKL = currentKlValue + delta;
            if (newKL > klCap) {
                const excess = newKL - klCap;
                p.currentKl = klCap;
                p.klCurrent = klCap;
                this.adjustStat(playerIndex, 'overflow', excess);
            } else {
                const bounded = Math.max(0, newKL);
                p.currentKl = bounded;
                p.klCurrent = bounded;
            }
        } else if (stat === 'klMax') {
            const newMax = p.klMax + delta;
            if (newMax > 13) {
                const excess = newMax - 13;
                p.klMax = 13;
                p.baseKl = p.klMax;
                this.adjustStat(playerIndex, 'overflow', excess);
            } else {
                p.klMax = Math.max(1, newMax);
                p.baseKl = p.klMax;
            }
        } else if (stat === 'overflow') {
            p.overflow = Math.max(0, p.overflow + delta);
            if (p.overflow >= 13 && this.state.rulesHelper && p.godCodeCharges < 2) {
                p.overflow -= 13;
                p.godCodeCharges = Math.min(2, p.godCodeCharges + 1);
                this.log('Essence Crown charged! +1 God Code charge!', 'heal');
                this.spawnParticles({ type: 'effect' }, 'gold');
            }
        }

        this.render();
    },

    adjustShards(playerIndex, delta) {
        const player = this.state.players[playerIndex];
        const before = player.shards ?? 0;
        const updated = Math.max(0, Math.min(6, before + delta));
        player.shards = updated;

        if (updated !== before) {
            this.renderStats();
        }
    },

    maybeGrantShardOnPlay(card, playerIndex) {
        if (!card || card.type === 'Deity') return;
        const aspects = Array.isArray(card.aspects) ? card.aspects : [];
        const gainsShard = aspects.some(a => typeof a === 'string' && ['shard', 'sun'].includes(a.toLowerCase()));
        if (!gainsShard) return;

        const player = this.state.players[playerIndex];
        if ((player.shards ?? 0) >= 6) return;

        this.adjustShards(playerIndex, 1);
        this.log(`Shard attuned! Player ${playerIndex + 1} gains 1 Shard (${this.state.players[playerIndex].shards}/6).`, 'action');
    },

    canUseShardSurge(playerIndex) {
        const player = this.state.players[playerIndex];
        return this.state.currentPlayer === playerIndex && player.shards >= 3 && !player.shardSurgeUsedThisTurn;
    },

    activateShardSurge() {
        if (this.state.isReplayMode || this.state.isSpectatorMode) return;
        const playerIndex = this.state.currentPlayer;
        const player = this.state.players[playerIndex];

        if (!this.canUseShardSurge(playerIndex)) {
            this.log('Shard Surge unavailable (requires 3 Shards, your turn, and unused this turn).', 'damage');
            return;
        }

        this.adjustShards(playerIndex, -3);
        player.shardSurgeUsedThisTurn = true;
        this.drawCard(playerIndex, 1, false, true);
        this.log(`Player ${playerIndex + 1} unleashes Shard Surge and draws 1 card!`, 'action');
        this.render();
    },

    playCard(card, playerIndex, zone = 'front') {
        if (this.state.isReplayMode || this.state.isSpectatorMode) return;
        const p = this.state.players[playerIndex];
        const handIndex = p.hand.findIndex(c => c.instanceId === card.instanceId);

        if (handIndex === -1) return;

        const availableKl = p.currentKl ?? p.klCurrent;

        if (this.state.rulesHelper && card.cost > availableKl) {
            this.log(`Not enough KL! Need ${card.cost}, have ${availableKl}`, 'damage');
            return;
        }

        const klBeforePlay = availableKl;
        p.hand.splice(handIndex, 1);
        p.currentKl = klBeforePlay - card.cost;
        p.klCurrent = p.currentKl;

        this.state.cardsPlayedThisTurn++;
        
        if (card.type === 'Avatar') {
            p.avatarRow.push(card);
            this.state.combat.summonedThisTurn.push(card.instanceId);
            this.log(`Player ${playerIndex + 1} summoned ${card.name}`, 'action');
            MatchRecorder.recordCardPlayed(card, playerIndex);
            MatchRecorder.recordAction('CARD_PLAYED', { cardId: card.id, cardName: card.name, type: card.type, zone: 'avatarRow' }, playerIndex);
            this.emitEvent('ON_AVATAR_SUMMONED', { card, playerIndex, zone: 'avatarRow' });
            this.handleOnEnterTrigger(card, playerIndex);
            this.handleAvatarEnterPassive(card, playerIndex);
            if (this.state.matchMode === 'campaign' && playerIndex === 1) {
                CampaignManager.applyBossAbility('summon', { card, playerIndex });
            }
        } else if (card.type === 'Domain') {
            // === ESSENCE CROWN: Enforce 1 Domain per turn limit ===
            if (this.state.rulesHelper && !this.canPlayDomain(playerIndex)) {
                this.log(`Cannot play another Domain this turn! (Limit: ${this.state.combat.maxDomainsPerTurn})`, 'damage');
                p.hand.push(card);
                p.currentKl += card.cost;
                p.klCurrent = p.currentKl;
                this.state.cardsPlayedThisTurn--;
                return;
            }
            if (p.domain) p.graveyard.push(p.domain);
            p.domain = card;
            p.domainRow.push(card);
            this.recordDomainPlay();
            this.log(`Player ${playerIndex + 1} set Domain: ${card.name}`, 'action');
            MatchRecorder.recordCardPlayed(card, playerIndex);
            MatchRecorder.recordAction('CARD_PLAYED', { cardId: card.id, cardName: card.name, type: card.type, zone: 'domainRow' }, playerIndex);
            this.handleOnEnterTrigger(card, playerIndex);
        } else if (card.type === 'Spell') {
            const targetType = this.getSpellTargetType(card);
            if (targetType && !this.state.spell.mode) {
                this.state.spell.mode = 'selectTarget';
                this.state.spell.pendingSpell = card;
                this.state.spell.targetType = targetType;
                p.currentKl += card.cost;
                p.klCurrent = p.currentKl;
                p.hand.push(card);
                this.state.cardsPlayedThisTurn--;
                this.showPrompt(`Select a target for ${card.name}`);
                this.render();
                return;
            }
            p.graveyard.push(card);
            this.state.spellsPlayedThisTurn++;
            this.log(`Player ${playerIndex + 1} cast ${card.name}!`, 'action');
            MatchRecorder.recordCardPlayed(card, playerIndex);
            MatchRecorder.recordAction('CARD_PLAYED', { cardId: card.id, cardName: card.name, type: card.type, zone: 'graveyard' }, playerIndex);
            this.handleSpellEffect(card, playerIndex);
            this.handleDeitySpellPassive(playerIndex);
            this.handleSecondCardPassive(playerIndex);
            if (p.currentKl === 0 && klBeforePlay === card.cost) {
                this.handleExactKLSpendPassive(playerIndex);
            }
            this.log(`${card.name}: Spell resolved`, 'phase');
        }

        this.maybeGrantShardOnPlay(card, playerIndex);

        if (this.state.cardsPlayedThisTurn === 2) {
            this.handleSecondCardPassive(playerIndex);
        }

        if (p.currentKl === 0 && klBeforePlay === card.cost) {
            this.handleExactKLSpendPassive(playerIndex);
        }
        
        this.handleAspectTrigger(card, playerIndex);
        this.animateCardPlay(card);
        this.render();
        
    },
    
    handleOnEnterTrigger(card, playerIndex) {
        if (!this.state.rulesHelper) return;
        if (!card.effect) return;
        
        const effect = card.effect.toLowerCase();
        
        if (effect.includes('on play:') || effect.includes('on enter:') || effect.includes('when') && effect.includes('enters')) {
            if (effect.includes('restore') && effect.includes('essence')) {
                const match = effect.match(/restore (\d+) essence/i);
                if (match) {
                    const amount = parseInt(match[1]);
                    this.adjustStat(playerIndex, 'essence', amount);
                    this.log(`${card.name}: Restored ${amount} Essence`, 'heal');
                }
            }
            
            if (effect.includes('deal') && effect.includes('damage') && effect.includes('deity')) {
                const match = effect.match(/deal (\d+)/i);
                if (match) {
                    const damage = parseInt(match[1]);
                    this.adjustStat(1 - playerIndex, 'essence', -damage);
                    this.log(`${card.name}: Dealt ${damage} damage to opponent`, 'damage');
                }
            }
            
            if (effect.includes('opponent loses') && effect.includes('essence')) {
                const match = effect.match(/loses (\d+) essence/i);
                if (match) {
                    const amount = parseInt(match[1]);
                    this.adjustStat(1 - playerIndex, 'essence', -amount);
                    this.log(`${card.name}: Opponent lost ${amount} Essence`, 'damage');
                }
            }
            
            if (effect.includes('draw a card') || effect.includes('draw 1')) {
                this.drawCardEffect(playerIndex, 1);
                this.log(`${card.name}: Drew 1 card`, 'action');
            }
            
            if (effect.includes('+1 kl') || effect.includes('gain') && effect.includes('kl')) {
                this.adjustStat(playerIndex, 'kl', 1);
                this.log(`${card.name}: Gained +1 KL`, 'action');
            }
        }
    },
    
    handleDeitySpellPassive(playerIndex) {
        if (!this.state.rulesHelper) return;
        const p = this.state.players[playerIndex];
        const deity = p.deity;
        if (!deity || !deity.passive) return;
        
        if (deity.passive === 'Presence of Wealth' && !p.passiveUsedThisTurn) {
            p.passiveUsedThisTurn = true;
            this.adjustStat(playerIndex, 'essence', 1);
            this.log(`${deity.passive}: +1 Essence from playing a Spell`, 'heal');
        }
    },
    
    handleSecondCardPassive(playerIndex) {
        if (!this.state.rulesHelper) return;
        const p = this.state.players[playerIndex];
        const deity = p.deity;
        if (!deity || !deity.passive) return;
        
        if (deity.passive === 'Story of the Shards' && !p.passiveUsedThisTurn) {
            p.passiveUsedThisTurn = true;
            this.drawCardEffect(playerIndex, 1);
            this.log(`${deity.passive}: Drew 1 card`, 'action');
        }
        
        if (deity.passive === 'Shard War Architect' && !p.passiveUsedThisTurn) {
            p.passiveUsedThisTurn = true;
            this.adjustStat(1 - playerIndex, 'essence', -1);
            this.drawCardEffect(playerIndex, 1);
            this.log(`${deity.passive}: Opponent lost 1 Essence, drew 1 card`, 'action');
        }
    },
    
    handleExactKLSpendPassive(playerIndex) {
        if (!this.state.rulesHelper) return;
        const p = this.state.players[playerIndex];
        const deity = p.deity;
        if (!deity || !deity.passive) return;
        
        if (deity.passive === 'Calibrated Flow') {
            this.drawCardEffect(playerIndex, 1);
            this.log(`${deity.passive}: Drew 1 card (spent exact KL)`, 'action');
        }
    },
    
    handleAvatarEnterPassive(card, playerIndex) {
        if (!this.state.rulesHelper) return;
        const p = this.state.players[playerIndex];
        const deity = p.deity;
        if (!deity || !deity.passive) return;
        
        if (deity.passive === 'Packbond' && isBeastCard(card)) {
            this.adjustStat(playerIndex, 'essence', 1);
            this.log(`${deity.passive}: Beast entered - restored 1 Essence!`, 'heal');
        }

        if (deity.passive === 'Familiar Swarm' && !p.passiveUsedThisTurn) {
            if (isBeastCard(card) || card.cost <= 2) {
                p.passiveUsedThisTurn = true;
                this.adjustStat(1 - playerIndex, 'essence', -1);
                this.adjustStat(playerIndex, 'kl', 1);
                this.log(`${deity.passive}: Beast/low-cost entered - opponent lost 1 Essence, +1 KL!`, 'action');
            }
        }
        
        if (deity.passive === 'Solar Flow' && !p.passiveUsedThisTurn) {
            const hasGlowAvatar = p.avatarRow.some(c => c.aspects && c.aspects.includes('Glow'));
            if (hasGlowAvatar || (card.aspects && card.aspects.includes('Glow'))) {
                p.passiveUsedThisTurn = true;
            }
        }
    },
    
    getSpellTargetType(card) {
        if (!card.effect) return null;
        const effect = card.effect.toLowerCase();
        
        if (effect.includes('target deity') || effect.includes('target opponent')) {
            return 'deity';
        }
        if (effect.includes('target avatar') || effect.includes('destroy target')) {
            return 'avatar';
        }
        if (effect.includes('target') && (effect.includes('damage') || effect.includes('destroy'))) {
            return 'any';
        }
        return null;
    },
    
    handleSpellEffect(card, playerIndex, target = null) {
        if (!card.effect) return;
        const effect = card.effect.toLowerCase();
        
        if (effect.includes('deal') && effect.includes('essence damage')) {
            const match = effect.match(/deal (\d+)/i);
            if (match) {
                const damage = parseInt(match[1]);
                if (target && target.type === 'deity') {
                    this.animateSpellToDeity(card, target.playerIndex, damage);
                } else {
                    this.animateSpellToDeity(card, 1 - playerIndex, damage);
                }
            }
        }
        
        if (effect.includes('destroy target avatar') && target && target.type === 'avatar') {
            this.animateSpellToAvatar(card, target.card, target.playerIndex);
            setTimeout(() => {
                this.destroyAvatar(target.card, target.playerIndex);
            }, 600);
        }
        
        if (effect.includes('restore') && effect.includes('essence') && effect.includes('your')) {
            const match = effect.match(/restore (\d+)/i);
            if (match) {
                const amount = parseInt(match[1]);
                this.adjustStat(playerIndex, 'essence', amount);
                this.log(`${card.name}: Restored ${amount} Essence`, 'heal');
                this.animateSpellEffect(card, 'heal');
            }
        }
        
        if (effect.includes('opponent loses') && effect.includes('essence')) {
            const match = effect.match(/loses (\d+)/i);
            if (match) {
                const amount = parseInt(match[1]);
                this.animateSpellToDeity(card, 1 - playerIndex, amount);
            }
        }
        
        if (effect.includes('draw')) {
            const match = effect.match(/draw (\d+|a) card/i);
            if (match) {
                const num = match[1] === 'a' ? 1 : parseInt(match[1]);
                this.drawCardEffect(playerIndex, num);
                this.log(`${card.name}: Drew ${num} card(s)`, 'action');
            }
        }
        
        if (effect.includes('gain') && effect.includes('kl')) {
            const match = effect.match(/\+(\d+) kl|gain (\d+) kl/i);
            if (match) {
                const amount = parseInt(match[1] || match[2]);
                this.adjustStat(playerIndex, 'kl', amount);
                this.log(`${card.name}: Gained +${amount} KL`, 'action');
            }
        }
        
        if (effect.includes('both deities gain')) {
            const match = effect.match(/gain (\d+) essence/i);
            if (match) {
                const amount = parseInt(match[1]);
                this.adjustStat(0, 'essence', amount);
                this.adjustStat(1, 'essence', amount);
                this.log(`${card.name}: Both Deities gained ${amount} Essence`, 'heal');
                this.animateSpellEffect(card, 'heal');
            }
        }
    },
    
    selectSpellTarget(target, playerIndex) {
        if (!this.state.spell.mode || !this.state.spell.pendingSpell) return;
        
        const spell = this.state.spell.pendingSpell;
        const casterIndex = this.state.currentPlayer;
        const p = this.state.players[casterIndex];
        
        const handIndex = p.hand.findIndex(c => c.instanceId === spell.instanceId);
        if (handIndex !== -1) {
            p.hand.splice(handIndex, 1);
            p.klCurrent -= spell.cost;
            p.graveyard.push(spell);
            this.state.cardsPlayedThisTurn++;
            this.state.spellsPlayedThisTurn++;
            
            this.log(`Player ${casterIndex + 1} cast ${spell.name} on ${target.name || 'target'}!`, 'action');
            this.handleSpellEffect(spell, casterIndex, { type: target.type, card: target.card, playerIndex: playerIndex, name: target.name });
            this.handleDeitySpellPassive(casterIndex);
            this.handleAspectTrigger(spell, casterIndex);
        }
        
        this.state.spell.mode = null;
        this.state.spell.pendingSpell = null;
        this.state.spell.targetType = null;
        this.hidePrompt();
        this.render();
    },
    
    cancelSpellTargeting() {
        this.state.spell.mode = null;
        this.state.spell.pendingSpell = null;
        this.state.spell.targetType = null;
        this.hidePrompt();
        this.render();
    },
    
    animateSpellToDeity(spell, targetPlayerIndex, damage) {
        const overlay = document.getElementById('ai-play-overlay');
        if (!overlay) return;
        
        const aspectClass = spell.aspects && spell.aspects[0] ? spell.aspects[0].toLowerCase() : '';
        
        overlay.innerHTML = `
            <div class="spell-cast-container">
                <div class="spell-cast-card ${aspectClass}">
                    <img src="${spell.image}" alt="${spell.name}">
                    <div class="spell-cast-info">
                        <div class="spell-cast-name">${spell.name}</div>
                    </div>
                </div>
                <div class="spell-cast-arrow">‚ö°</div>
                <div class="spell-target-deity">
                    <div class="target-deity-name">Player ${targetPlayerIndex + 1}'s Deity</div>
                    <div class="spell-damage-preview">-${damage} Essence</div>
                </div>
            </div>
        `;
        
        overlay.classList.add('visible');
        
        setTimeout(() => {
            this.adjustStat(targetPlayerIndex, 'essence', -damage);
            this.log(`${spell.name}: Dealt ${damage} damage to Player ${targetPlayerIndex + 1}`, 'damage');
            this.spawnDamageNumber(targetPlayerIndex === 0 ? 'p1-deity' : 'p2-deity', damage);
            this.screenShake(damage >= 3 ? 'heavy' : 'light');
        }, 400);
        
        setTimeout(() => {
            overlay.classList.remove('visible');
        }, 1200);
    },
    
    animateSpellToAvatar(spell, targetCard, targetPlayerIndex) {
        const overlay = document.getElementById('ai-play-overlay');
        if (!overlay) return;
        
        const aspectClass = spell.aspects && spell.aspects[0] ? spell.aspects[0].toLowerCase() : '';
        
        overlay.innerHTML = `
            <div class="spell-cast-container">
                <div class="spell-cast-card ${aspectClass}">
                    <img src="${spell.image}" alt="${spell.name}">
                    <div class="spell-cast-info">
                        <div class="spell-cast-name">${spell.name}</div>
                    </div>
                </div>
                <div class="spell-cast-arrow">üí•</div>
                <div class="spell-target-avatar">
                    <img src="${targetCard.image}" alt="${targetCard.name}">
                    <div class="spell-target-name">${targetCard.name}</div>
                </div>
            </div>
        `;
        
        overlay.classList.add('visible');
        this.screenShake('heavy');
        
        setTimeout(() => {
            overlay.classList.remove('visible');
        }, 1000);
    },
    
    animateSpellEffect(spell, effectType) {
        const overlay = document.getElementById('ai-play-overlay');
        if (!overlay) return;
        
        const aspectClass = spell.aspects && spell.aspects[0] ? spell.aspects[0].toLowerCase() : '';
        const icon = effectType === 'heal' ? '‚ú®' : effectType === 'damage' ? 'üí•' : '‚ö°';
        
        overlay.innerHTML = `
            <div class="spell-cast-container">
                <div class="spell-cast-card ${aspectClass}">
                    <img src="${spell.image}" alt="${spell.name}">
                    <div class="spell-cast-info">
                        <div class="spell-cast-name">${spell.name}</div>
                    </div>
                </div>
                <div class="spell-effect-icon">${icon}</div>
            </div>
        `;
        
        overlay.classList.add('visible');
        
        setTimeout(() => {
            overlay.classList.remove('visible');
        }, 800);
    },
    
    destroyAvatar(card, playerIndex) {
        const p = this.state.players[playerIndex];
        let zone = 'avatarRow';
        let idx = p.avatarRow.findIndex(c => c.instanceId === card.instanceId);
        if (idx === -1) {
            zone = 'domainRow';
            idx = p.domainRow.findIndex(c => c.instanceId === card.instanceId);
        }
        
        if (idx !== -1) {
            const destroyed = p[zone].splice(idx, 1)[0];
            p.graveyard.push(destroyed);
            this.log(`${card.name} was destroyed!`, 'damage');
            this.emitEvent('ON_AVATAR_DESTROYED', { card: destroyed, playerIndex, zone });
            this.handleOnDeathTrigger(card, playerIndex);
            this.render();
        }
    },

    animateCardPlay(card) {
        const handCards = document.querySelectorAll('#player-hand .game-card');
        handCards.forEach(el => {
            if (el.dataset.cardId === String(card.instanceId)) {
                if (card.type === 'Spell') {
                    el.classList.add('spell-casting');
                    BattleEffects.spellCast(el, card.aspects || []);
                    setTimeout(() => {
                        this.render();
                    }, 800);
                } else {
                    el.classList.add('card-playing');
                }
            }
        });
        
        setTimeout(() => {
            if (card.type === 'Avatar' || card.type === 'Domain' || card.type === 'Relic') {
                const playedCard = document.querySelector(`[data-card-id="${card.instanceId}"]`);
                if (playedCard) {
                    BattleEffects.cardSummon(playedCard, card.type);
                    const slot = playedCard.closest('.ec-card-slot');
                    if (slot) {
                        AnimationHelper.play('manifest', slot);
                    }
                }
            }
        }, 100);
    },

    handleAspectTrigger(card, playerIndex) {
        if (!this.state.rulesHelper) return;
        
        const aspects = card.aspects || (card.aspect ? [card.aspect] : []);
        const mainAspect = getMainAspect(card);
        
        if (mainAspect === 'Glow') {
            this.adjustStat(playerIndex, 'essence', 1);
            this.log('Glow aspect: +1 Essence', 'heal');
        } else if (mainAspect === 'Void') {
            this.adjustStat(1 - playerIndex, 'essence', -1);
            this.log('Void aspect: -1 to opponent', 'damage');
        } else if (mainAspect === 'Gray') {
            this.drawCardEffect(playerIndex);
            this.log('Gray aspect: Draw 1', 'action');
        }
    },
    
    drawCardEffect(playerIndex, count = 1) {
        const p = this.state.players[playerIndex];
        for (let i = 0; i < count; i++) {
            if (p.deck.length > 0) {
                const card = p.deck.pop();
                p.hand.push(card);
                this.log(`Player ${playerIndex + 1} drew ${card.name}`, 'action');
            }
        }
        this.render();
    },

    moveCard(card, fromZone, toZone, playerIndex) {
        const p = this.state.players[playerIndex];
        
        const removeFrom = (zone) => {
            const idx = p[zone].findIndex(c => c.instanceId === card.instanceId);
            if (idx > -1) p[zone].splice(idx, 1);
        };
        
        ['hand', 'avatarRow', 'domainRow', 'graveyard', 'banished', 'deck', 'relicRow', 'spellRow'].forEach(removeFrom);
        
        if (toZone === 'deckTop') {
            p.deck.push(card);
        } else if (toZone === 'deckBottom') {
            p.deck.unshift(card);
        } else {
            p[toZone].push(card);
        }
        
        this.render();
    },

    showContextMenu(e, card) {
        e.preventDefault();
        e.stopPropagation();
        const menu = document.getElementById('context-menu');
        this.state.contextCard = card;
        menu.style.left = e.clientX + 'px';
        menu.style.top = e.clientY + 'px';
        menu.classList.add('visible');
    },

    hideContextMenu() {
        document.getElementById('context-menu').classList.remove('visible');
    },

    handleContextAction(action) {
        const card = this.state.contextCard;
        if (!card) return;
        
        const playerIndex = 0;
        
        switch(action) {
            case 'play':
                this.playCard(card, playerIndex);
                break;
            case 'tap':
                card.tapped = !card.tapped;
                break;
            case 'flip':
                card.faceDown = !card.faceDown;
                break;
            case 'to-hand':
                this.moveCard(card, null, 'hand', playerIndex);
                break;
            case 'to-discard':
                this.moveCard(card, null, 'graveyard', playerIndex);
                break;
            case 'to-exile':
                this.moveCard(card, null, 'banished', playerIndex);
                break;
        }
        
        this.hideContextMenu();
        this.render();
    },

    viewPile(playerIndex, pileName) {
        const p = this.state.players[playerIndex];
        const pile = p[pileName];
        this.showPileOverlay(pile, pileName, playerIndex);
    },
    
    showPileOverlay(pile, pileName, playerIndex) {
        const overlay = document.getElementById('pile-overlay');
        if (!overlay) return;
        
        const title = pileName === 'graveyard' ? 'GRAVEYARD' : pileName.toUpperCase();
        
        let cardsHtml = '';
        if (pile.length === 0) {
            cardsHtml = '<div class="pile-empty">No cards</div>';
        } else {
            pile.forEach(card => {
                cardsHtml += `
                    <div class="pile-card ${card.aspects && card.aspects[0] ? card.aspects[0].toLowerCase() : ''}">
                        <img src="${card.image}" alt="${card.name}">
                        <div class="pile-card-info">
                            <div class="pile-card-name">${card.name}</div>
                            <div class="pile-card-cost">${card.cost} KL</div>
                            ${card.attack !== undefined ? `<div class="pile-card-stats">${card.attack}/${card.health}</div>` : ''}
                            ${card.effect ? `<div class="pile-card-effect">${card.effect}</div>` : ''}
                        </div>
                    </div>
                `;
            });
        }
        
        overlay.innerHTML = `
            <div class="pile-container">
                <div class="pile-header">
                    <h2>Player ${playerIndex + 1} ${title}</h2>
                    <span class="pile-count">${pile.length} cards</span>
                    <button class="pile-close" onclick="Game.closePileOverlay()">X</button>
                </div>
                <div class="pile-cards">
                    ${cardsHtml}
                </div>
            </div>
        `;
        
        overlay.classList.add('visible');
    },
    
    closePileOverlay() {
        document.getElementById('pile-overlay')?.classList.remove('visible');
    },
    
    showCardPreview(card) {
        const preview = document.getElementById('card-preview');
        if (!preview || !card) return;
        
        if (this.state.previewTimeout) {
            clearTimeout(this.state.previewTimeout);
            this.state.previewTimeout = null;
        }
        
        const aspectClass = card.aspects && card.aspects[0] ? card.aspects[0].toLowerCase() : '';
        
        preview.innerHTML = `
            <div class="preview-card ${aspectClass}">
                <img src="${card.image}" alt="${card.name}">
                <div class="preview-info">
                    <div class="preview-name">${card.name}</div>
                    <div class="preview-type">${card.type} ${card.rarity ? '- ' + card.rarity : ''}</div>
                    <div class="preview-cost">${card.cost} KL</div>
                    ${card.attack !== undefined ? `<div class="preview-stats">Power: ${card.attack} | Health: ${card.health}</div>` : ''}
                    ${card.effect ? `<div class="preview-effect">${card.effect}</div>` : ''}
                    ${card.passive ? `<div class="preview-passive"><strong>${card.passive}:</strong> ${card.passiveText || ''}</div>` : ''}
                    ${card.godCode ? `<div class="preview-godcode"><strong>${card.godCode}:</strong> ${card.godCodeText || ''}</div>` : ''}
                </div>
            </div>
        `;
        
        preview.classList.add('visible');
        
        this.updateCodexView(card);
    },
    
    updateCodexView(card) {
        if (!card) return;
        const codexName = document.getElementById('codex-name');
        const codexMeta = document.getElementById('codex-meta');
        const codexBody = document.getElementById('codex-body');
        const codexFlavor = document.getElementById('codex-flavor');
        
        if (codexName) codexName.textContent = card.name || 'Unknown Card';
        if (codexMeta) {
            codexMeta.innerHTML = `
                <span class="ec-meta-type">${card.type || 'Card'}${card.rarity ? ' ‚Ä¢ ' + card.rarity : ''}</span>
                ${card.cost !== undefined ? `<span class="ec-meta-cost">‚ö° ${card.cost} KL</span>` : ''}
                ${card.attack !== undefined ? `<span class="ec-meta-stats">‚öî ${card.attack} / ‚ù§ ${card.health}</span>` : ''}
            `;
        }
        if (codexBody) {
            let bodyHTML = '';
            if (card.effect) {
                bodyHTML += this.formatCardEffect(card.effect);
            }
            if (card.passive) {
                bodyHTML += `<span class="ec-ability ec-ability-active"><span class="ec-ability-name">${card.passive}:</span> ${card.passiveText || ''}</span>`;
            }
            if (card.godCode) {
                bodyHTML += `<span class="ec-ability ec-ability-crownbound"><span class="ec-ability-name">${card.godCode}:</span> ${card.godCodeText || ''}</span>`;
            }
            codexBody.innerHTML = bodyHTML || 'No special effects.';
        }
        if (codexFlavor) codexFlavor.textContent = card.flavor || '';
    },
    
    formatCardEffect(effect) {
        if (!effect) return '';
        const keywords = [
            { pattern: /\b(Manifest:)/gi, class: 'ec-ability-manifest', name: 'Manifest' },
            { pattern: /\b(On Play:)/gi, class: 'ec-ability-manifest', name: 'On Play' },
            { pattern: /\b(Active:)/gi, class: 'ec-ability-active', name: 'Active' },
            { pattern: /\b(Cycle:)/gi, class: 'ec-ability-cycle', name: 'Cycle' },
            { pattern: /\b(Crownbound:)/gi, class: 'ec-ability-crownbound', name: 'Crownbound' },
            { pattern: /\b(When.*?:)/gi, class: 'ec-ability-active', name: 'When' }
        ];
        
        let formatted = effect;
        keywords.forEach(kw => {
            formatted = formatted.replace(kw.pattern, `<span class="ec-ability-name">$1</span>`);
        });
        
        const lines = formatted.split(/[.!]\s+/).filter(l => l.trim());
        if (lines.length > 1) {
            return lines.map(line => `<span class="ec-ability">${line.trim()}.</span>`).join('');
        }
        return `<span class="ec-ability">${formatted}</span>`;
    },
    
    hideCardPreview() {
        this.state.previewTimeout = setTimeout(() => {
            document.getElementById('card-preview')?.classList.remove('visible');
            this.state.previewTimeout = null;
        }, 50);
    },

    toggleRulesHelper() {
        this.state.rulesHelper = !this.state.rulesHelper;
        const btn = document.getElementById('btn-rules-helper');
        btn.classList.toggle('active', this.state.rulesHelper);
        btn.textContent = this.state.rulesHelper ? 'Auto' : 'Man';
        this.log(`Rules Helper: ${this.state.rulesHelper ? 'ON - Automatic play assistance enabled' : 'OFF - Manual play'}`, 'phase');
        this.highlightLegalPlays();
    },

    toggleLog() {
        this.state.logVisible = !this.state.logVisible;
        const logPanel = document.getElementById('log-panel');
        const chroniclePanel = document.querySelector('.ec-panel--chronicle');
        const logBtn = document.getElementById('btn-log');
        
        if (logPanel) logPanel.classList.toggle('visible', this.state.logVisible);
        if (chroniclePanel) chroniclePanel.classList.toggle('open', this.state.logVisible);
        if (logBtn) logBtn.classList.toggle('active', this.state.logVisible);
    },

    // ==================== CODEX SYSTEM ====================
    toggleCodex() {
        this.state.codexVisible = !this.state.codexVisible;
        const overlay = document.getElementById('codex-overlay');
        if (this.state.codexVisible) {
            overlay.classList.remove('hidden');
        } else {
            overlay.classList.add('hidden');
        }
    },
    
    switchCodexTab(tabId) {
        document.querySelectorAll('.codex-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.codex-section').forEach(s => s.classList.remove('active'));
        
        document.querySelector(`.codex-tab[data-tab="${tabId}"]`).classList.add('active');
        document.getElementById(`codex-${tabId}`).classList.add('active');
    },

    // ==================== CARD ZOOM SYSTEM ====================
    showCardZoom(card) {
        if (!card) return;
        
        const panel = document.getElementById('card-zoom-panel');
        document.getElementById('zoom-card-image').src = card.image || '';
        document.getElementById('zoom-card-name').textContent = card.name || 'Unknown Card';
        document.getElementById('zoom-card-type').textContent = card.type || 'Unknown';
        
        const aspectEl = document.getElementById('zoom-card-aspect');
        const aspects = card.aspects || (card.aspect ? [card.aspect] : []);
        if (aspects.length > 0) {
            aspectEl.textContent = aspects.join(' / ');
            aspectEl.className = 'zoom-aspect ' + aspects[0].toLowerCase();
        } else {
            aspectEl.textContent = '';
        }
        
        const costEl = document.getElementById('zoom-card-cost');
        costEl.textContent = card.cost ? `Cost: ${card.cost} KL` : '';
        
        const statsRow = document.getElementById('zoom-card-stats-row');
        if (card.attack !== undefined && card.health !== undefined) {
            statsRow.innerHTML = `<div class="zoom-stat"><span class="stat-label">Attack:</span> ${card.attack}</div><div class="zoom-stat"><span class="stat-label">Health:</span> ${card.healthCurrent || card.health}</div>`;
        } else {
            statsRow.innerHTML = '';
        }
        
        const effectEl = document.getElementById('zoom-card-effect');
        effectEl.innerHTML = card.effect ? `<p><strong>Effect:</strong> ${card.effect}</p>` : '';
        if (card.passive) {
            effectEl.innerHTML += `<p><strong>${card.passive}:</strong> ${card.passiveText || ''}</p>`;
        }
        if (card.godCode) {
            effectEl.innerHTML += `<p><strong>GOD CODE - ${card.godCode}:</strong> ${card.godCodeText || ''}</p>`;
        }
        
        const rarityEl = document.getElementById('zoom-card-rarity');
        rarityEl.textContent = card.rarity ? `Rarity: ${card.rarity}` : '';
        
        panel.classList.remove('hidden');
        this.log(`Zoomed: ${card.name}`, 'action');
    },
    
    hideCardZoom() {
        document.getElementById('card-zoom-panel')?.classList.add('hidden');
    },

    // ==================== MOBILE PANEL SYSTEM ====================
    switchMobilePanel(panel) {
        document.querySelectorAll('.mobile-tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.mobile-tab[data-panel="${panel}"]`).classList.add('active');
        
        document.getElementById('hand-zone').style.display = panel === 'hand' ? 'block' : 'none';
        document.getElementById('shard-chain-panel').style.display = panel === 'chain' ? 'block' : 'none';
        document.getElementById('log-panel').style.display = panel === 'log' ? 'block' : 'none';
        
        if (panel === 'log') {
            document.getElementById('log-panel').classList.add('visible');
        }
    },

    // ==================== LEGAL PLAY HIGHLIGHTING ====================
    highlightLegalPlays() {
        if (!this.state.rulesHelper) return;
        
        document.querySelectorAll('.legal-play').forEach(el => el.classList.remove('legal-play'));
        document.querySelectorAll('.legal-target').forEach(el => el.classList.remove('legal-target'));
        
        if (this.state.currentPlayer !== 0) return;
        
        const p = this.state.players[0];
        
        if (this.state.currentPhase === 'main') {
            const handCards = document.querySelectorAll('#player-hand .hand-card');
            handCards.forEach((cardEl, i) => {
                const card = p.hand[i];
                if (card && card.cost <= p.klCurrent) {
                    cardEl.classList.add('legal-play');
                }
            });
        }
        
        if (this.state.currentPhase === 'clash' && this.state.combat.mode === 'selectAttacker') {
            const frontCards = document.querySelectorAll('#p1-avatar-row .game-card');
            frontCards.forEach(cardEl => {
                const cardId = parseInt(cardEl.dataset.instanceId);
                const canAttack = !this.state.combat.attackedThisTurn.includes(cardId) &&
                                  !this.state.combat.summonedThisTurn.includes(cardId);
                if (canAttack) {
                    cardEl.classList.add('legal-play');
                }
            });
        }
        
        if (this.state.combat.mode === 'selectTarget') {
            const targets = document.querySelectorAll('#p2-avatar-row .game-card');
            targets.forEach(cardEl => cardEl.classList.add('legal-target'));
            
            const guardians = this.getGuardians(1);
            if (guardians.length === 0) {
                document.getElementById('p2-deity-zone').classList.add('legal-target');
            }
        }
    },

    log(message, type = 'action') {
        MatchRecorder.recordAction('LOG', { message, type }, this.state.currentPlayer);
        
        const content = document.getElementById('log-content');
        if (!content) return;
        const entry = document.createElement('div');
        entry.className = `ec-chronicle-entry ${type}`;
        const turnNum = this.state?.turnNumber || 1;
        entry.innerHTML = `<span class="chronicle-turn">T${turnNum}</span> ${message}`;
        content.insertBefore(entry, content.firstChild);
        
        if (content.children.length > 50) {
            content.removeChild(content.lastChild);
        }
    },

    render() {
        this.renderStats();
        this.renderDeities();
        this.renderBoard();
        this.renderHand();
        this.highlightLegalPlays();
    },

    ensureShardPills() {
        ['p1', 'p2'].forEach(prefix => {
            const deckPill = document.getElementById(`${prefix}-deck`);
            const hudStats = deckPill?.parentElement;
            if (hudStats && !document.getElementById(`${prefix}-shards`)) {
                const shardPill = document.createElement('div');
                shardPill.className = 'ec-pill ec-pill--shard';
                shardPill.id = `${prefix}-shards`;
                shardPill.innerHTML = `
                    <span class="ec-pill-icon">üí†</span>
                    <span class="ec-pill-value" id="${prefix}-shard-count">0</span>
                    <span class="ec-pill-label">Shards</span>
                `;
                hudStats.appendChild(shardPill);
            }
        });
    },

    renderStats() {
        this.ensureShardPills();

        for (let p = 0; p < 2; p++) {
            const prefix = p === 0 ? 'p1' : 'p2';
            const player = this.state.players[p];

            const essenceEl = document.getElementById(`${prefix}-essence`);
            const klEl = document.getElementById(`${prefix}-kl`);
            const deckEl = document.getElementById(`${prefix}-deck-count`);
            const discardEl = document.getElementById(`${prefix}-graveyard-count`);
            
            if (essenceEl) essenceEl.textContent = player.essence;
            if (klEl) klEl.textContent = `${player.klCurrent}/${player.klMax}`;
            if (deckEl) deckEl.textContent = player.deck.length;
            if (discardEl) discardEl.textContent = player.graveyard.length;
            
            const essenceBar = document.getElementById(`${prefix}-essence-bar`);
            if (essenceBar) {
                const percent = Math.min(100, (player.essence / 23) * 100);
                essenceBar.style.width = `${percent}%`;
            }

            const playmatEssence = document.getElementById(`${prefix}-essence-display`);
            if (playmatEssence) playmatEssence.textContent = player.essence;

            const playmatDeck = document.getElementById(`${prefix}-deck-count-display`);
            if (playmatDeck) playmatDeck.textContent = player.deck.length;

            const shardCountEl = document.getElementById(`${prefix}-shard-count`);
            if (shardCountEl) shardCountEl.textContent = player.shards ?? 0;

            const statusTokens = document.getElementById(`${prefix}-status-tokens`);
            if (statusTokens) statusTokens.textContent = `Shards: ${player.shards ?? 0}`;
        }

        const handInfo = document.getElementById('hand-info');
        if (handInfo && this.state.players[0]) {
            const p = this.state.players[0];
            handInfo.textContent = `${p.hand.length} cards ‚Ä¢ ${p.klCurrent} KL`;
        }
        
        const deckPileCount = document.getElementById('deck-pile-count');
        if (deckPileCount && this.state.players[0]) {
            deckPileCount.textContent = this.state.players[0].deck.length;
        }
        
        const graveyardPileCount = document.getElementById('graveyard-pile-count');
        if (graveyardPileCount && this.state.players[0]) {
            graveyardPileCount.textContent = this.state.players[0].graveyard.length;
        }
        
        const deckPile = document.getElementById('deck-pile');
        if (deckPile) {
            if (this.state.currentPhase === 'draw' &&
                this.state.currentPlayer === 0 &&
                this.state.drawsThisTurn < 1 &&
                this.state.players[0].deck.length > 0) {
                deckPile.classList.add('can-draw');
            } else {
                deckPile.classList.remove('can-draw');
            }
        }

        const shardBtn = document.getElementById('btn-shard-surge');
        if (shardBtn) {
            const canUse = this.canUseShardSurge(this.state.currentPlayer);
            shardBtn.disabled = !canUse;
            shardBtn.classList.toggle('disabled', !canUse);
        }
    },

    renderDeities() {
        for (let p = 0; p < 2; p++) {
            const prefix = p === 0 ? 'p1' : 'p2';
            const player = this.state.players[p];
            const deity = player.deity;
            const frame = document.getElementById(`${prefix}-deity`);
            const nameLabel = document.getElementById(`${prefix}-deity-name`);
            const playmatSlot = document.getElementById(`${prefix}-deity-slot`);
            
            if (deity && frame) {
                const godCodeAvailable = player.godCodeCharges > 0 && !player.godCodeUsed && p === this.state.currentPlayer;
                const passiveText = deity.passive ? `${deity.passive}` : '';
                
                frame.innerHTML = `
                    <img src="${deity.image}" alt="${deity.name}">
                    <div class="deity-info-overlay">
                        <div class="deity-passive" title="${deity.passiveText || ''}">${passiveText}</div>
                        <div class="god-code-charges">
                            <span class="charge ${player.godCodeCharges >= 1 ? 'active' : ''}"></span>
                            <span class="charge ${player.godCodeCharges >= 2 ? 'active' : ''}"></span>
                        </div>
                        ${godCodeAvailable ? `<button class="god-code-btn" onclick="Game.activateGodCode(${p})">GOD CODE</button>` : ''}
                    </div>
                    <div class="deity-overflow">OF: ${player.overflow}/13</div>
                `;
                
                frame.onclick = () => {
                    if (this.state.spell.mode === 'selectTarget') {
                        const targetType = this.state.spell.targetType;
                        if (targetType === 'deity' || targetType === 'any') {
                            this.selectSpellTarget({ type: 'deity', name: `Player ${p + 1}'s Deity` }, p);
                        }
                    } else if (this.state.combat.mode === 'selectTarget') {
                        this.attackDeity(p);
                    }
                };

                if (this.state.spell.mode === 'selectTarget') {
                    const targetType = this.state.spell.targetType;
                    if ((targetType === 'deity' || targetType === 'any') && p !== this.state.currentPlayer) {
                        frame.classList.add('valid-spell-target');
                    } else {
                        frame.classList.remove('valid-spell-target');
                    }
                } else if (this.state.combat.mode === 'selectTarget' && p !== this.state.currentPlayer) {
                    frame.classList.add('valid-deity-target');
                } else {
                    frame.classList.remove('valid-deity-target');
                    frame.classList.remove('valid-spell-target');
                }
            }
            if (deity && nameLabel) {
                nameLabel.textContent = deity.name;
            }
            
            if (deity && playmatSlot) {
                const deityCard = this.createCardElement(deity, false, p);
                deityCard.classList.add('deity-card', 'playmat-deity');
                playmatSlot.innerHTML = '';
                playmatSlot.appendChild(deityCard);
            }
        }
    },
    
    activateGodCode(playerIndex) {
        const p = this.state.players[playerIndex];
        const deity = p.deity;
        
        if (!deity || p.godCodeCharges <= 0 || p.godCodeUsed) {
            this.showPrompt('God Code not available!');
            return;
        }
        
        if (playerIndex !== this.state.currentPlayer) {
            this.showPrompt('You can only activate your own God Code!');
            return;
        }
        
        p.godCodeCharges--;
        p.godCodeUsed = true;
        
        this.log(`${deity.name} activates ${deity.godCode}!`, 'phase');
        this.emitEvent('ON_DEITY_ABILITY_USED', { deity, playerIndex, godCode: deity.godCode });
        this.spawnParticles({ type: 'effect' }, 'gold');
        this.screenShake('heavy');
        
        this.executeGodCode(playerIndex, deity);
        this.render();
    },
    
    executeGodCode(playerIndex, deity) {
        const godCode = deity.godCode;
        
        if (godCode === 'Crown of the Second Sun') {
            this.state.players[playerIndex].avatarRow.forEach(c => c.attack += 2);
            this.state.players[playerIndex].domainRow.forEach(c => c.attack += 2);
            this.adjustStat(1 - playerIndex, 'essence', -4);
            this.log('Avatars gain +2 Power, opponent loses 4 Essence!', 'damage');
        }
        else if (godCode === 'Crown of Absolute Zero') {
            this.adjustStat(1 - playerIndex, 'kl', -3);
            this.adjustStat(1 - playerIndex, 'essence', -3);
            this.log('Opponent loses 3 KL and 3 Essence!', 'damage');
        }
        else if (godCode === 'Final Arbitration') {
            const minEssence = Math.min(
                this.state.players[0].essence,
                this.state.players[1].essence
            );
            this.state.players[0].essence = minEssence;
            this.state.players[1].essence = minEssence;
            this.adjustStat(playerIndex, 'essence', 3);
            this.log(`Both Deities set to ${minEssence} Essence, then you gain 3!`, 'action');
        }
        else if (godCode === 'Call of the Crown Pride') {
            for (let i = 0; i < 3; i++) {
                const token = this.createCardInstance({
                    id: `TOKEN-${Date.now()}-${i}`,
                    name: 'Glow Beast Token',
                    type: 'Avatar',
                    aspects: ['Glow', 'Beast'],
                    cost: 0,
                    attack: 2,
                    health: 2,
                    effect: 'Guardian',
                    keywords: ['Guardian', 'Beast'],
                    image: CARD_BACK_URL
                });
                if (this.state.players[playerIndex].avatarRow.length < 5) {
                    this.state.players[playerIndex].avatarRow.push(token);
                }
            }
            this.adjustStat(playerIndex, 'essence', 3);
            this.log('Created 3 Glow Beast tokens with Guardian, restored 3 Essence!', 'heal');
        }
        else if (godCode === 'Absolute Schedule Lock') {
            this.log('Opponent cannot gain extra KL or draw extra cards next turn!', 'action');
        }
        else if (godCode === 'Golden Aura Cascade') {
            this.state.players[playerIndex].avatarRow.forEach(c => c.attack += 1);
            this.log('Your Avatars gain +1 Power and lifesteal this turn!', 'heal');
        }
        else if (godCode === 'Canon Rewrite') {
            const p = this.state.players[playerIndex];
            p.banished.push(...p.hand);
            p.hand = [];
            this.drawCardEffect(playerIndex, 5);
            this.log('Exiled hand, drew 5 cards! Spells cost 1 less this turn!', 'action');
        }
        else if (godCode === 'Sanctuary Eclipse') {
            const opponent = this.state.players[1 - playerIndex];
            let destroyed = 0;
            opponent.avatarRow = opponent.avatarRow.filter(c => {
                if (!isBeastCard(c) && destroyed < 2) {
                    opponent.graveyard.push(c);
                    destroyed++;
                    return false;
                }
                return true;
            });
            for (let i = 0; i < destroyed; i++) {
                const token = this.createCardInstance({
                    id: `TOKEN-${Date.now()}-${i}`,
                    name: 'Void Beast Token',
                    type: 'Avatar',
                    aspects: ['Void', 'Beast'],
                    cost: 0,
                    attack: 3,
                    health: 3,
                    keywords: ['Beast'],
                    image: CARD_BACK_URL
                });
                if (this.state.players[playerIndex].avatarRow.length < 5) {
                    this.state.players[playerIndex].avatarRow.push(token);
                }
            }
            this.log(`Destroyed ${destroyed} non-Beast Avatars, created ${destroyed} Void Beast tokens!`, 'damage');
        }
        else if (godCode === 'Final Shardstorm') {
            const opponent = this.state.players[1 - playerIndex];
            let sacrificed = 0;
            while (opponent.avatarRow.length > 0 && sacrificed < 2) {
                opponent.graveyard.push(opponent.avatarRow.pop());
                sacrificed++;
            }
            this.adjustStat(1 - playerIndex, 'essence', -4);
            this.state.players[playerIndex].avatarRow.forEach(c => c.attack += 2);
            this.log(`Opponent sacrificed ${sacrificed} Avatars, lost 4 Essence! Your Avatars gain +2 Power!`, 'damage');
        }
        else if (godCode === 'Stillpoint Rewrite') {
            const opponent = this.state.players[1 - playerIndex];
            opponent.avatarRow.forEach(c => c.tapped = true);
            opponent.domainRow.forEach(c => c.tapped = true);
            this.adjustStat(playerIndex, 'essence', 5);
            this.drawCardEffect(playerIndex, 3);
            this.log('Tapped all enemy Avatars, restored 5 Essence, drew 3 cards!', 'heal');
        }
        else {
            this.log(`${deity.godCode} activated!`, 'action');
        }
    },

    renderBoard() {
        console.log('=== RENDER BOARD CALLED ===');
        console.log('P1 Hand:', this.state.players[0].hand.length, 'cards');
        console.log('P1 Deck:', this.state.players[0].deck.length, 'cards');
        console.log('P1 Avatars:', this.state.players[0].avatarRow.length);
        console.log('P1 Domains:', this.state.players[0].domainRow.length);
        
        const zones = [
            { id: 'p1-avatar-row', data: this.state.players[0].avatarRow, player: 0 },
            { id: 'p1-domain-row', data: this.state.players[0].domainRow, player: 0 },
            { id: 'p1-relic-row', data: this.state.players[0].relicRow || [], player: 0 },
            { id: 'p2-avatar-row', data: this.state.players[1].avatarRow, player: 1 },
            { id: 'p2-domain-row', data: this.state.players[1].domainRow, player: 1 },
            { id: 'p2-relic-row', data: this.state.players[1].relicRow || [], player: 1 }
        ];
        
        zones.forEach(zone => {
            const container = document.getElementById(zone.id);
            if (!container) {
                console.warn('Zone not found:', zone.id);
                return;
            }
            
            const slots = container.querySelectorAll('.card-slot, .ec-card-slot, .avatar-slot, .relic-slot, .domain-slot');
            console.log(`Zone ${zone.id}: ${slots.length} slots, ${zone.data.length} cards`);
            
            slots.forEach((slot, i) => {
                const slotLabel = slot.querySelector('.slot-label');
                slot.innerHTML = '';
                if (slotLabel) slot.appendChild(slotLabel);
                
                if (zone.data[i]) {
                    const cardEl = this.createCardElement(zone.data[i], false, zone.player);
                    slot.appendChild(cardEl);
                    slot.classList.add('active');
                } else {
                    slot.classList.remove('active');
                }
            });
        });

        this.renderTurnIndicator();
        this.renderDeckPiles();
    },
    
    renderDeckPiles() {
        for (let p = 0; p < 2; p++) {
            const prefix = p === 0 ? 'p1' : 'p2';
            const player = this.state.players[p];
            
            const deckPile = document.getElementById(`${prefix}-deck-pile`);
            if (deckPile) {
                const stack = deckPile.querySelector('.deck-cards-stack');
                if (stack) {
                    stack.innerHTML = '';
                    const stackSize = Math.min(5, Math.ceil(player.deck.length / 10));
                    for (let i = 0; i < stackSize; i++) {
                        const card = document.createElement('div');
                        card.className = 'deck-stack-card';
                        card.style.bottom = `${i * 2}px`;
                        stack.appendChild(card);
                    }
                }
                const countEl = deckPile.querySelector('.deck-count');
                if (countEl) countEl.textContent = player.deck.length;
            }
            
            const voidPile = document.getElementById(`${prefix}-void-pile`);
            if (voidPile && player.exile) {
                voidPile.textContent = player.exile.length || 0;
            }
            
            const abyssPile = document.getElementById(`${prefix}-abyss-pile`);
            if (abyssPile && player.graveyard) {
                abyssPile.textContent = player.graveyard.length;
            }
        }
    },

    renderTurnIndicator() {
        const indicator = document.getElementById('turn-indicator');
        if (!indicator) return;
        
        indicator.textContent = `Player ${this.state.currentPlayer + 1}'s Turn`;
        indicator.className = `turn-indicator p${this.state.currentPlayer + 1}`;
    },

    renderHand() {
        const handContainer = document.getElementById('player-hand');
        if (!handContainer) {
            console.error('Hand container #player-hand not found!');
            return;
        }
        
        handContainer.innerHTML = '';
        
        const playerHand = this.state.players[0]?.hand || [];
        console.log('Rendering hand with', playerHand.length, 'cards');
        
        playerHand.forEach(card => {
            const cardEl = this.createCardElement(card, true);
            handContainer.appendChild(cardEl);
        });
        
        handContainer.style.display = 'flex';
    },

    createCardElement(card, isHand = false, playerIndex = 0) {
        const el = document.createElement('div');
        const aspectClass = card.aspects && card.aspects.length > 0 ? card.aspects[0].toLowerCase() : (card.aspect ? card.aspect.toLowerCase() : '');
        el.className = `game-card ${aspectClass}`;
        el.dataset.cardId = card.instanceId;
        if (card.tapped) el.classList.add('tapped');
        if (card.faceDown) el.classList.add('face-down');
        
        if (this.state.combat.selectedAttacker?.instanceId === card.instanceId) {
            el.classList.add('selected-attacker');
        }
        
        if (this.state.combat.mode === 'selectTarget' && playerIndex !== this.state.currentPlayer) {
            el.classList.add('valid-target');
        }
        
        if (this.state.spell.mode === 'selectTarget') {
            const targetType = this.state.spell.targetType;
            if ((targetType === 'avatar' || targetType === 'any') && card.type === 'Avatar') {
                el.classList.add('valid-spell-target');
            }
        }
        
        const hasStats = card.type === 'Avatar' && card.attack !== undefined;
        const healthPercent = hasStats ? ((card.healthCurrent || card.health) / card.health) * 100 : 100;
        
        const isGuardian = hasGuardian(card);
        const isCardBeast = isBeastCard(card);
        
        el.innerHTML = `
            <div class="card-front">
                <img class="card-image" src="${card.image}" alt="${card.name}">
                <div class="card-cost">${card.cost || 0}</div>
                ${isGuardian ? '<div class="guardian-badge">GUARD</div>' : ''}
                ${isCardBeast ? '<div class="beast-badge">BEAST</div>' : ''}
                <div class="card-info">
                    <div class="card-name">${card.name}</div>
                    ${hasStats ? `
                        <div class="card-stats">
                            <span class="stat attack">${card.attack}</span>
                            <span class="stat health">${card.healthCurrent || card.health}</span>
                        </div>
                        <div class="health-bar">
                            <div class="health-fill" style="width: ${healthPercent}%"></div>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
        
        el.oncontextmenu = (e) => this.showContextMenu(e, card);
        
        el.onmouseenter = () => this.showCardPreview(card);
        el.onmouseleave = () => this.hideCardPreview();
        el.ondblclick = (e) => {
            e.stopPropagation();
            this.showCardZoom(card);
        };
        
        if (isHand) {
            el.style.cursor = 'pointer';
            el.onclick = (e) => {
                e.stopPropagation();
                this.playCard(card, 0);
            };
        } else if (card.type === 'Avatar') {
            el.style.cursor = 'pointer';
            el.onclick = (e) => {
                e.stopPropagation();
                if (this.state.spell.mode === 'selectTarget') {
                    const targetType = this.state.spell.targetType;
                    if (targetType === 'avatar' || targetType === 'any') {
                        this.selectSpellTarget({ type: 'avatar', card: card, name: card.name }, playerIndex);
                    }
                } else if (this.state.combat.mode === 'selectAttacker') {
                    this.selectAttacker(card, playerIndex);
                } else if (this.state.combat.mode === 'selectTarget') {
                    this.selectTarget(card, playerIndex);
                } else if (this.state.currentPhase === 'clash' && playerIndex === this.state.currentPlayer) {
                    this.enterCombatMode();
                    this.selectAttacker(card, playerIndex);
                }
            };
        }
        
        return el;
    },

    showFullscreenPrompt() {
        document.getElementById('fullscreen-prompt').classList.remove('hidden');
    },

    hideFullscreenPrompt() {
        document.getElementById('fullscreen-prompt').classList.add('hidden');
        this.state.matchMode = 'casual';
        this.showDeitySelection(0);
    },
    
    closeWelcome() {
        document.getElementById('welcome-overlay').classList.add('hidden');
    },
    
    startWelcomeGame() {
        this.closeWelcome();
        this.state.matchMode = 'casual';
        this.showDeitySelection(0);
    },
    
    showQueueSelection() {
        const overlay = document.getElementById('queue-overlay');
        const tierInfo = Matchmaking.mmoToTier(Matchmaking.playerProfile.mmr);
        document.getElementById('player-rank-display').textContent = `${tierInfo.tier} ${tierInfo.level} (${Matchmaking.playerProfile.mmr} MMR)`;
        document.getElementById('player-stats-display').textContent = `W: ${Matchmaking.playerProfile.wins} / L: ${Matchmaking.playerProfile.losses}`;
        overlay.classList.remove('hidden');
    },
    
    hideQueueSelection() {
        document.getElementById('queue-overlay').classList.add('hidden');
    },
    
    joinQueue(mode) {
        this.state.matchMode = mode;
        this.hideQueueSelection();
        this.showFriendsScreen();
    },
    
    showFriendsScreen() {
        document.getElementById('friends-overlay').classList.remove('hidden');
        this.renderFriendsList();
    },
    
    hideFriendsScreen() {
        document.getElementById('friends-overlay').classList.add('hidden');
    },
    
    renderFriendsList() {
        const list = document.getElementById('friends-list');
        list.innerHTML = '';
        Matchmaking.friends.forEach(friend => {
            const status = Matchmaking.getFriendStatus(friend);
            const el = document.createElement('div');
            el.className = `friend-item ${status}`;
            el.innerHTML = `
                <div class="friend-info">
                    <span class="friend-name">${friend}</span>
                    <span class="friend-status">${status}</span>
                </div>
                <button class="challenge-btn" onclick="Game.startDirectChallenge('${friend}')">Challenge</button>
            `;
            list.appendChild(el);
        });
        
        const reqList = document.getElementById('friend-requests-list');
        reqList.innerHTML = '';
        Matchmaking.friendRequests.forEach(req => {
            const el = document.createElement('div');
            el.className = 'request-item';
            el.innerHTML = `
                <span>${req} wants to be friends</span>
                <button class="accept-btn" onclick="Game.acceptFriendRequest('${req}')">Accept</button>
                <button class="decline-btn" onclick="Game.declineFriendRequest('${req}')">Decline</button>
            `;
            reqList.appendChild(el);
        });
    },
    
    startDirectChallenge(friendName) {
        this.state.isPrivateMatch = true;
        this.state.challengeFriend = friendName;
        this.hideFriendsScreen();
        this.showDeitySelection(0);
    },
    
    addNewFriend() {
        const username = prompt('Enter friend username:');
        if (username && username.length > 0) {
            if (Matchmaking.addFriend(username)) {
                alert(`${username} added to friends!`);
                this.renderFriendsList();
            } else {
                alert('Friend already added or invalid username.');
            }
        }
    },
    
    acceptFriendRequest(username) {
        Matchmaking.acceptFriendRequest(username);
        alert(`${username} is now your friend!`);
        this.renderFriendsList();
    },
    
    declineFriendRequest(username) {
        Matchmaking.declineFriendRequest(username);
        this.renderFriendsList();
    },
    
    proceedToQueue() {
        this.hideFriendsScreen();
        this.showDeitySelection(0);
    },
    
    showReplayBrowser() {
        document.getElementById('replay-browser-overlay').classList.remove('hidden');
        this.renderReplayList();
    },
    
    hideReplayBrowser() {
        document.getElementById('replay-browser-overlay').classList.add('hidden');
    },
    
    renderReplayList() {
        const list = document.getElementById('replay-list');
        const replays = MatchRecorder.getAllReplays();
        
        if (replays.length === 0) {
            list.innerHTML = '<p class="no-replays">No replays saved yet. Play some matches!</p>';
            return;
        }
        
        list.innerHTML = replays.map(r => `
            <div class="replay-item" onclick="Game.loadReplay('${r.matchId}')">
                <div class="replay-matchup">
                    <span class="deity">${r.player1Deity}</span>
                    <span class="vs">vs</span>
                    <span class="deity">${r.player2Deity}</span>
                </div>
                <div class="replay-details">
                    <span class="turns">${r.turnCount} turns</span>
                    <span class="winner">P${r.winner + 1} wins</span>
                    <span class="date">${new Date(r.timestamp).toLocaleDateString()}</span>
                </div>
                <div class="replay-mode ${r.matchMode}">${r.matchMode.toUpperCase()}</div>
            </div>
        `).join('');
    },
    
    loadReplay(matchId) {
        this.hideReplayBrowser();
        ReplayViewer.loadReplay(matchId);
    },
    
    showSpectateBrowser() {
        document.getElementById('spectate-browser-overlay').classList.remove('hidden');
        this.renderLiveMatches();
    },
    
    hideSpectateBrowser() {
        document.getElementById('spectate-browser-overlay').classList.add('hidden');
    },
    
    renderLiveMatches() {
        const list = document.getElementById('live-matches-list');
        const matches = MatchRecorder.getLiveMatches();
        
        if (matches.length === 0) {
            list.innerHTML = '<p class="no-matches">No live matches available to spectate</p>';
            return;
        }
        
        list.innerHTML = matches.map(m => `
            <div class="live-match-item" onclick="Game.spectateMatch('${m.matchId}')">
                <span class="match-players">${m.player1Deity} vs ${m.player2Deity}</span>
                <span class="match-status">LIVE</span>
            </div>
        `).join('');
    },
    
    spectateMatch(matchId) {
        this.hideSpectateBrowser();
        SpectatorMode.startSpectating(matchId);
    },
    
    showAnalytics() {
        this.hideReplayBrowser();
        document.getElementById('analytics-overlay').classList.remove('hidden');
        this.switchAnalyticsTab('cards');
    },
    
    hideAnalytics() {
        document.getElementById('analytics-overlay').classList.add('hidden');
    },
    
    switchAnalyticsTab(tab) {
        document.querySelectorAll('.analytics-tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.analytics-tab[data-tab="${tab}"]`)?.classList.add('active');
        
        const content = document.getElementById('analytics-content');
        
        if (tab === 'cards') {
            const topCards = Analytics.getTopCards(15);
            if (topCards.length === 0) {
                content.innerHTML = '<p class="no-data">Play more matches to generate card statistics</p>';
                return;
            }
            content.innerHTML = `
                <table class="analytics-table">
                    <thead><tr><th>Card</th><th>Type</th><th>Played</th><th>Winrate</th></tr></thead>
                    <tbody>
                        ${topCards.map(c => `
                            <tr>
                                <td>${c.name}</td>
                                <td>${c.type}</td>
                                <td>${c.played}</td>
                                <td class="winrate">${Math.round(c.winrate)}%</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        } else if (tab === 'archetypes') {
            const archetypes = Analytics.getArchetypeStats();
            if (archetypes.length === 0) {
                content.innerHTML = '<p class="no-data">Play more matches to generate archetype data</p>';
                return;
            }
            content.innerHTML = `
                <table class="analytics-table">
                    <thead><tr><th>Archetype</th><th>Matches</th><th>Winrate</th></tr></thead>
                    <tbody>
                        ${archetypes.map(a => `
                            <tr>
                                <td>${a.name}</td>
                                <td>${a.total}</td>
                                <td class="winrate">${a.winrate}%</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        } else if (tab === 'history') {
            const history = Analytics.data.matchHistory.slice(-20).reverse();
            if (history.length === 0) {
                content.innerHTML = '<p class="no-data">No match history yet</p>';
                return;
            }
            content.innerHTML = `
                <table class="analytics-table">
                    <thead><tr><th>Match</th><th>Winner</th><th>Turns</th><th>Mode</th></tr></thead>
                    <tbody>
                        ${history.map(h => `
                            <tr>
                                <td>${h.player1Deity} vs ${h.player2Deity}</td>
                                <td>P${h.winner + 1}</td>
                                <td>${h.turnCount}</td>
                                <td>${h.matchMode}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }
    },
    
    exportAnalytics() {
        const data = Analytics.export();
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'essence-crown-analytics.json';
        a.click();
        URL.revokeObjectURL(url);
    },
    
    showTournaments() {
        this.hideQueueSelection();
        document.getElementById('tournament-overlay').classList.remove('hidden');
        this.switchTournamentTab('open');
    },
    
    hideTournaments() {
        document.getElementById('tournament-overlay').classList.add('hidden');
        this.showQueueSelection();
    },
    
    switchTournamentTab(tab) {
        document.querySelectorAll('.tournament-tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.tournament-tab[data-tab="${tab}"]`)?.classList.add('active');
        
        const content = document.getElementById('tournament-content');
        
        if (tab === 'open') {
            const tournaments = TournamentManager.getOpenTournaments();
            if (tournaments.length === 0) {
                content.innerHTML = '<p class="no-tournaments">No open tournaments. Create one!</p>';
                return;
            }
            content.innerHTML = `<div class="tournament-list">${tournaments.map(t => this.renderTournamentItem(t)).join('')}</div>`;
        } else if (tab === 'active') {
            const tournaments = TournamentManager.getActiveTournaments();
            if (tournaments.length === 0) {
                content.innerHTML = '<p class="no-tournaments">No active tournaments</p>';
                return;
            }
            content.innerHTML = `<div class="tournament-list">${tournaments.map(t => this.renderTournamentItem(t)).join('')}</div>`;
        } else if (tab === 'completed') {
            const tournaments = TournamentManager.tournaments.filter(t => t.status === 'completed');
            if (tournaments.length === 0) {
                content.innerHTML = '<p class="no-tournaments">No completed tournaments</p>';
                return;
            }
            content.innerHTML = `<div class="tournament-list">${tournaments.map(t => this.renderTournamentItem(t)).join('')}</div>`;
        } else if (tab === 'create') {
            content.innerHTML = this.renderCreateTournamentForm();
        }
    },
    
    renderTournamentItem(t) {
        const eventName = t.eventId ? (EventManager.getEvent(t.eventId)?.name || 'Standard') : 'Standard';
        return `
            <div class="tournament-item" onclick="Game.viewTournament('${t.id}')">
                <div class="tournament-info">
                    <span class="tournament-name">${t.name}</span>
                    <div class="tournament-meta">
                        <span class="tournament-format ${t.format}">${t.format.toUpperCase()}</span>
                        <span class="tournament-players">${t.players.length}/${t.maxPlayers} players</span>
                        <span>${eventName}</span>
                    </div>
                </div>
                <span class="tournament-status ${t.status}">${t.status}</span>
            </div>
        `;
    },
    
    renderCreateTournamentForm() {
        const events = EventManager.getActiveEvents();
        return `
            <div class="create-tournament-form">
                <div class="form-group">
                    <label>Tournament Name</label>
                    <input type="text" id="create-tourney-name" placeholder="My Tournament" value="Shard Wars Championship">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label>Format</label>
                        <select id="create-tourney-format">
                            <option value="swiss">Swiss (Best for casual)</option>
                            <option value="elimination">Single Elimination</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Max Players</label>
                        <select id="create-tourney-players">
                            <option value="4">4 Players</option>
                            <option value="8" selected>8 Players</option>
                            <option value="16">16 Players</option>
                            <option value="32">32 Players</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label>Event / Format Rules</label>
                    <select id="create-tourney-event">
                        <option value="">Standard (No Restrictions)</option>
                        ${events.map(e => `<option value="${e.id}">${e.icon} ${e.name}</option>`).join('')}
                    </select>
                </div>
                <button class="create-btn" onclick="Game.createTournament()">CREATE TOURNAMENT</button>
            </div>
        `;
    },
    
    createTournament() {
        const name = document.getElementById('create-tourney-name').value || 'Shard Wars Tournament';
        const format = document.getElementById('create-tourney-format').value;
        const maxPlayers = parseInt(document.getElementById('create-tourney-players').value);
        const eventId = document.getElementById('create-tourney-event').value || null;
        
        const tournament = TournamentManager.createTournament({
            name, format, maxPlayers, eventId
        });
        
        this.log(`Created tournament: ${name}`, 'action');
        this.viewTournament(tournament.id);
    },
    
    viewTournament(tournamentId) {
        TournamentManager.setActiveTournament(tournamentId);
        const t = TournamentManager.activeTournament;
        if (!t) return;
        
        document.getElementById('tournament-overlay').classList.add('hidden');
        document.getElementById('tournament-detail-overlay').classList.remove('hidden');
        
        document.getElementById('tournament-detail-name').textContent = t.name;
        document.getElementById('tournament-detail-status').textContent = t.status;
        document.getElementById('tournament-detail-status').className = `tournament-status ${t.status}`;
        document.getElementById('tournament-detail-format').textContent = t.format.toUpperCase();
        document.getElementById('tournament-detail-players').textContent = `${t.players.length}/${t.maxPlayers}`;
        document.getElementById('tournament-detail-round').textContent = `${t.currentRound}/${t.maxRounds}`;
        
        const eventRow = document.getElementById('tournament-event-row');
        if (t.eventId) {
            const event = EventManager.getEvent(t.eventId);
            document.getElementById('tournament-detail-event').textContent = event ? `${event.icon} ${event.name}` : 'Standard';
            eventRow.style.display = 'flex';
        } else {
            eventRow.style.display = 'none';
        }
        
        this.updateTournamentActions(t);
        this.switchTournamentDetailTab('matches');
    },
    
    updateTournamentActions(t) {
        const actions = document.getElementById('tournament-actions');
        const playerId = Matchmaking.playerProfile.playerId;
        const isRegistered = t.players.find(p => p.playerId === playerId);
        
        let html = '';
        
        if (t.status === 'registration') {
            if (isRegistered) {
                html = `<button class="action-btn danger" onclick="Game.unregisterFromTournament()">Leave Tournament</button>`;
            } else if (t.players.length < t.maxPlayers) {
                html = `<button class="action-btn primary" onclick="Game.registerForTournament()">Join Tournament</button>`;
            }
            if (t.players.length >= 2) {
                html += `<button class="action-btn secondary" onclick="Game.startTournament()">Start Tournament</button>`;
            }
        } else if (t.status === 'active') {
            const myMatch = TournamentManager.getPlayerMatch(t.id, playerId);
            if (myMatch) {
                html = `<button class="action-btn primary" onclick="Game.playTournamentMatch('${myMatch.matchId}')">Play Match</button>`;
            }
        }
        
        actions.innerHTML = html;
    },
    
    registerForTournament() {
        const t = TournamentManager.activeTournament;
        if (!t) return;
        
        const result = TournamentManager.registerPlayer(t.id, Matchmaking.playerProfile);
        if (result.success) {
            this.log(`Registered for ${t.name}`, 'action');
            this.viewTournament(t.id);
        } else {
            this.log(result.error, 'damage');
        }
    },
    
    unregisterFromTournament() {
        const t = TournamentManager.activeTournament;
        if (!t) return;
        
        const result = TournamentManager.unregisterPlayer(t.id, Matchmaking.playerProfile.playerId);
        if (result.success) {
            this.log(`Left tournament`, 'action');
            this.viewTournament(t.id);
        }
    },
    
    startTournament() {
        const t = TournamentManager.activeTournament;
        if (!t) return;
        
        const result = TournamentManager.startTournament(t.id);
        if (result.success) {
            this.log(`Tournament started!`, 'phase');
            this.viewTournament(t.id);
        } else {
            this.log(result.error, 'damage');
        }
    },
    
    playTournamentMatch(matchId) {
        const t = TournamentManager.activeTournament;
        if (!t) return;
        
        TournamentManager.currentMatch = matchId;
        this.state.matchMode = 'tournament';
        this.state.tournamentId = t.id;
        this.state.tournamentMatchId = matchId;
        
        if (t.eventId) {
            EventManager.setActiveEvent(t.eventId);
        }
        
        document.getElementById('tournament-detail-overlay').classList.add('hidden');
        this.showDeitySelection(0);
    },
    
    reportTournamentResult(winnerId) {
        const t = TournamentManager.activeTournament;
        if (!t || !this.state.tournamentMatchId) return;
        
        const result = TournamentManager.reportMatchResult(t.id, this.state.tournamentMatchId, winnerId, '2-0');
        
        this.state.tournamentMatchId = null;
        TournamentManager.currentMatch = null;
        EventManager.clearActiveEvent();
    },
    
    switchTournamentDetailTab(tab) {
        document.querySelectorAll('.detail-tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.detail-tab[data-tab="${tab}"]`)?.classList.add('active');
        
        const content = document.getElementById('tournament-detail-content');
        const t = TournamentManager.activeTournament;
        if (!t) return;
        
        if (tab === 'matches') {
            const matches = TournamentManager.getCurrentMatches(t.id);
            if (matches.length === 0) {
                content.innerHTML = '<p class="no-tournaments">No matches in current round</p>';
                return;
            }
            content.innerHTML = `
                <div class="matches-list">
                    ${matches.map(m => `
                        <div class="match-item">
                            <div class="match-players">
                                <span class="match-player ${m.winner === m.player1 ? 'winner' : ''}">${m.player1Name}</span>
                                <span class="match-vs">VS</span>
                                <span class="match-player ${m.winner === m.player2 ? 'winner' : ''}">${m.player2Name}</span>
                            </div>
                            <span class="match-result ${m.reported ? 'completed' : 'pending'}">
                                ${m.reported ? (m.result || 'Completed') : 'Pending'}
                            </span>
                        </div>
                    `).join('')}
                </div>
            `;
        } else if (tab === 'standings') {
            const standings = TournamentManager.getStandings(t.id);
            content.innerHTML = `
                <table class="standings-table">
                    <thead><tr><th>#</th><th>Player</th><th>W-L</th><th>Points</th><th>OWR</th></tr></thead>
                    <tbody>
                        ${standings.map((p, i) => `
                            <tr>
                                <td class="rank">${i + 1}</td>
                                <td>${p.username}</td>
                                <td>${p.wins}-${p.losses}</td>
                                <td>${p.matchPoints}</td>
                                <td>${Math.round(p.opponentWinRate * 100)}%</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        } else if (tab === 'bracket') {
            if (t.format !== 'elimination') {
                content.innerHTML = '<p class="no-tournaments">Bracket view only for elimination tournaments</p>';
                return;
            }
            content.innerHTML = this.renderBracket(t);
        }
    },
    
    renderBracket(t) {
        if (t.rounds.length === 0) return '<p class="no-tournaments">Tournament not started</p>';
        
        const roundNames = ['Round 1', 'Quarterfinals', 'Semifinals', 'Finals'];
        
        return `
            <div class="bracket-container">
                ${t.rounds.map((round, idx) => `
                    <div class="bracket-round">
                        <div class="bracket-round-title">${roundNames[idx] || `Round ${idx + 1}`}</div>
                        ${round.matches.map(m => `
                            <div class="bracket-match">
                                <div class="bracket-player ${m.winner === m.player1 ? 'winner' : ''}">
                                    <span>${m.player1Name}</span>
                                    <span class="score">${m.winner === m.player1 ? 'W' : ''}</span>
                                </div>
                                <div class="bracket-player ${m.winner === m.player2 ? 'winner' : ''}">
                                    <span>${m.player2Name}</span>
                                    <span class="score">${m.winner === m.player2 ? 'W' : ''}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `).join('')}
            </div>
        `;
    },
    
    backToTournaments() {
        document.getElementById('tournament-detail-overlay').classList.add('hidden');
        document.getElementById('tournament-overlay').classList.remove('hidden');
        this.switchTournamentTab('open');
    },
    
    showEvents() {
        this.hideQueueSelection();
        document.getElementById('events-overlay').classList.remove('hidden');
        this.renderEvents();
    },
    
    hideEvents() {
        document.getElementById('events-overlay').classList.add('hidden');
        this.showQueueSelection();
    },
    
    renderEvents() {
        const events = EventManager.getActiveEvents();
        const list = document.getElementById('events-list');
        
        if (events.length === 0) {
            list.innerHTML = '<p class="no-tournaments">No special events available</p>';
            return;
        }
        
        list.innerHTML = events.map(e => `
            <div class="event-card" onclick="Game.selectEvent('${e.id}')">
                <div class="event-card-header">
                    <span class="event-icon">${e.icon}</span>
                    <h3>${e.name}</h3>
                </div>
                <p class="event-card-description">${e.description}</p>
                <div class="event-card-meta">
                    ${e.rules.allowedAspects.map(a => `<span class="event-tag aspect-${a.toLowerCase()}">${a}</span>`).join('')}
                    ${e.rules.bannedTypes.map(t => `<span class="event-tag">No ${t}s</span>`).join('')}
                    <span class="event-tag">${e.format.toUpperCase()}</span>
                </div>
            </div>
        `).join('');
    },
    
    selectedEventId: null,
    
    selectEvent(eventId) {
        const event = EventManager.getEvent(eventId);
        if (!event) return;
        
        this.selectedEventId = eventId;
        
        document.getElementById('events-overlay').classList.add('hidden');
        document.getElementById('event-queue-overlay').classList.remove('hidden');
        
        document.querySelector('#event-queue-header .event-icon').textContent = event.icon;
        document.getElementById('event-queue-name').textContent = event.name;
        
        const rulesDiv = document.getElementById('event-queue-rules');
        rulesDiv.innerHTML = `
            <div class="event-rule">
                <span class="rule-label">Allowed Aspects</span>
                <span class="rule-value">${event.rules.allowedAspects.join(', ') || 'All'}</span>
            </div>
            ${event.rules.bannedTypes.length > 0 ? `
                <div class="event-rule">
                    <span class="rule-label">Banned Types</span>
                    <span class="rule-value">${event.rules.bannedTypes.join(', ')}</span>
                </div>
            ` : ''}
            <div class="event-rule">
                <span class="rule-label">Starting Essence</span>
                <span class="rule-value">${event.rules.startingEssence}</span>
            </div>
            <div class="event-rule">
                <span class="rule-label">Starting KL</span>
                <span class="rule-value">${event.rules.startingKL}</span>
            </div>
            <div class="event-rule">
                <span class="rule-label">Format</span>
                <span class="rule-value">${event.format.toUpperCase()}</span>
            </div>
        `;
    },
    
    hideEventQueue() {
        document.getElementById('event-queue-overlay').classList.add('hidden');
        this.showEvents();
    },
    
    joinEventQueue() {
        if (!this.selectedEventId) return;
        
        EventManager.setActiveEvent(this.selectedEventId);
        this.state.matchMode = 'event';
        this.state.eventId = this.selectedEventId;
        
        document.getElementById('event-queue-overlay').classList.add('hidden');
        this.showDeitySelection(0);
    },

    showLimited() {
        this.hideQueueSelection();
        LimitedMode.init();
        
        if (LimitedMode.sealedActive) {
            this.showSealedDeckbuilder();
        } else {
            document.getElementById('limited-overlay').classList.remove('hidden');
        }
    },
    
    hideLimited() {
        document.getElementById('limited-overlay').classList.add('hidden');
        this.showQueueSelection();
    },
    
    startSealed() {
        LimitedMode.generateSealedPool();
        document.getElementById('limited-overlay').classList.add('hidden');
        this.showSealedDeckbuilder();
    },
    
    showSealedDeckbuilder() {
        document.getElementById('sealed-deckbuilder-overlay').classList.remove('hidden');
        this.renderSealedDeckbuilder();
    },
    
    renderSealedDeckbuilder() {
        const pool = LimitedMode.currentPool;
        const deck = LimitedMode.currentDeck;
        
        document.getElementById('sealed-deck-count').textContent = `Deck: ${deck.length}/${LimitedMode.sealedConfig.minDeckSize}-${LimitedMode.sealedConfig.maxDeckSize}`;
        document.getElementById('sealed-pool-count').textContent = `Pool: ${pool.length}`;
        
        const poolGrid = document.getElementById('sealed-pool');
        poolGrid.innerHTML = pool.map(card => `
            <div class="sealed-card" onclick="Game.addCardToDeck('${card.instanceId}')" 
                 style="background-image: url('${card.image || CARD_BACK_URL}')"
                 title="${card.name} - ${card.rarity}">
                <div class="rarity-indicator ${card.rarity}"></div>
            </div>
        `).join('');
        
        const deckGrid = document.getElementById('sealed-deck');
        deckGrid.innerHTML = deck.map(card => `
            <div class="sealed-card" onclick="Game.removeCardFromDeck('${card.instanceId}')"
                 style="background-image: url('${card.image || CARD_BACK_URL}')"
                 title="${card.name} - ${card.rarity}">
                <div class="rarity-indicator ${card.rarity}"></div>
            </div>
        `).join('');
        
        const playBtn = document.getElementById('sealed-play-btn');
        playBtn.disabled = !LimitedMode.isDeckValid();
    },
    
    addCardToDeck(cardInstanceId) {
        const result = LimitedMode.addToDeck(cardInstanceId);
        if (result.success) {
            this.renderSealedDeckbuilder();
        }
    },
    
    removeCardFromDeck(cardInstanceId) {
        const result = LimitedMode.removeFromDeck(cardInstanceId);
        if (result.success) {
            this.renderSealedDeckbuilder();
        }
    },
    
    exitSealed() {
        if (confirm('Abandon your sealed pool? This cannot be undone.')) {
            LimitedMode.endSealed();
            document.getElementById('sealed-deckbuilder-overlay').classList.add('hidden');
            this.showQueueSelection();
        }
    },
    
    playSealedDeck() {
        if (!LimitedMode.isDeckValid()) return;
        
        this.state.matchMode = 'sealed';
        this.state.sealedDeck = LimitedMode.getDeckForGame();
        
        document.getElementById('sealed-deckbuilder-overlay').classList.add('hidden');
        this.showDeitySelection(0);
    },
    
    showCosmetics() {
        this.hideQueueSelection();
        CosmeticsManager.init();
        document.getElementById('cosmetics-overlay').classList.remove('hidden');
        document.getElementById('cosmetics-currency').textContent = ShardPath.getCurrency();
        this.showCosmeticType('cardBack');
    },
    
    hideCosmetics() {
        document.getElementById('cosmetics-overlay').classList.add('hidden');
        this.showQueueSelection();
    },
    
    showCosmeticType(type) {
        document.querySelectorAll('.cosmetic-tab').forEach(t => {
            t.classList.toggle('active', t.dataset.type === type);
        });
        
        const cosmetics = CosmeticsManager.getCosmeticsByType(type);
        const grid = document.getElementById('cosmetics-grid');
        
        grid.innerHTML = cosmetics.map(c => {
            const owned = CosmeticsManager.isOwned(c.id);
            const equipped = CosmeticsManager.getEquipped(type, c.deityId) === c.id;
            
            return `
                <div class="cosmetic-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''}">
                    <div class="cosmetic-preview">${this.getCosmeticPreviewIcon(c)}</div>
                    <h3>${c.name}</h3>
                    <div class="cosmetic-rarity ${c.rarity}">${c.rarity}</div>
                    ${!owned ? `
                        <div class="cosmetic-price">
                            <span class="shard-icon">üíé</span>
                            <span>${c.price}</span>
                        </div>
                        <button class="cosmetic-btn purchase" onclick="Game.purchaseCosmetic('${c.id}')">Purchase</button>
                    ` : equipped ? `
                        <button class="cosmetic-btn equipped">Equipped</button>
                    ` : `
                        <button class="cosmetic-btn equip" onclick="Game.equipCosmetic('${c.id}')">Equip</button>
                    `}
                </div>
            `;
        }).join('');
    },
    
    getCosmeticPreviewIcon(cosmetic) {
        const icons = {
            cardBack: 'üé¥',
            boardSkin: 'üåç',
            cardFrame: 'üñºÔ∏è',
            effectVariant: '‚ú®',
            deitySkin: 'üëë'
        };
        return icons[cosmetic.type] || 'üéÅ';
    },
    
    purchaseCosmetic(id) {
        const result = CosmeticsManager.purchase(id);
        if (result.success) {
            document.getElementById('cosmetics-currency').textContent = ShardPath.getCurrency();
            const cosmetic = CosmeticsManager.getCosmetic(id);
            this.showCosmeticType(cosmetic.type);
        } else {
            alert(result.error);
        }
    },
    
    equipCosmetic(id) {
        const result = CosmeticsManager.equip(id);
        if (result.success) {
            const cosmetic = CosmeticsManager.getCosmetic(id);
            this.showCosmeticType(cosmetic.type);
        }
    },
    
    showShardPath() {
        this.hideQueueSelection();
        ShardPath.init();
        document.getElementById('shard-path-overlay').classList.remove('hidden');
        this.renderShardPath();
    },
    
    hideShardPath() {
        document.getElementById('shard-path-overlay').classList.add('hidden');
        this.showQueueSelection();
    },
    
    renderShardPath() {
        const progress = ShardPath.getProgress();
        
        document.getElementById('shard-path-season').textContent = progress.seasonName.toUpperCase();
        
        const daysRemaining = Math.ceil((progress.seasonEnd - Date.now()) / (24 * 60 * 60 * 1000));
        document.getElementById('shard-path-timer').textContent = `${Math.max(0, daysRemaining)} days remaining`;
        
        document.getElementById('shard-path-level').textContent = `Level ${progress.level}`;
        document.getElementById('shard-path-xp-fill').style.width = `${progress.percentage}%`;
        document.getElementById('shard-path-xp').textContent = `${progress.xp} / ${progress.xpRequired} XP`;
        document.getElementById('shard-path-currency').textContent = progress.currency;
        
        document.getElementById('premium-status').textContent = progress.premiumUnlocked ? '‚úì' : 'üîí';
        document.getElementById('premium-status').className = progress.premiumUnlocked ? 'unlocked' : 'locked';
        
        this.renderRewardTracks();
        this.renderQuests();
    },
    
    renderRewardTracks() {
        const progress = ShardPath.getProgress();
        
        const freeTrack = document.getElementById('free-track-rewards');
        freeTrack.innerHTML = ShardPath.rewards.free.map(r => this.renderRewardNode(r, false, progress.level)).join('');
        
        const premiumTrack = document.getElementById('premium-track-rewards');
        premiumTrack.innerHTML = ShardPath.rewards.premium.map(r => this.renderRewardNode(r, true, progress.level)).join('');
    },
    
    renderRewardNode(reward, isPremium, currentLevel) {
        const unlocked = currentLevel >= reward.level;
        const claimed = ShardPath.isRewardClaimed(reward.level, isPremium);
        const canClaim = unlocked && !claimed && (isPremium ? ShardPath.data.premiumUnlocked : true);
        
        const icon = reward.type === 'currency' ? 'üíé' : 'üéÅ';
        
        return `
            <div class="reward-node ${unlocked ? 'unlocked' : 'locked'} ${claimed ? 'claimed' : ''}">
                <div class="reward-level">Level ${reward.level}</div>
                <div class="reward-icon">${icon}</div>
                <div class="reward-name">${reward.name}</div>
                <button class="reward-claim-btn ${canClaim ? 'claim' : claimed ? 'claimed' : 'locked'}"
                        onclick="${canClaim ? `Game.claimPathReward(${reward.level}, ${isPremium})` : ''}"
                        ${!canClaim ? 'disabled' : ''}>
                    ${claimed ? 'Claimed' : canClaim ? 'Claim' : 'Locked'}
                </button>
            </div>
        `;
    },
    
    renderQuests() {
        const dailyContainer = document.getElementById('daily-quests');
        dailyContainer.innerHTML = ShardPath.data.dailyQuests.map(q => this.renderQuestItem(q, false)).join('');
        
        const weeklyContainer = document.getElementById('weekly-quests');
        weeklyContainer.innerHTML = ShardPath.data.weeklyQuests.map(q => this.renderQuestItem(q, true)).join('');
    },
    
    renderQuestItem(quest, isWeekly) {
        const progressPercent = Math.min(100, (quest.progress / quest.target) * 100);
        
        return `
            <div class="quest-item ${quest.completed ? 'completed' : ''} ${quest.claimed ? 'claimed' : ''}">
                <div class="quest-info">
                    <h4>${quest.name}</h4>
                    <p>${quest.description}</p>
                </div>
                <div class="quest-progress">
                    <div class="quest-progress-bar">
                        <div class="quest-progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <span class="quest-progress-text">${quest.progress}/${quest.target}</span>
                </div>
                <div class="quest-reward">
                    <span>+${quest.xp} XP</span>
                </div>
                <button class="quest-claim-btn ${quest.completed && !quest.claimed ? 'claim' : ''}"
                        onclick="Game.claimQuestReward('${quest.id}', ${isWeekly})"
                        ${!quest.completed || quest.claimed ? 'disabled' : ''}>
                    ${quest.claimed ? 'Claimed' : quest.completed ? 'Claim' : 'In Progress'}
                </button>
            </div>
        `;
    },
    
    showShardPathTab(tab) {
        document.querySelectorAll('.path-tab').forEach(t => {
            t.classList.toggle('active', t.dataset.tab === tab);
        });
        
        document.getElementById('shard-path-content').classList.toggle('hidden', tab !== 'rewards');
        document.getElementById('shard-path-quests').classList.toggle('hidden', tab !== 'quests');
    },
    
    claimPathReward(level, isPremium) {
        const result = ShardPath.claimReward(level, isPremium);
        if (result.success) {
            this.renderShardPath();
        }
    },
    
    claimQuestReward(questId, isWeekly) {
        const result = ShardPath.claimQuestReward(questId, isWeekly);
        if (result.success) {
            this.renderShardPath();
        }
    },
    
    showSandbox() {
        document.getElementById('queue-overlay').classList.add('hidden');
        document.getElementById('sandbox-overlay').classList.remove('hidden');
        
        this.state.selectedDeities = [getDeities()[0], getDeities()[1]];
        this.startGame();
        SandboxMode.enter();
        
        this.renderSandboxSavedStates();
        this.searchSandboxCards('');
    },
    
    hideSandbox() {
        document.getElementById('sandbox-overlay').classList.add('hidden');
        SandboxMode.exit();
        this.proceedToQueue();
    },
    
    searchSandboxCards(query) {
        const container = document.getElementById('sandbox-card-results');
        if (!container) return;
        
        const q = query.toLowerCase();
        const cards = ALL_CARDS
            .filter(c => c.type !== 'Deity')
            .filter(c => !q || c.name.toLowerCase().includes(q) || c.type.toLowerCase().includes(q))
            .slice(0, 30);
        
        container.innerHTML = cards.map(c => `
            <div class="sandbox-card-item" onclick="Game.addSandboxCard('${c.id}')">
                <div class="card-name">${c.name}</div>
                <div class="card-type">${c.type} - ${c.aspect || 'Neutral'}</div>
            </div>
        `).join('');
    },
    
    addSandboxCard(cardId) {
        const playerIndex = parseInt(document.getElementById('sandbox-player-select').value);
        const zone = document.getElementById('sandbox-zone-select').value;
        SandboxMode.addCardToZone(playerIndex, cardId, zone);
    },
    
    sandboxApplyPlayer(playerIndex) {
        const prefix = playerIndex === 0 ? 'p1' : 'p2';
        const essence = document.getElementById(`sandbox-${prefix}-essence`).value;
        const kl = document.getElementById(`sandbox-${prefix}-kl`).value;
        const klMax = document.getElementById(`sandbox-${prefix}-kl-max`).value;
        
        SandboxMode.setEssence(playerIndex, essence);
        SandboxMode.setKL(playerIndex, kl, klMax);
    },
    
    sandboxSaveState() {
        const name = document.getElementById('sandbox-state-name').value || `State ${Date.now()}`;
        SandboxMode.saveState(name);
        document.getElementById('sandbox-state-name').value = '';
        this.renderSandboxSavedStates();
    },
    
    renderSandboxSavedStates() {
        const container = document.getElementById('sandbox-saved-states');
        if (!container) return;
        
        container.innerHTML = SandboxMode.savedStates.map((state, idx) => `
            <div class="sandbox-state-item">
                <div>
                    <span class="state-name">${state.name}</span>
                    <span class="state-date">${new Date(state.timestamp).toLocaleDateString()}</span>
                </div>
                <button class="sandbox-btn" onclick="Game.loadSandboxState(${idx})">Load</button>
            </div>
        `).join('') || '<p style="color:rgba(255,255,255,0.5);text-align:center;">No saved states</p>';
    },
    
    loadSandboxState(index) {
        SandboxMode.loadState(index);
    },
    
    sandboxStartGame() {
        document.getElementById('sandbox-overlay').classList.add('hidden');
        SandboxMode.startGame();
    },
    
    showCustomLobby() {
        document.getElementById('queue-overlay').classList.add('hidden');
        document.getElementById('custom-lobby-overlay').classList.remove('hidden');
        this.showLobbyTab('create');
        this.refreshLobbies();
    },
    
    hideCustomLobby() {
        document.getElementById('custom-lobby-overlay').classList.add('hidden');
        this.proceedToQueue();
    },
    
    showLobbyTab(tab) {
        document.querySelectorAll('.lobby-tab').forEach(t => {
            t.classList.toggle('active', t.textContent.toLowerCase().includes(tab));
        });
        
        document.getElementById('lobby-create-tab').classList.toggle('hidden', tab !== 'create');
        document.getElementById('lobby-browse-tab').classList.toggle('hidden', tab !== 'browse');
    },
    
    applyLobbyPreset() {
        const preset = document.getElementById('lobby-preset').value;
        if (!preset) return;
        
        const p = CustomLobby.presets[preset];
        if (!p) return;
        
        document.getElementById('lobby-name').value = p.name;
        document.getElementById('lobby-essence').value = p.essence;
        document.getElementById('lobby-kl').value = p.kl;
        document.getElementById('lobby-victory').value = p.victory;
        
        if (p.victory === 'avatars') {
            document.getElementById('lobby-avatar-count-row').style.display = 'flex';
            document.getElementById('lobby-avatar-count').value = p.avatarWinCount || 5;
        } else {
            document.getElementById('lobby-avatar-count-row').style.display = 'none';
        }
        
        document.getElementById('lobby-aspect-glow').checked = !p.aspects || p.aspects.includes('Glow');
        document.getElementById('lobby-aspect-void').checked = !p.aspects || p.aspects.includes('Void');
        document.getElementById('lobby-aspect-gray').checked = !p.aspects || p.aspects.includes('Gray');
        
        document.getElementById('lobby-type-avatar').checked = !p.types || p.types.includes('Avatar');
        document.getElementById('lobby-type-spell').checked = !p.types || p.types.includes('Spell');
        document.getElementById('lobby-type-domain').checked = !p.types || p.types.includes('Domain');
        document.getElementById('lobby-type-relic').checked = !p.types || p.types.includes('Relic');
    },
    
    createCustomLobby() {
        const aspects = [];
        if (document.getElementById('lobby-aspect-glow').checked) aspects.push('Glow');
        if (document.getElementById('lobby-aspect-void').checked) aspects.push('Void');
        if (document.getElementById('lobby-aspect-gray').checked) aspects.push('Gray');
        
        const types = [];
        if (document.getElementById('lobby-type-avatar').checked) types.push('Avatar');
        if (document.getElementById('lobby-type-spell').checked) types.push('Spell');
        if (document.getElementById('lobby-type-domain').checked) types.push('Domain');
        if (document.getElementById('lobby-type-relic').checked) types.push('Relic');
        
        const settings = {
            name: document.getElementById('lobby-name').value || 'Custom Match',
            essence: parseInt(document.getElementById('lobby-essence').value) || 23,
            kl: parseInt(document.getElementById('lobby-kl').value) || 3,
            aspects: aspects.length === 3 ? null : aspects,
            types: types.length === 4 ? null : types,
            victory: document.getElementById('lobby-victory').value,
            avatarWinCount: parseInt(document.getElementById('lobby-avatar-count').value) || 5,
            preset: document.getElementById('lobby-preset').value || null
        };
        
        const playerName = this.state.playerName || 'Player';
        const lobby = CustomLobby.create(playerName, settings);
        
        document.getElementById('custom-lobby-overlay').classList.add('hidden');
        this.showLobbyWaiting(lobby);
    },
    
    showLobbyWaiting(lobby) {
        document.getElementById('lobby-waiting-overlay').classList.remove('hidden');
        document.getElementById('lobby-waiting-name').textContent = lobby.settings.name;
        
        const summary = document.getElementById('lobby-rules-summary');
        summary.innerHTML = `
            <p><strong>Essence:</strong> ${lobby.settings.startingEssence}</p>
            <p><strong>Starting KL:</strong> ${lobby.settings.startingKL}</p>
            <p><strong>Victory:</strong> ${lobby.settings.victoryCondition === 'avatars' 
                ? `Destroy ${lobby.settings.avatarWinCount} Avatars` 
                : 'Reduce Essence to 0'}</p>
            ${lobby.settings.allowedAspects 
                ? `<p><strong>Aspects:</strong> ${lobby.settings.allowedAspects.join(', ')}</p>` 
                : ''}
            ${lobby.settings.allowedTypes 
                ? `<p><strong>Types:</strong> ${lobby.settings.allowedTypes.join(', ')}</p>` 
                : ''}
        `;
        
        this.renderLobbyPlayers(lobby);
        this.simulateLobbyJoin(lobby);
    },
    
    renderLobbyPlayers(lobby) {
        const container = document.getElementById('lobby-player-list');
        container.innerHTML = lobby.players.map((p, i) => `
            <div class="lobby-player-item ${i === 0 ? 'host' : ''}">${p}</div>
        `).join('');
        
        const startBtn = document.getElementById('lobby-start-btn');
        if (lobby.players.length >= 2) {
            startBtn.disabled = false;
            startBtn.textContent = 'START MATCH';
        } else {
            startBtn.disabled = true;
            startBtn.textContent = 'Waiting for opponent...';
        }
    },
    
    simulateLobbyJoin(lobby) {
        setTimeout(() => {
            if (CustomLobby.currentLobby?.id === lobby.id && lobby.players.length < 2) {
                lobby.players.push('Opponent');
                this.renderLobbyPlayers(lobby);
            }
        }, 2000);
    },
    
    leaveCustomLobby() {
        if (CustomLobby.currentLobby) {
            CustomLobby.leave(CustomLobby.currentLobby.id, this.state.playerName || 'Player');
        }
        document.getElementById('lobby-waiting-overlay').classList.add('hidden');
        this.proceedToQueue();
    },
    
    startCustomLobby() {
        const lobby = CustomLobby.currentLobby;
        if (!lobby || lobby.players.length < 2) return;
        
        CustomLobby.start(lobby.id);
        
        this.state.matchMode = 'custom';
        this.state.customLobbySettings = lobby.settings;
        
        document.getElementById('lobby-waiting-overlay').classList.add('hidden');
        this.showDeitySelection(0);
    },
    
    refreshLobbies() {
        const container = document.getElementById('lobby-list');
        const lobbies = CustomLobby.getOpenLobbies();
        
        if (lobbies.length === 0) {
            container.innerHTML = '<p class="lobby-empty">No open lobbies available. Create one!</p>';
            return;
        }
        
        container.innerHTML = lobbies.map(lobby => `
            <div class="lobby-item">
                <div class="lobby-item-info">
                    <h4>${lobby.settings.name}</h4>
                    <p>Host: ${lobby.host} | ${lobby.players.length}/${lobby.maxPlayers} players | ${lobby.settings.startingEssence} Essence</p>
                </div>
                <button class="lobby-item-join" onclick="Game.joinLobby('${lobby.id}')">Join</button>
            </div>
        `).join('');
    },
    
    joinLobby(lobbyId) {
        const playerName = this.state.playerName || 'Player';
        const result = CustomLobby.join(lobbyId, playerName);
        
        if (result.success) {
            document.getElementById('custom-lobby-overlay').classList.add('hidden');
            this.showLobbyWaiting(result.lobby);
        } else {
            this.showPrompt(result.error);
        }
    },

    requestFullscreen() {
        const elem = document.documentElement;
        const goToGame = () => {
            document.getElementById('fullscreen-prompt').classList.add('hidden');
            this.state.matchMode = 'casual';
            this.showDeitySelection(0);
        };
        if (elem.requestFullscreen) {
            elem.requestFullscreen().then(goToGame).catch(goToGame);
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
            goToGame();
        } else {
            goToGame();
        }
    },

    enterCombatMode() {
        if (this.state.currentPhase !== 'clash') {
            this.showPrompt('Attacks can only be declared during Clash phase!');
            return;
        }
        this.state.combat.mode = 'selectAttacker';
        this.showPrompt('Select an Avatar to attack with');
        this.render();
    },

    exitCombatMode() {
        this.state.combat.mode = null;
        this.state.combat.selectedAttacker = null;
        this.state.combat.selectedTarget = null;
        this.state.combat.declaredAttackers = [];
        this.state.combat.declaredBlockers = {};
        this.state.combat.pendingCombatResolution = false;
        this.hidePrompt();
        this.hideBattleOverlay();
        this.hideBlockerOverlay();
        this.render();
    },
    
    // ==================== ENHANCED COMBAT: BLOCKER DECLARATION ====================
    
    /**
     * Toggle an attacker for batch attack declaration
     * Allows selecting multiple attackers before committing
     */
    toggleAttacker(card, playerIndex) {
        if (playerIndex !== this.state.currentPlayer) {
            this.showPrompt('You can only attack with your own Avatars!');
            return;
        }
        
        const existingIndex = this.state.combat.declaredAttackers.findIndex(
            a => a.card.instanceId === card.instanceId
        );
        
        if (existingIndex !== -1) {
            // Deselect attacker
            this.state.combat.declaredAttackers.splice(existingIndex, 1);
            this.log(`${card.name} will not attack`, 'action');
        } else {
            // Validate attacker can attack
            if (card.tapped) {
                this.showPrompt('This Avatar is tapped and cannot attack!');
                return;
            }
            if (this.state.combat.attackedThisTurn.includes(card.instanceId)) {
                this.showPrompt('This Avatar has already attacked this turn!');
                return;
            }
            if (this.hasSummoningSickness(card)) {
                this.showPrompt('This Avatar has summoning sickness!');
                return;
            }
            
            // Add to declared attackers (defaulting to deity target)
            this.state.combat.declaredAttackers.push({
                card: card,
                targetType: 'deity',
                targetCard: null
            });
            this.log(`${card.name} declared as attacker`, 'action');
        }
        
        this.render();
        this.highlightDeclaredAttackers();
    },
    
    /**
     * Highlight cards that are declared as attackers
     */
    highlightDeclaredAttackers() {
        document.querySelectorAll('.game-card').forEach(el => {
            el.classList.remove('declared-attacker');
        });
        
        this.state.combat.declaredAttackers.forEach(({ card }) => {
            const cardEl = document.querySelector(`[data-instance-id="${card.instanceId}"]`);
            if (cardEl) {
                cardEl.classList.add('declared-attacker');
            }
        });
    },
    
    /**
     * Confirm all declared attackers and move to blocker phase
     * Called when player clicks "Attack!" after selecting attackers
     */
    confirmAttackers() {
        const attackers = this.state.combat.declaredAttackers;
        
        if (attackers.length === 0) {
            this.showPrompt('Select at least one Avatar to attack with!');
            return;
        }
        
        this.log(`Declared ${attackers.length} attackers`, 'phase');
        
        // Check if opponent has any valid blockers
        const defenderIndex = 1 - this.state.currentPlayer;
        const validBlockers = this.getValidBlockers(defenderIndex);
        
        if (validBlockers.length === 0 || defenderIndex === 1) {
            // No blockers OR AI defender - skip to combat resolution
            // AI will auto-block, then we resolve
            if (defenderIndex === 1) {
                this.aiDeclareBlockers();
            }
            this.showBlockerSummaryAndResolve();
        } else {
            // Human defender - show blocker selection
            this.state.combat.mode = 'declareBlockers';
            this.showBlockerSelectionUI();
        }
    },
    
    /**
     * AI automatically declares blockers based on strategy
     */
    aiDeclareBlockers() {
        const aiIndex = 1;
        const validBlockers = this.getValidBlockers(aiIndex);
        const attackers = this.state.combat.declaredAttackers;
        
        if (validBlockers.length === 0 || attackers.length === 0) {
            return;
        }
        
        // Sort blockers by health (prefer blocking with high-health units)
        const sortedBlockers = [...validBlockers].sort((a, b) => 
            (b.health || 0) - (a.health || 0)
        );
        
        // Sort attackers by attack power (block strongest first)
        const sortedAttackers = [...attackers].sort((a, b) => 
            (b.card.attack || 0) - (a.card.attack || 0)
        );
        
        // AI blocking strategy: block strongest attackers with best blockers
        const usedBlockers = new Set();
        
        for (const attackerData of sortedAttackers) {
            const attacker = attackerData.card;
            
            // Find best available blocker
            const blocker = sortedBlockers.find(b => 
                !usedBlockers.has(b.instanceId) &&
                (b.health || 0) > 0
            );
            
            if (blocker) {
                // Only block if it makes strategic sense
                // Block if blocker survives OR trades favorably OR protects significant essence
                const blockerHealth = blocker.healthCurrent || blocker.health || 0;
                const attackerPower = attacker.attack || 0;
                const blockerPower = blocker.attack || 0;
                const attackerHealth = attacker.healthCurrent || attacker.health || 0;
                
                const blockerDies = attackerPower >= blockerHealth;
                const attackerDies = blockerPower >= attackerHealth;
                
                // Block if: we trade, or we survive, or attacker deals 3+ damage to essence
                const shouldBlock = (blockerDies && attackerDies) || 
                                   !blockerDies || 
                                   attackerPower >= 3;
                
                if (shouldBlock) {
                    this.state.combat.declaredBlockers[attacker.instanceId] = blocker;
                    usedBlockers.add(blocker.instanceId);
                    this.log(`${blocker.name} blocks ${attacker.name}`, 'action');
                }
            }
        }
    },
    
    /**
     * Show blocker selection UI for human defender
     */
    showBlockerSelectionUI() {
        const defenderIndex = 1 - this.state.currentPlayer;
        const validBlockers = this.getValidBlockers(defenderIndex);
        
        const overlay = document.getElementById('blocker-overlay') || this.createBlockerOverlay();
        
        const attackersHtml = this.state.combat.declaredAttackers.map(({ card }) => {
            const blocker = this.state.combat.declaredBlockers[card.instanceId];
            return `
                <div class="blocker-attacker-slot" data-attacker-id="${card.instanceId}">
                    <div class="blocker-attacker-card">
                        <img src="${card.image}" alt="${card.name}">
                        <div class="blocker-card-name">${card.name}</div>
                        <div class="blocker-card-stats">${card.attack} / ${card.healthCurrent || card.health}</div>
                    </div>
                    <div class="blocker-arrow">‚Üí</div>
                    <div class="blocker-slot ${blocker ? 'assigned' : 'empty'}" 
                         data-attacker-id="${card.instanceId}"
                         onclick="Game.clearBlocker(${card.instanceId})">
                        ${blocker ? `
                            <img src="${blocker.image}" alt="${blocker.name}">
                            <div class="blocker-card-name">${blocker.name}</div>
                        ` : '<span class="no-blocker">No Blocker</span>'}
                    </div>
                </div>
            `;
        }).join('');
        
        const blockersHtml = validBlockers.map(card => {
            const isAssigned = Object.values(this.state.combat.declaredBlockers)
                .some(b => b?.instanceId === card.instanceId);
            return `
                <div class="blocker-available-card ${isAssigned ? 'assigned' : ''}" 
                     data-blocker-id="${card.instanceId}"
                     onclick="Game.selectBlocker(${card.instanceId})">
                    <img src="${card.image}" alt="${card.name}">
                    <div class="blocker-card-name">${card.name}</div>
                    <div class="blocker-card-stats">${card.attack} / ${card.healthCurrent || card.health}</div>
                </div>
            `;
        }).join('');
        
        overlay.innerHTML = `
            <div class="blocker-container">
                <div class="blocker-header">
                    <h2>Declare Blockers</h2>
                    <p>Assign blockers to incoming attackers, or let them through to deal Essence damage</p>
                </div>
                <div class="blocker-attackers">
                    <h3>Incoming Attackers</h3>
                    <div class="blocker-attacker-list">${attackersHtml}</div>
                </div>
                <div class="blocker-available">
                    <h3>Available Blockers</h3>
                    <div class="blocker-available-list">${blockersHtml}</div>
                </div>
                <div class="blocker-actions">
                    <button class="battle-btn confirm" onclick="Game.confirmBlockers()">Confirm Blockers</button>
                    <button class="battle-btn skip" onclick="Game.skipBlockers()">Take All Damage</button>
                </div>
            </div>
        `;
        
        overlay.classList.add('visible');
    },
    
    /**
     * Create the blocker overlay element if it doesn't exist
     */
    createBlockerOverlay() {
        const overlay = document.createElement('div');
        overlay.id = 'blocker-overlay';
        overlay.className = 'blocker-overlay';
        document.body.appendChild(overlay);
        return overlay;
    },
    
    /**
     * Hide the blocker overlay
     */
    hideBlockerOverlay() {
        const overlay = document.getElementById('blocker-overlay');
        if (overlay) {
            overlay.classList.remove('visible');
        }
    },
    
    /**
     * Player selected a blocker to assign
     */
    selectBlocker(blockerInstanceId) {
        const defenderIndex = 1 - this.state.currentPlayer;
        const player = this.state.players[defenderIndex];
        const blocker = player.avatarRow.find(c => c.instanceId === blockerInstanceId);
        
        if (!blocker) return;
        
        // Check if already assigned
        const isAlreadyAssigned = Object.values(this.state.combat.declaredBlockers)
            .some(b => b?.instanceId === blockerInstanceId);
        
        if (isAlreadyAssigned) {
            this.showPrompt('This blocker is already assigned!');
            return;
        }
        
        // Store for next click on attacker slot
        this.state.combat.pendingBlocker = blocker;
        this.showPrompt(`Select an attacker to block with ${blocker.name}`);
    },
    
    /**
     * Assign pending blocker to an attacker
     */
    assignBlockerToAttacker(attackerInstanceId) {
        const blocker = this.state.combat.pendingBlocker;
        if (!blocker) {
            this.showPrompt('Select a blocker first!');
            return;
        }
        
        const attackerData = this.state.combat.declaredAttackers.find(
            a => a.card.instanceId === attackerInstanceId
        );
        
        if (!attackerData) return;
        
        this.state.combat.declaredBlockers[attackerInstanceId] = blocker;
        this.state.combat.pendingBlocker = null;
        this.log(`${blocker.name} will block ${attackerData.card.name}`, 'action');
        
        this.showBlockerSelectionUI(); // Refresh UI
    },
    
    /**
     * Clear a blocker assignment
     */
    clearBlocker(attackerInstanceId) {
        const blocker = this.state.combat.declaredBlockers[attackerInstanceId];
        if (blocker) {
            this.log(`${blocker.name} no longer blocking`, 'action');
            delete this.state.combat.declaredBlockers[attackerInstanceId];
            this.showBlockerSelectionUI(); // Refresh UI
        }
    },
    
    /**
     * Skip blocking and take all damage
     */
    skipBlockers() {
        this.state.combat.declaredBlockers = {};
        this.log('No blockers declared', 'action');
        this.hideBlockerOverlay();
        this.showBlockerSummaryAndResolve();
    },
    
    /**
     * Confirm blocker assignments and proceed to resolution
     */
    confirmBlockers() {
        const blockerCount = Object.keys(this.state.combat.declaredBlockers).length;
        this.log(`Confirmed ${blockerCount} blockers`, 'phase');
        this.hideBlockerOverlay();
        this.showBlockerSummaryAndResolve();
    },
    
    /**
     * Show summary and resolve all combat simultaneously
     */
    showBlockerSummaryAndResolve() {
        const attackers = this.state.combat.declaredAttackers;
        const blockers = this.state.combat.declaredBlockers;
        
        this.state.combat.mode = 'resolving';
        this.log('=== COMBAT RESOLUTION ===', 'phase');
        
        // Process each attacker
        let delay = 0;
        const delayIncrement = 800;
        
        for (const attackerData of attackers) {
            const attacker = attackerData.card;
            const blocker = blockers[attacker.instanceId];
            
            setTimeout(() => {
                if (blocker) {
                    // Blocked combat - Power vs Guard exchange
                    this.resolveBlockedCombat(attacker, blocker);
                } else {
                    // Unblocked - damage goes to Essence
                    this.resolveUnblockedAttack(attacker);
                }
            }, delay);
            
            delay += delayIncrement;
        }
        
        // After all combat, finalize damage and tap attackers
        setTimeout(() => {
            this.finalizeCombatRound();
        }, delay + 400);
    },
    
    /**
     * Resolve blocked combat using Power vs Guard damage exchange
     */
    resolveBlockedCombat(attacker, blocker) {
        const attackerOwner = this.state.currentPlayer;
        const defenderOwner = 1 - attackerOwner;
        
        const { damageToDefender, damageToAttacker } = this.calculateCombatDamage(attacker, blocker);
        
        this.log(`${attacker.name} (${attacker.attack}) fights ${blocker.name} (${blocker.attack})`, 'action');
        
        // Apply temp damage to both
        this.applyTempDamage(blocker, damageToDefender);
        this.applyTempDamage(attacker, damageToAttacker);
        
        // Visual effects
        this.spawnDamageNumber(`card-${attacker.instanceId}`, damageToAttacker);
        this.spawnDamageNumber(`card-${blocker.instanceId}`, damageToDefender);
        this.screenShake('light');
        
        // Trigger on-attack effects
        this.handleOnAttackTrigger(attacker, blocker, attackerOwner);
        this.handleOnDealDamageTrigger(attacker, damageToDefender, attackerOwner, false);
    },
    
    /**
     * Resolve unblocked attack to opponent's Essence
     */
    resolveUnblockedAttack(attacker) {
        const attackerOwner = this.state.currentPlayer;
        const defenderIndex = 1 - attackerOwner;
        const damage = attacker.attack || 0;
        
        this.log(`${attacker.name} deals ${damage} damage to Essence!`, 'damage');
        
        // Apply damage to Essence
        this.dealDamageToEssence(defenderIndex, damage);
        
        // Trigger on-attack effects
        this.handleOnAttackTrigger(attacker, { type: 'deity', playerIndex: defenderIndex }, attackerOwner);
        this.handleOnDealDamageTrigger(attacker, damage, attackerOwner, true);
    },
    
    /**
     * Finalize combat round - apply permanent damage, destroy dead cards, tap attackers
     */
    finalizeCombatRound() {
        // Finalize all temp damage
        this.finalizeCombatDamage();
        
        // Tap all attackers and mark as attacked
        for (const attackerData of this.state.combat.declaredAttackers) {
            const attacker = attackerData.card;
            attacker.tapped = true;
            this.state.combat.attackedThisTurn.push(attacker.instanceId);
        }
        
        // Check win condition
        this.checkWinCondition();
        
        // Clear combat state
        this.state.combat.declaredAttackers = [];
        this.state.combat.declaredBlockers = {};
        this.state.combat.pendingBlocker = null;
        this.state.combat.mode = null;
        
        this.log('Combat resolved', 'phase');
        this.hidePrompt();
        this.render();
    },

    selectAttacker(card, playerIndex) {
        if (playerIndex !== this.state.currentPlayer) {
            this.showPrompt('You can only attack with your own Avatars!');
            return;
        }
        if (card.tapped) {
            this.showPrompt('This Avatar is tapped and cannot attack!');
            return;
        }
        if (this.state.combat.attackedThisTurn.includes(card.instanceId)) {
            this.showPrompt('This Avatar has already attacked this turn!');
            return;
        }
        if (this.state.combat.summonedThisTurn.includes(card.instanceId)) {
            this.showPrompt('This Avatar has summoning sickness and cannot attack!');
            return;
        }

        this.state.combat.selectedAttacker = card;
        this.state.combat.mode = 'selectTarget';
        this.emitEvent('ON_ATTACK_DECLARED', { attacker: card, playerIndex });
        this.showPrompt('Select a target to attack (enemy Avatar or Deity)');
        this.render();
        
    },

    selectTarget(card, playerIndex) {
        if (playerIndex === this.state.currentPlayer) {
            this.showPrompt('You cannot attack your own units!');
            return;
        }
        
        if (!this.validateGuardianTarget(card, playerIndex)) {
            return;
        }

        this.state.combat.selectedTarget = card;
        this.showBattleOverlay();
    },
    
    getGuardians(playerIndex) {
        const p = this.state.players[playerIndex];
        return [...p.avatarRow, ...p.domainRow].filter(c => hasGuardian(c));
    },
    
    validateGuardianTarget(target, defenderIndex) {
        const guardians = this.getGuardians(defenderIndex);
        
        if (guardians.length === 0) return true;
        
        const isTargetGuardian = hasGuardian(target);
        if (!isTargetGuardian) {
            const guardianNames = guardians.map(g => g.name).join(', ');
            this.showPrompt(`Guardian Active! You must attack ${guardianNames} first!`);
            return false;
        }
        
        return true;
    },

    attackDeity(playerIndex) {
        if (this.state.combat.mode !== 'selectTarget') return;
        if (playerIndex === this.state.currentPlayer) {
            this.showPrompt('You cannot attack your own Deity!');
            return;
        }

        const opponent = this.state.players[playerIndex];
        
        const guardians = this.getGuardians(playerIndex);
        if (guardians.length > 0) {
            const guardianNames = guardians.map(g => g.name).join(', ');
            this.showPrompt(`Guardian Active! You must attack ${guardianNames} first!`);
            return;
        }
        
        this.state.combat.selectedTarget = { type: 'deity', playerIndex };
        this.showBattleOverlay();
    },

    showBattleOverlay() {
        const overlay = document.getElementById('battle-overlay');
        const attacker = this.state.combat.selectedAttacker;
        const target = this.state.combat.selectedTarget;

        if (!overlay || !attacker || !target) return;

        const isDeity = target.type === 'deity';
        const targetData = isDeity ? this.state.players[target.playerIndex].deity : target;
        
        overlay.innerHTML = `
            <div class="battle-container">
                <div class="battle-card attacker">
                    <img src="${attacker.image}" alt="${attacker.name}">
                    <div class="battle-name">${attacker.name}</div>
                    <div class="battle-stats">
                        <span class="atk">${attacker.attack} ATK</span>
                    </div>
                </div>
                <div class="battle-vs">
                    <div class="vs-text">VS</div>
                    <div class="damage-preview">
                        ${isDeity ? attacker.attack : Math.max(0, attacker.attack - (targetData.healthCurrent || targetData.health))} DMG
                    </div>
                </div>
                <div class="battle-card defender ${isDeity ? 'deity-target' : ''}">
                    <img src="${targetData.image}" alt="${targetData.name}">
                    <div class="battle-name">${targetData.name}</div>
                    <div class="battle-stats">
                        ${isDeity ? `<span class="hp">${this.state.players[target.playerIndex].essence} ESS</span>` : 
                        `<span class="hp">${targetData.healthCurrent || targetData.health} HP</span>`}
                    </div>
                </div>
            </div>
            <div class="battle-actions">
                <button class="battle-btn confirm" onclick="Game.resolveCombat()">ATTACK!</button>
                <button class="battle-btn cancel" onclick="Game.exitCombatMode()">Cancel</button>
            </div>
        `;

        overlay.classList.add('visible');
    },

    hideBattleOverlay() {
        document.getElementById('battle-overlay')?.classList.remove('visible');
    },

    resolveCombat() {
        const attacker = this.state.combat.selectedAttacker;
        const target = this.state.combat.selectedTarget;

        if (!attacker || !target) return;

        this.hideBattleOverlay();
        
        const attackerEl = document.querySelector(`[data-card-id="${attacker.instanceId}"]`);
        if (attackerEl) {
            this.animateAttack(attackerEl, target);
        }

        setTimeout(() => {
            this.handleOnAttackTrigger(attacker, target, this.state.currentPlayer);
            
            if (target.type === 'deity') {
                this.dealDamageToDeity(target.playerIndex, attacker.attack);
                this.handleOnDealDamageTrigger(attacker, attacker.attack, this.state.currentPlayer, true);
            } else {
                this.dealDamageToCard(target, attacker.attack, 1 - this.state.currentPlayer);
                this.dealDamageToCard(attacker, target.attack, this.state.currentPlayer);
                this.handleOnDealDamageTrigger(attacker, attacker.attack, this.state.currentPlayer, false);
            }

            this.state.combat.attackedThisTurn.push(attacker.instanceId);
            attacker.tapped = true;
            
            this.checkWinCondition();
            this.exitCombatMode();
        }, 600);
    },
    
    handleOnAttackTrigger(attacker, target, attackerOwner) {
        if (!this.state.rulesHelper || !attacker.effect) return;
        
        const effect = attacker.effect.toLowerCase();
        
        if (effect.includes('when') && effect.includes('attack')) {
            if (effect.includes('+1 essence damage')) {
                if (target.type === 'deity') {
                    this.adjustStat(target.playerIndex, 'essence', -1);
                    this.log(`${attacker.name}: +1 Essence damage on attack!`, 'damage');
                }
            }
            
            if (effect.includes('draw a card')) {
                this.drawCardEffect(attackerOwner, 1);
                this.log(`${attacker.name}: Drew 1 card on attack`, 'action');
            }
            
            if (effect.includes('+1 kl')) {
                this.adjustStat(attackerOwner, 'kl', 1);
                this.log(`${attacker.name}: +1 KL on attack`, 'action');
            }
        }
    },
    
    handleOnDealDamageTrigger(source, damage, sourceOwner, hitDeity) {
        if (!this.state.rulesHelper || !source.effect) return;
        
        const effect = source.effect.toLowerCase();
        
        if (hitDeity && effect.includes('deals essence damage') && effect.includes('deity')) {
            if (effect.includes('gain') && effect.includes('essence')) {
                const match = effect.match(/gain (\d+) essence/i);
                const amount = match ? parseInt(match[1]) : 1;
                this.adjustStat(sourceOwner, 'essence', amount);
                this.log(`${source.name}: +${amount} Essence (lifesteal)`, 'heal');
            }
            
            if (effect.includes('drain') && effect.includes('kl')) {
                const match = effect.match(/drain (\d+) kl/i);
                const amount = match ? parseInt(match[1]) : 1;
                this.adjustStat(1 - sourceOwner, 'kl', -amount);
                this.log(`${source.name}: Drained ${amount} KL!`, 'damage');
            }
        }
    },

    animateAttack(element, target) {
        if (!element) return;
        
        element.classList.add('attacking');
        
        // Handle deity vs creature attacks separately
        if (target.type === 'deity') {
            // Direct attack on opponent's deity - use directAttack effect
            BattleEffects.directAttack(element, target.playerIndex);
        } else {
            // Creature vs creature combat - use attackSlash if target element exists
            const targetEl = document.querySelector(`[data-card-id="${target.instanceId}"]`);
            if (targetEl) {
                BattleEffects.attackSlash(element, targetEl);
            } else {
                // Fallback: just screen shake if no target element found
                BattleEffects.screenShake(10, 300);
            }
        }
        
        setTimeout(() => {
            element.classList.remove('attacking');
        }, 500);
    },

    dealDamageToCard(card, damage, ownerIndex) {
        if (!card || card.type === 'deity') return;

        card.healthCurrent = (card.healthCurrent || card.health) - damage;
        
        this.showDamageNumber(card, damage);
        this.spawnParticles(card, 'damage');
        
        this.log(`${card.name} takes ${damage} damage!`, 'damage');

        if (card.healthCurrent <= 0) {
            this.destroyCard(card, ownerIndex);
        }

        this.render();
    },

    dealDamageToDeity(playerIndex, damage) {
        const player = this.state.players[playerIndex];
        player.essence -= damage;

        this.showDamageNumber({ type: 'deity', playerIndex }, damage);
        this.spawnParticles({ type: 'deity', playerIndex }, 'damage');
        this.screenShake(damage > 5 ? 'heavy' : 'light');
        
        const essenceBar = document.getElementById(`p${playerIndex + 1}-essence-bar`);
        if (essenceBar) {
            AnimationHelper.play('essence-damage', essenceBar.parentElement, { amount: damage, isHeal: false });
            AnimationHelper.play('stat-pulse', essenceBar.parentElement, { color: 'damage' });
        }
        
        this.log(`Player ${playerIndex + 1}'s Deity takes ${damage} damage!`, 'damage');
        
        if (this.state.matchMode === 'campaign') {
            CampaignManager.applyBossAbility('damage', { targetPlayer: playerIndex, damage });
        }

        if (player.essence <= 0) {
            player.essence = 0;
            this.checkWinCondition();
        }
        
        this.render();
    },

    destroyCard(card, ownerIndex) {
        const player = this.state.players[ownerIndex];
        
        ['front', 'support', 'avatarRow', 'domainRow', 'relicRow'].forEach(zone => {
            if (!player[zone]) return;
            const idx = player[zone].findIndex(c => c.instanceId === card.instanceId);
            if (idx > -1) {
                player[zone].splice(idx, 1);
                player.graveyard.push(card);
            }
        });

        this.spawnParticles(card, 'destroy');
        this.log(`${card.name} was destroyed!`, 'damage');
        
        this.handleOnDeathTrigger(card, ownerIndex);
        this.handleDeityDeathPassive(card, ownerIndex);
        
        const cardEl = document.querySelector(`[data-card-id="${card.instanceId}"]`);
        if (cardEl) {
            BattleEffects.cardDestroyed(cardEl);
            cardEl.classList.add('destroying');
            setTimeout(() => this.render(), 500);
        }
    },
    
    handleOnDeathTrigger(card, ownerIndex) {
        if (!this.state.rulesHelper || !card.effect) return;
        
        const effect = card.effect.toLowerCase();
        
        if (effect.includes('when') && (effect.includes('dies') || effect.includes('destroyed'))) {
            if (effect.includes('opponent loses') && effect.includes('essence')) {
                const match = effect.match(/loses (\d+) essence/i);
                const amount = match ? parseInt(match[1]) : 1;
                this.adjustStat(1 - ownerIndex, 'essence', -amount);
                this.log(`${card.name}: Opponent lost ${amount} Essence on death!`, 'damage');
            }
            
            if (effect.includes('draw')) {
                const match = effect.match(/draw (\d+)/i);
                const amount = match ? parseInt(match[1]) : 1;
                this.drawCardEffect(ownerIndex, amount);
                this.log(`${card.name}: Drew ${amount} card(s) on death`, 'action');
            }
            
            if (effect.includes('gain') && effect.includes('essence')) {
                const match = effect.match(/gain (\d+) essence/i);
                const amount = match ? parseInt(match[1]) : 1;
                this.adjustStat(ownerIndex, 'essence', amount);
                this.log(`${card.name}: +${amount} Essence on death`, 'heal');
            }
        }
    },
    
    handleDeityDeathPassive(card, ownerIndex) {
        if (!this.state.rulesHelper) return;
        
        const player = this.state.players[ownerIndex];
        const deity = player.deity;
        if (!deity || !deity.passive) return;
        
        if (deity.passive === 'Dark Bond' && isBeastCard(card)) {
            this.adjustStat(1 - ownerIndex, 'essence', -1);
            this.log(`${deity.passive}: Beast died - opponent lost 1 Essence!`, 'damage');
        }
        
        if (deity.passive === 'Grid Drain') {
            const opponent = 1 - ownerIndex;
            if (this.state.currentPlayer !== ownerIndex) {
                this.adjustStat(opponent, 'kl', -1);
                this.log(`${deity.passive}: Enemy Avatar died - drained 1 KL!`, 'damage');
            }
        }
    },

    showDamageNumber(target, damage) {
        const container = document.getElementById('damage-numbers');
        if (!container) return;

        const dmgEl = document.createElement('div');
        dmgEl.className = 'damage-number';
        dmgEl.textContent = `-${damage}`;

        let x = window.innerWidth / 2;
        let y = window.innerHeight / 2;

        if (target.type === 'deity') {
            const deityEl = document.getElementById(target.playerIndex === 0 ? 'p1-deity' : 'p2-deity');
            if (deityEl) {
                const rect = deityEl.getBoundingClientRect();
                x = rect.left + rect.width / 2;
                y = rect.top + rect.height / 2;
            }
        } else {
            const cardEl = document.querySelector(`[data-card-id="${target.instanceId}"]`);
            if (cardEl) {
                const rect = cardEl.getBoundingClientRect();
                x = rect.left + rect.width / 2;
                y = rect.top + rect.height / 2;
            }
        }

        dmgEl.style.left = x + 'px';
        dmgEl.style.top = y + 'px';
        container.appendChild(dmgEl);

        setTimeout(() => dmgEl.remove(), 1500);
    },

    spawnParticles(target, type = 'damage') {
        const canvas = document.getElementById('particle-canvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let x = canvas.width / 2;
        let y = canvas.height / 2;

        if (target.type === 'deity') {
            const deityEl = document.getElementById(target.playerIndex === 0 ? 'p1-deity' : 'p2-deity');
            if (deityEl) {
                const rect = deityEl.getBoundingClientRect();
                x = rect.left + rect.width / 2;
                y = rect.top + rect.height / 2;
            }
        } else if (target.instanceId) {
            const cardEl = document.querySelector(`[data-card-id="${target.instanceId}"]`);
            if (cardEl) {
                const rect = cardEl.getBoundingClientRect();
                x = rect.left + rect.width / 2;
                y = rect.top + rect.height / 2;
            }
        }

        const particles = [];
        const colors = type === 'destroy' ? ['#ff4444', '#ff8800', '#ffcc00'] : ['#ff4444', '#ff6666'];
        const count = type === 'destroy' ? 30 : 15;

        for (let i = 0; i < count; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 15,
                vy: (Math.random() - 0.5) * 15 - 5,
                size: Math.random() * 8 + 4,
                color: colors[Math.floor(Math.random() * colors.length)],
                life: 1
            });
        }

        const animate = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let alive = false;

            particles.forEach(p => {
                if (p.life <= 0) return;
                alive = true;
                
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= 0.02;
                p.size *= 0.98;

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fill();
            });

            ctx.globalAlpha = 1;
            if (alive) requestAnimationFrame(animate);
        };

        animate();
    },

    screenShake(intensity = 'light') {
        const board = document.getElementById('game-board');
        if (!board) return;

        const className = intensity === 'heavy' ? 'shake-heavy' : 'shake-light';
        board.classList.add(className);
        setTimeout(() => board.classList.remove(className), 300);
    },

    showPrompt(message) {
        let prompt = document.getElementById('action-prompt');
        if (!prompt) {
            prompt = document.createElement('div');
            prompt.id = 'action-prompt';
            document.getElementById('game-container').appendChild(prompt);
        }

        let messageEl = document.getElementById('action-prompt-message');
        if (!messageEl) {
            messageEl = document.createElement('div');
            messageEl.id = 'action-prompt-message';
            messageEl.className = 'action-prompt-message';
            prompt.prepend(messageEl);
        }

        let closeBtn = document.getElementById('draw-phase-warning-close');
        if (!closeBtn) {
            closeBtn = document.createElement('button');
            closeBtn.id = 'draw-phase-warning-close';
            closeBtn.className = 'ec-dialog-close';
            closeBtn.textContent = 'OK';
            prompt.appendChild(closeBtn);
        }

        closeBtn.onclick = () => this.hideDrawPhaseWarning();
        messageEl.textContent = message;
        prompt.style.display = 'block';
        prompt.classList.add('visible');
    },

    hidePrompt() {
        const prompt = document.getElementById('action-prompt');
        if (!prompt) return;
        prompt.classList.remove('visible');
        prompt.style.display = 'none';
    },

    hideDrawPhaseWarning() {
        this.hidePrompt();
    },

    checkWinCondition() {
        for (let i = 0; i < 2; i++) {
            if (this.state.players[i].essence <= 0) {
                this.state.gameOver = true;
                this.showVictoryScreen(1 - i);
                return true;
            }
        }
        return false;
    },
    
    // === ESSENCE CROWN: Game end handler for various win/loss conditions ===
    triggerGameEnd(winnerIndex, reason = 'essence') {
        this.state.gameOver = true;
        
        // Log the win condition
        const reasonMessages = {
            essence: 'Essence reduced to 0',
            deck_out: 'Deck exhausted (deck out)',
            concede: 'Opponent conceded',
            timeout: 'Turn timer expired'
        };
        this.log(`Game Over: ${reasonMessages[reason] || reason}`, 'phase');
        
        // Store the reason for the victory screen
        this.state.gameEndReason = reason;
        
        // Trigger victory screen
        this.showVictoryScreen(winnerIndex);
    },

    showVictoryScreen(winnerIndex) {
        MatchRecorder.endRecording(winnerIndex);
        
        const playerWon = winnerIndex === 0;
        ShardPath.recordMatchResult(playerWon, this.state.cardsPlayedThisMatch || [], this.state.damageDealtThisMatch || 0);
        
        if (!this.state.isPrivateMatch && this.state.matchMode === 'ranked' && winnerIndex === 0) {
            Matchmaking.updateMMR(true);
        } else if (!this.state.isPrivateMatch && this.state.matchMode === 'ranked' && winnerIndex === 1) {
            Matchmaking.updateMMR(false);
        }
        
        if (this.state.matchMode === 'tournament' && this.state.tournamentMatchId) {
            const playerId = Matchmaking.playerProfile.playerId;
            const winnerId = winnerIndex === 0 ? playerId : 'opponent';
            this.reportTournamentResult(winnerId);
        }
        if (this.state.matchMode === 'sealed') {
            LimitedMode.endSealed();
        }
        
        let rewardText = '';
        let shardsEarned = 0;
        
        const matchReward = RewardsSystem.getMatchRewards(
            playerWon,
            this.state.matchMode,
            this.state.aiDifficulty
        );
        shardsEarned = matchReward;
        
        if (this.state.isAIMatch && playerWon) {
            AIManager.onMatchEnd(true);
            const rewards = { easy: 232, medium: 247, hard: 272, boss: 322 };
            shardsEarned = rewards[this.state.aiDifficulty] || 247;
        }
        
        if (this.state.matchMode === 'campaign' && playerWon && this.state.currentBoss) {
            CampaignManager.onBossDefeated(this.state.currentBoss.id);
            shardsEarned = this.state.currentBoss.reward;
            rewardText = `<p class="reward-text">BOSS DEFEATED!</p>`;
        }
        
        if (shardsEarned > 0) {
            ShardPath.addCurrency(shardsEarned);
            rewardText += `<p class="reward-text">üíé +${shardsEarned} Shards</p>`;
        }
        
        if (this.state.matchMode === 'ranked' && playerWon && !this.state.isPrivateMatch) {
            const rankResult = RewardsSystem.checkRankUp();
            if (rankResult.rankedUp && rankResult.rewards && !rankResult.rewards.alreadyClaimed) {
                setTimeout(() => {
                    RewardsSystem.showRankUpNotification(rankResult.newTier, rankResult.rewards);
                }, 1500);
            }
        }
        
        PlayerProfile.recordMatch(playerWon, 'Opponent', this.state.matchMode || 'Battle');
        
        EventManager.clearActiveEvent();
        
        // Play victory/defeat music and trigger effects
        if (playerWon) {
            AudioManager.play('victory');
            BattleEffects.victorySequence();
        } else {
            AudioManager.play('defeat');
            BattleEffects.defeatSequence();
        }
        
        const overlay = document.createElement('div');
        overlay.id = 'victory-overlay';
        const tierInfo = Matchmaking.mmoToTier(Matchmaking.playerProfile.mmr);
        const mmrText = this.state.matchMode === 'ranked' ? `<p class="mmr-update">MMR: ${tierInfo.tier} ${tierInfo.level} (${Matchmaking.playerProfile.mmr} MMR)</p>` : '';
        const eventText = this.state.eventId ? `<p class="event-mode">Event Mode</p>` : '';
        const tournamentText = this.state.tournamentId ? `<p class="tournament-mode">Tournament Match</p>` : '';
        
        const winTitle = playerWon ? 'VICTORY' : 'DEFEAT';
        const winMsg = playerWon ? 'You Win!' : 'You Lost...';
        
        overlay.innerHTML = `
            <div class="victory-content ${playerWon ? '' : 'defeat'}">
                <h1 class="victory-title">${winTitle}</h1>
                <p class="victory-text">${winMsg}</p>
                ${rewardText}
                ${mmrText}
                ${eventText}
                ${tournamentText}
                <div class="victory-buttons">
                    <button class="victory-btn" onclick="Game.returnToMenu()">Main Menu</button>
                    <button class="victory-btn secondary" onclick="location.reload()">Play Again</button>
                </div>
            </div>
        `;
        document.getElementById('game-container').appendChild(overlay);
        
        for (let i = 0; i < 50; i++) {
            this.spawnVictoryParticle();
        }
    },
    
    returnToMenu() {
        document.getElementById('victory-overlay')?.remove();
        document.getElementById('game-container').style.display = 'none';
        document.getElementById('game-controls').style.display = 'none';
        document.getElementById('pause-overlay').classList.add('hidden');
        
        // Stop battle effects
        BattleEffects.stopBattleAmbience();
        
        this.state.gameOver = false;
        this.state.isAIMatch = false;
        this.state.matchMode = null;
        this.state.currentBoss = null;
        this.state.selectedDeities = [];
        this.state.turnNumber = 1;
        this.state.currentPhase = 'dawn';
        this.state.currentPlayer = 0;
        
        MainMenu.show();
    },

    recordDeckContents(playerIndex, deck) {
        // Track deck composition for analytics
        if (!MatchRecorder.currentMatch) return;
        if (!MatchRecorder.currentMatch.deckContents) {
            MatchRecorder.currentMatch.deckContents = [{}, {}];
        }
        MatchRecorder.currentMatch.deckContents[playerIndex] = deck.map(c => c.id);
    },
    
    spawnVictoryParticle() {
        const particle = document.createElement('div');
        particle.className = 'victory-particle';
        particle.style.left = Math.random() * 100 + 'vw';
        particle.style.animationDelay = Math.random() * 3 + 's';
        particle.style.background = ['#d4af37', '#f4d03f', '#00ffcc', '#ff6b9d'][Math.floor(Math.random() * 4)];
        document.getElementById('victory-overlay')?.appendChild(particle);
    },

    startShardChain(initialLink) {
        this.state.shardChain.active = true;
        this.state.shardChain.links = [initialLink];
        this.state.shardChain.priority = 1 - this.state.currentPlayer;
        this.state.shardChain.passCount = 0;
        
        this.log(`Shard Chain activated: ${initialLink.source.name}`, 'phase');
        this.renderShardChain();
        this.promptForResponse();
    },

    addToShardChain(link) {
        this.state.shardChain.links.push(link);
        this.state.shardChain.priority = 1 - this.state.shardChain.priority;
        this.state.shardChain.passCount = 0;
        
        this.log(`Chain Link ${this.state.shardChain.links.length}: ${link.source.name}`, 'action');
        this.renderShardChain();
        this.promptForResponse();
    },

    passShardChainPriority() {
        this.state.shardChain.passCount++;
        this.state.shardChain.priority = 1 - this.state.shardChain.priority;
        
        if (this.state.shardChain.passCount >= 2) {
            this.resolveShardChain();
        } else {
            this.promptForResponse();
        }
    },

    resolveShardChain() {
        this.log('Resolving Shard Chain...', 'phase');
        
        while (this.state.shardChain.links.length > 0) {
            const link = this.state.shardChain.links.pop();
            this.log(`Resolving: ${link.source.name}`, 'action');
            
            if (link.effect) {
                this.executeShardChainEffect(link);
            }
            
            setTimeout(() => {}, 300);
        }
        
        this.state.shardChain.active = false;
        this.state.shardChain.links = [];
        this.hideShardChainPanel();
        this.render();
    },

    executeShardChainEffect(link) {
        const { source, controller, targets, effect } = link;
        
        if (effect.type === 'damage') {
            targets.forEach(target => {
                if (target.type === 'deity') {
                    this.adjustStat(target.playerIndex, 'essence', -effect.amount);
                    this.spawnParticles({ type: 'deity', playerIndex: target.playerIndex }, 'damage');
                } else if (target.card) {
                    target.card.healthCurrent = (target.card.healthCurrent || target.card.health) - effect.amount;
                    if (target.card.healthCurrent <= 0) {
                        this.destroyCard(target.card, target.playerIndex);
                    }
                }
            });
        } else if (effect.type === 'destroy') {
            targets.forEach(target => {
                if (target.card) {
                    this.destroyCard(target.card, target.playerIndex);
                }
            });
        } else if (effect.type === 'draw') {
            this.drawCardEffect(controller, effect.amount);
        } else if (effect.type === 'heal') {
            this.adjustStat(controller, 'essence', effect.amount);
        } else if (effect.type === 'buff') {
            targets.forEach(target => {
                if (target.card) {
                    target.card.attack = (target.card.attack || 0) + (effect.attackMod || 0);
                    target.card.healthCurrent = (target.card.healthCurrent || target.card.health) + (effect.healthMod || 0);
                }
            });
        }
        
        this.screenShake('light');
    },

    promptForResponse() {
        const priorityPlayer = this.state.shardChain.priority;
        const isAI = priorityPlayer === 1;
        
        if (isAI) {
            setTimeout(() => this.passShardChainPriority(), 800);
        } else {
            this.showPrompt(`Shard Chain active - Respond or Pass`);
        }
    },

    renderShardChain() {
        const panel = document.getElementById('shard-chain-panel');
        if (!panel) return;

        panel.innerHTML = `
            <div class="shard-chain-header">
                <span class="chain-title">SHARD CHAIN</span>
                <span class="chain-count">${this.state.shardChain.links.length} Link${this.state.shardChain.links.length !== 1 ? 's' : ''}</span>
            </div>
            <div class="shard-chain-links">
                ${this.state.shardChain.links.map((link, i) => `
                    <div class="chain-link" data-index="${i}">
                        <span class="link-number">${i + 1}</span>
                        <span class="link-name">${link.source.name}</span>
                        <span class="link-controller">P${link.controller + 1}</span>
                    </div>
                `).reverse().join('')}
            </div>
            <div class="shard-chain-controls">
                <button class="chain-btn pass-btn" onclick="Game.passShardChainPriority()">PASS</button>
            </div>
        `;
        
        panel.classList.add('visible');
    },

    hideShardChainPanel() {
        document.getElementById('shard-chain-panel')?.classList.remove('visible');
    },

    emitEvent(eventType, data) {
        const handlers = this.state.events[eventType] || [];
        handlers.forEach(handler => handler(data));
        
        this.checkTriggeredAbilities(eventType, data);
    },

    registerEventHandler(eventType, handler) {
        if (!this.state.events[eventType]) {
            this.state.events[eventType] = [];
        }
        this.state.events[eventType].push(handler);
    },

    checkTriggeredAbilities(eventType, data) {
        const currentPlayer = this.state.currentPlayer;
        const p = this.state.players[currentPlayer];
        
        [...p.avatarRow, ...p.domainRow].forEach(card => {
            if (this.hasTriggeredAbility(card, eventType)) {
                this.log(`${card.name} triggers on ${eventType}`, 'action');
            }
        });
    },

    hasTriggeredAbility(card, eventType) {
        if (!card.effect) return false;
        
        const triggers = {
            'ON_AVATAR_SUMMONED': /when.*enter|on.*summon|on.*play/i,
            'ON_ATTACK_DECLARED': /when.*attack|on.*attack/i,
            'ON_AVATAR_DESTROYED': /when.*die|when.*destroy|on.*death/i,
            'ON_ESSENCE_LOSS': /when.*lose.*essence|when.*damage/i
        };
        
        const pattern = triggers[eventType];
        return pattern && pattern.test(card.effect);
    },

    isFastSpell(card) {
        if (card.type !== 'Spell') return false;
        
        const fastPatterns = /quick|instant|counter|in response|during.*phase/i;
        return fastPatterns.test(card.effect || '') || card.speed === 'FAST';
    },

    canPlayDuringShardChain(card, playerIndex) {
        if (!this.state.shardChain.active) return false;
        if (this.state.shardChain.priority !== playerIndex) return false;

        return this.isFastSpell(card);
    }
};

// === ENGINE LOGIC END ===

document.addEventListener('DOMContentLoaded', () => {
    BattleEffects.init();
    PlayerProfile.init();
    RewardsSystem.init();
    AudioManager.init();
    Game.init();
    console.log('Essence Crown core game initialized (no tutorial/walkthrough modes).');
});

Game.openProfileViewer = function() {
    const profile = PlayerProfile.data;
    const tierInfo = Matchmaking.mmoToTier(Matchmaking.playerProfile.mmr);
    
    document.getElementById('profile-name').textContent = profile.name || 'Player';
    document.getElementById('profile-avatar').textContent = profile.avatar || 'üëë';
    document.getElementById('profile-tier').textContent = `${tierInfo.tier} ${tierInfo.level}`;
    document.getElementById('profile-mmr').textContent = `${Matchmaking.playerProfile.mmr} MMR`;
    
    const wins = profile.stats?.wins || 0;
    const losses = profile.stats?.losses || 0;
    const total = wins + losses;
    const winrate = total > 0 ? Math.round((wins / total) * 100) : 0;
    
    document.getElementById('profile-wins').textContent = wins;
    document.getElementById('profile-losses').textContent = losses;
    document.getElementById('profile-winrate').textContent = winrate + '%';
    document.getElementById('profile-highest').textContent = RewardsSystem.data.highestTierReached || 'Bronze III';
    
    const matchHistory = (profile.matchHistory || []).slice(-10).reverse();
    const historyHtml = matchHistory.length > 0 ? matchHistory.map(m => `
        <div class="match-entry ${m.won ? 'win' : 'loss'}">
            ${m.won ? '‚úì' : '‚úó'} vs ${m.opponent} (${m.deity}) - ${m.mode} - ${new Date(m.date).toLocaleDateString()}
        </div>
    `).join('') : '<div style="color: rgba(255,255,255,0.5);">No matches yet</div>';
    document.getElementById('profile-match-history').innerHTML = historyHtml;
    
    const ownedCosmetics = CosmeticsManager.getCosmeticsOwned();
    const cosmeticsHtml = ownedCosmetics.slice(0, 20).map(c => `
        <div class="cosmetic-preview-mini">
            <div class="cosmetic-preview-mini-icon">${Game.getCosmeticPreviewIcon(c)}</div>
            <div class="cosmetic-preview-mini-name">${c.name}</div>
        </div>
    `).join('');
    document.getElementById('profile-cosmetics-grid').innerHTML = cosmeticsHtml || '<div style="color: rgba(255,255,255,0.5); grid-column: 1/-1;">No cosmetics owned yet</div>';
    
    document.getElementById('profile-viewer-overlay').classList.remove('hidden');
};

Game.closeProfileViewer = function() {
    document.getElementById('profile-viewer-overlay').classList.add('hidden');
};

Game.showProfileTab = function(tab) {
    document.querySelectorAll('.profile-tab').forEach(t => {
        t.classList.toggle('active', t.textContent.toLowerCase().includes(tab.toLowerCase()));
    });
    document.querySelectorAll('.profile-tab-content').forEach(c => {
        c.classList.toggle('active', c.id.includes(tab));
    });
};

CosmeticsManager.getCosmeticsOwned = function() {
    return Object.keys(this.cosmetics)
        .filter(id => this.owned[id])
        .map(id => this.getCosmetic(id));
};

    </script>
</body>
</html>
